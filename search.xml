<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里云OSS+PicGo建立图床]]></title>
    <url>%2F2019%2F09%2F21%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%2BPicGo%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在本地写md文档时候插入图片是一件挺麻烦的事情，使用本地图片的话，每次在给别人分享文档或者上传博客的时候就比较难顶了。网上有两种方法可以解决这个问题，一种是使用图片的base64编码，但是图片转换为base64编码之后，编码长度会很大，文档的可读性不好，而且也会使文档的体积急剧变大，这种方法显然不太好。所以，最终使用了图床的方法将图片储存在阿里云中。 开通OSS服务​ 进入阿里云创建一个对象存储OSS的服务，之后新建一个Bucket，创建Bucket之后，我们的存储空间就创建成功了。 使用PicGo快速上传图片 PicGo下载地址https://github.com/Molunerfinn/PicGo 配置PicGo ​ KeyId和KeySecret可以从阿里的控制台获取。 ​ 储存空间名就是Bucket的名称，存储区域在访问域名可以找到。 ​ 配置完成之后就可以使用PicGo上传图片了。 踩坑记录​ 第一次使用PicGo上传图片的时候，总是提示上传失败，检查了好几遍配置，都没有什么错误，可是就是上传不了。 ​ 打开PicGo的配置文件之后，发现有下面的报错信息。 2019-09-21 21:33:11 [PicGo ERROR] StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot;------Error Stack Begin------StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot; at new StatusCodeError (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\errors.js:32:15) at Request.plumbing.callback (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:104:33) at Request.RP$callback [as _callback] (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:46:31) at Request.self.callback (E:\PicGo\resources\app.asar\node_modules\request\request.js:185:22) at Request.emit (events.js:182:13) at Request.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1157:10) at Request.emit (events.js:182:13) at IncomingMessage.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1079:12) at Object.onceWrapper (events.js:273:13) at IncomingMessage.emit (events.js:187:15)-------Error Stack End------- ​ 重点关注The difference between the request time and the current time is too large这一部分，查找阿里云OS文档，403错误及排查。看到下面的部分，就明白了出问题的原因。 ​ 由于我的电脑是Windows+Ubuntu双系统，每次切换系统的时候都会产生八个小时的时差，一直没有解决这个冲突问题，所以造成了Windows时间不正常，也就导致了今天的问题。 ​ 解决方法就很简单了，重新同步一下时钟就好了。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合类]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java众多的集合类由两大接口衍生而来：Collection接口和Map接口 CollectionList(有序，可重复)ArrayList优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程不安全，效率高。 类继承图 ArrayList.java /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 上面的elementData就是ArrayList的底层数组的实现。 Vector优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程安全，效率低。 类继承图 Vector.java /** * Appends the specified element to the end of this Vector. * * @param e element to be appended to this Vector * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) * @since 1.2 */public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 查看Vector的源码可以发现，大部分源码都加上了synchronized关键字，比如上面的add方法，这也是Vector线程安全的原因。 LinkedList优点: 底层数据结构是链表，查询慢，增删快。缺点: 线程不安全，效率高。 类继承图 比较LinkedList和前两个集合类的区别，可以发现LinkedList实现了Deque接口，并且缺少了一个 RandomAccess接口。 其他 RandomAccess接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么输入IP地址无法访问网站]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%93%E5%85%A5IP%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[🌈学习完DNS解析之后，自己尝试写了一个Java程序解析DNS地址的小Demo。 代码： import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Arrays;/** * @paragram: DNSDemo * @description: 域名解析 * @auhor: liuergo * @date: 2019-09-18 15:41 */public class Test &#123; public static void main(String[] args) &#123; Test tester = new Test(); // tester.resolveDomain("www.baidu.com"); tester.resolveDomain("www.zhihu.com"); &#125; private void resolveDomain(String domain) &#123; InetAddress[] address; try &#123; address = InetAddress.getAllByName(domain); Arrays.stream(address) .map(InetAddress::getHostAddress) .forEach(System.out::println); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解析百度的IP地址以后，直接访问百度的IP地址可以正常访问，然而解析知乎的IP地址以后，无法正常访问。 域名可以访问然而IP不能访问，这是为什么呢？ 只输入IP地址无法访问网站的原因​ 输入IP地址无法访问的原因就是多个站点在共用这一个IP，如果只输入IP地址的话，浏览器也不知道要访问哪个站点，所以就无法访问了。 ​ 那么，浏览器不也是解析域名之后再访问的IP地址吗，最终也是访问的IP地址，那么越过DNS解析直接访问和前一种形式不应该一样吗？ ​ 有两种技术可以上面的问题： 虚拟主机技术 反向代理技术 虚拟主机技术 虚拟主机技术是apache，nginx等服务器所特有的一种功能，也就是实现多个站点在同一台服务器上放置。 那么，知乎的某台服务器可能就是下面的样子： 站点 文件存放路径 www.zhihu.com /zhihu/index www.a.com /a/index www.b.com /b/index 这样，域名和文件之间就存在映射关系了，当我们直接访问 www.zhihu.com 时，主要经历了以下几个步骤： DNS域名解析，获得解析后的结果，比如是223.111.243.190。 浏览器与IP为223.111.243.190的服务器进行三次握手，建立TCP连接。 浏览器开始构建HTTP请求报文，通过抓包可以看到报文格式： Hypertext Transfer Protocol GET / HTTP/1.1\r\n Host: www.zhihu.com\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8\r\n Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n Accept-Encoding: gzip, deflate\r\n Connection: keep-alive\r\n Upgrade-Insecure-Requests: 1\r\n \r\n [Full request URI: http://www.zhihu.com/] [HTTP request 1/18] [Response in frame: 121] 以上信息中，我们需要关注一行，就是Host: www.zhihu.com\r\n 这一行，通过这个头部字段，服务器就可以知道 到底访问的是哪个HOST，然后服务器就根据HOST和域名的对应关系，去寻找/zhihu/index文件。 反向代理技术先介绍一下正向代理和反向代理的区别： 正向代理正向代理，是在用户端的。比如需要访问某些国外网站，我们可能需要购买vpn。 并且vpn是在我们的用户浏览器端设置的(并不是在远端的服务器设置)。 浏览器先访问vpn地址，vpn地址转发请求，并最后将请求结果原路返回来。 反向代理有正向代理，就有反向代理。 反向代理是作用在服务器端的，是一个虚拟IP(VIP)。对于用户的一个请求，会转发到多个后端处理器中的一台来处理该具体请求。 大型网站都有DNS(域名解析服务器)，load balance(负载均衡器)等。 下面主要介绍反向代理技术 ​ 在计算机网络中，反向代理是代理服务器的一种。服务器根据客户端的请求，从其关联的一组或多组后端（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在。 在这种情况下，直接访问IP的时候会访问反向代理服务器，这样访问 www.zhihu.com 的时候，过程如下： 通过DNS解析获得 www.zhihu.com 的反向代理IP地址223.111.243.190。 HTTP请求到达反向代理服务器之后，该服务器会对请求做转发。 请求的HOST地址为 www.zhihu.com ，反向代理服务器会将请求报文转发到域名为www.zhihu.com的服务器上。 总结直接使用IP无法访问站点的原因 一个IP可能对应多个web站点，仅仅凭借IP无法找到相应的站点。通过域名访问就可以借助HOST分辨到底是要访问哪个站点。如果使用虚拟主机技术，那么利用HOST + IP的方式就可以访问；如果使用反向代理技术，通过代理服务器找到站点实际服务器的IP也可以访问。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WireShark基本操作]]></title>
    <url>%2F2019%2F09%2F16%2FWireShark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 拦截本地回环数据（需要的时候再开启）机访问本机的回环数据是不经过网卡的，比如我们在本机访问搭建在本机上的web服务，但我们经常有服务搭建在本机的操作也经常有拦截本地回环数据包加以分析的需求，所以我们环要拦载回环数据包。操作如下。 首先，以管理员身份运行cmd（普通用户没有路由表操作权限，会提示“请求的操作需要提升”） 然后，使用ipconfig查看本机ip和网关： ipconfig 再然后，使用以下命令添加路由，指定回环数据也要先转发到网关（使用上一步获取本的本机ip和网关替换其中的和）： route add &lt;your_IP&gt; mask 255.255.255.255 &lt;gateway_IP&gt; metric 1 最后，查看路由表中路由是否已添加成功： route print 回环数据经网关再回来会增加网卡的压力，可使用以下命令删除路由（使用前边获取本的本机ip替换其中的）： route delete &lt;your_IP&gt; 2. WireShark 界面说明 区域1：该区域展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。 区域 2：该区域是区域 1 中选定的数据包的分协议层展示。 区域 3：该区域是区域 1 中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。 2. 捕获过滤器表达式在欢迎页面可以看到管理捕获过滤器。 打开以后，可以看到过滤器的各种写法。 3. 显示过滤器表达式及其书写规律显示过滤器会在WireShark捕获数据包之后，按照过滤表达的条件，有选择性地显示已经捕获的所有数据包。 3.1. 基本过滤表达式一个基本的表达式由过滤项、过滤关系、过滤值三个部分组成。 比如ip.addr == 192.168.1.1这条表达式 ip.addr是过滤项 == 是过滤关系 192.168.1.1是过滤值 表达式的意思为找出所有ip协议中源或目标地址为192.168.1.1的数据包。 3.1.1. 过滤项==过滤项 = 协议 + 协议字段== 以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。 当在应用过滤显示器中输入时，会有相应的提示。 3.1.2. 过滤关系过滤关系可以使用“English”和“C-like”两种方式，例如“==”可以写作“eq”。 3.1.3 过滤值不解释。 ###3.2. 复合规律表达式 English C-like Description Example and &amp;&amp; Logical AND ip.src==10.0.0.5 and tcp.flags.fin or || Logical OR ip.scr==10.0.0.5 or ip.src==192.1.1.1 xor ^^ Logical XOR tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! Logical NOT not llc […] Subsequence See “Slice Operator” below. in Set Membership http.request.method in {&quot;HEAD&quot; &quot;GET&quot;}. See “Membership Operator” below. 3.3. 常见用显示过滤需求及其对应表达式数据链路层： 筛选mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 网络层： 筛选ip地址为192.168.1.1的数据包—-ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据—- ip contains “192.168.1” 筛选192.168.1.1和192.168.1.2之间的数据包—-ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包—-ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2 传输层： 筛选tcp协议的数据包—-tcp 筛选除tcp协议以外的数据包—-!tcp 筛选端口为80的数据包—-tcp.port == 80 筛选12345端口和80端口之间的数据包—-tcp.port == 12345 &amp;&amp; tcp.port == 80 筛选从12345端口到80端口的数据包—-tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80 应用层： 特别说明—-http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包—-http.request.uri contains “.php” 筛选内容包含username的http数据包—-http contains “username”]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
      </tags>
  </entry>
</search>
