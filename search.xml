<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Final arrays in Java]]></title>
    <url>%2F2019%2F10%2F10%2FFinal%20arrays%20in%20Java%2F</url>
    <content type="text"><![CDATA[之前在做第一个安卓项目时，在使用TimerTask和使用Thread创建新线程的时候，发现如果在匿名方法中对局部变量进行修改的时候会报错，但是可以访问局部变量，而使用成员变量的时候就不会报错。不过，如果将其写成下面就不会报错了，但是问题又来了，明明将变量声明成了final类型，为什么可以修改其值呢？ void myThread() &#123; final int[] i = &#123;0&#125;; Thread thread = new Thread(()-&gt; i[0]++); thread.start();&#125; 我们需要解决以下几个问题： 为什么在匿名方法中可以修改成员变量而不可以修改局部变量？ 为什么匿名方法中只能访问final类型的局部变量？ 为什么final数组的值可以被修改？ 在匿名方法中使用的局部变量为什么只能是final原因是Java设计者想要匿名函数或者Lambda函数内部外部保持数据一致性，在匿名方法中使用局部变量时，内部类并不是真正地使用该变量，而是在匿名方法中复制一个副本，由于是副本，所以即使是在匿名方法中修改了该变量，局部变量也不会发生变化，所以匿名方法使用的局部变量只能是final类型的变量。 注：在Java8以前，访问任何局部变量都要加final关键字，而在Java8之后，只要不涉及修改局部变量的操作，就可以不用加final关键字。 但是，对于成员变量来说，匿名方法会保存外部类的引用，因而内部类中对任何字段的修改都回真实的反应到外部类实例本身上，所以不需要用final来修饰它。具体可以参考该博客：https://www.cnblogs.com/qq78292959/p/3745348.html Final arrays如果非要对局部变量进行修改怎么办，那就只能用到上面的final数组方法。我们都知道，final类型的数据是不可以被修改的，但是为什么此处的final数组的值被修改了呢？ 下面是一个静态常量： public final int[] number = &#123;1, 2, 3&#125;; final关键字只能保证对于常量对象来说这点是成立的，但对于数组来说就不成立了，因为上面只能保证对象不变(意思是说final只能保证基本数据类型或原始数据类型不可变，比如：String，Double，int)，但number引用的对象是可以改变的。 注意：正是由于final数组的这个特性，所以在需要定义一个常量数组的时候，不要使用该方法，这样定义依然是会被修改值的。 文章开始的代码可以重写Thread类，定义Thread类的成员变量来实现相同的功能。 private void myThread()&#123; class MyThread extends Thread &#123; private int i = 0; @Override public void run() &#123; super.run(); i++; System.out.println(i); &#125; &#125; MyThread myThread = new MyThread(); myThread.start();&#125; 总结 在匿名方法中使用的局部变量只能是fianl类型的。 Java8以后，只要不对局部变量修改，局部变量即使不加final关键字也可以被匿名方法访问。 如果匿名方法要修改局部变量，可以将变量定义成final数组的形式。 如果要final发挥常量作用，final数组要慎用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static关键字]]></title>
    <url>%2F2019%2F10%2F10%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static关键字是经常会使用到的，之前一直没有对该关键字进行过深入地学习过，下面就讲述一下该关键字以及用途。 static关键字static关键字表示全局或者静态的意思，可以实现类似全局变量的作用，用static修饰变量或者方法都是独立于某个类的，会被所有的该类的实例共享，所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 public class Student &#123; private static int count; Student() &#123; count++; &#125; public static void main(String[] args) &#123; Student student = new Student(); Student student1 = new Student(); Student student2 = new Student(); System.out.println(Student.count); &#125;&#125;---------------Output:3 如上面的代码，运行结果为3，说明三个类的实例是共享静态变量count的，使用上面的代码可以统计一个类被实例化了多少次。 static关键字的用途 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 上面是《Thinking in Java》对static关键字作用的解释，总结一下，就是static方法可以在不用实例化对象的情况下使用。 static变量有static关键字修饰的变量为静态变量，而没有static修饰的变量是成员变量，在对类进行实例化的时候，无论进行多少次实例化，静态变量也只会被实例化一次，而成员变量则不同，它是伴随着实例的，每创建一个实例就会产生一个成员变量。 static成员变量的初始化顺序按照定义的顺序进行初始化。 在C/C++中static是可以作用域局部变量的，但是在Java中static是不允许用来修饰局部变量。 static方法有static关键字修饰的方法可以直接通过类名进行调用。由于static方法在类加载的时候就已经存在了，它不依赖于任何实例。 注意，在静态方法中不能调用非静态成员和非静态方法，在静态方法加载的时候非静态成员和方法还未加载；然而，在非静态方法中可以调用静态方法。 static代码块static关键字的一个比较特殊的用法就是静态代码块。静态代码块同样是在虚拟机加载类的时候就会会被加载执行，而且只执行一次。如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们。 静态代码块作用静态代码块的一个比较重要的作用就是可以优化性能。 比如下面的例子： public class Student &#123; private Date birthDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是判断该人是否是1946年到1964年之间出生的，每次isBornBoomer被调用的时候都会生成startDate和endDate两个对象，造成了空间浪费，可以改成下面的形式： public class Student &#123; private Date birthDate; private static Date startDate,endDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; static &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 所以，可以对只进行一次初始化的操作放在static代码块中进行。 静态代码块的执行时机在Java中，一个类的加载过程分为三个步骤：1. 装载 2. 连接 3. 初始化。 静态代码块是在类初始化的时候执行的，初始化阶段，jvm主要完成对静态变量的初始化，静态块执行等工作。 Class A&#123; static&#123; System.out.println("static block invoked!") &#125;&#125; 上面的代码中 new A()会执行static代码块中的内容。 Class.forName(&quot;A&quot;)会执行代码块中的内容；这个过程相当于Class.forName(&quot;A&quot;, true, A.class.getClassLoader())。 Class.forName(&quot;A&quot;, false, A.class.getClassLoader())不会执行代码块中的内容；因为false指明了在类加载的过程中不进行初始化，就不会执行static代码块了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置WireShark抓取https数据包]]></title>
    <url>%2F2019%2F09%2F29%2F%E9%85%8D%E7%BD%AEWireShark%E6%8A%93%E5%8F%96https%E6%95%B0%E6%8D%AE%E5%8C%85%2F</url>
    <content type="text"><![CDATA[配置环境变量SSLKEYLOGFILE为E:\ssl_key\sslog.log。 完全退出chrome或者firefox浏览器，然后重新打开。打开浏览器，访问一个HTTPS 网页，然后打开刚才SSLKEYLOGFILE环境变量值的文件路径就可以看到随机字符串记录。 配置WireShark。打开编辑-&gt;首选项-&gt;Protocols，打开SSL对其进行编辑（注：wireshark在某次版本更新之后去掉了SSL选项，没有SSL选项的需要设置TSL），将日志文件的路径添加到(Pre)-Master-Securet log file。 访问www.liuergo.top ，在WireShark中开始抓包，可以发现https的数据包可以被抓到了。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2019%2F09%2F27%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要是对《HTTP图解》这本书的学习记录，加上一些实验课中以及自己做的实验深入学习HTTP协议。 HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 协议报文解析HTTP报文大致可分为报文首部和报文主体两部分，两者由一个空行划分。通常，不一定要有报文主体（GET方法就没有报文主体）。 请求行：包含用于请求的方法，请求的URI和HTTP版本。 状态行：包含表明响应结果的状态码，状态短语和HTTP版本。 首部字段：包含表示请求和响应的各种条件和属性的各类首部。 报文主体：应被发送的数据。 实验验证 输入URL: http://gaia.cs.umass.edu/ethereal-labs/HTTP-ethereal-file3.html ，使用WireShark抓包。 输入过滤表达式tcp &amp;&amp; ip.addr==128.119.245.12 观察抓到的数据包 重点关注下面这一部分 352号包 这个包就是客户端发送给服务端HTTPGET请求，由请求行、各种首部字段和空行组成，在GET请求中，没有请求的报文主体部分。 384号包 在TCP协议中，发送双方每发出一个包都要有响应，此包就是服务端对刚刚发送的HTTP的GET包的响应。 386、387、389、390号包 首先，介绍一下WireShark中TCP segment of a ressembled PDU的概念，在TCP协议中，会将一个较大的数据包分成很多个小包发出去，在WireShark中，TCP segment of a ressembled PDU就是被TCP协议所分成的一个个小的数据包。 其实，这四个包都是TCP分成的小包，WireShark在最后一个http包中将所有的包都进行了重新拼包。 查看386号数据包 点击TCP segment data，查看此segment的数据内容，发现其中的数据就是http报文，只不过是服务器返回的http长报文的一部分。 查看390号数据包 打开4 Reassembled TCP Segments，可以看到所有被TCP所分成的四个小数据包，正是386，387，389，390号包。 查看HTTP数据包的内容 此数据包是服务端返回的HTTP报文，由状态行、首部字段、报文主体和空行组成。通过Line-based text data可以查看具体的报文主体部分的数据。 HTTP方法GET：获取资源GET方法用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应的内容。 POST：传输实体的主体状态码#]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点整理（持续更新...）]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本学期学习了计算机网络，本文将整理计算机网络的一些基础知识点，供自己以后查阅。 计算机网络的几种分层结构计算机网络通常可以进行下面的几种分层方式： 七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。 五层划分为：应用层、传输层、网络层、数据链路层、物理层。 四层划分为：应用层、传输层、网络层、网络接口层。 下面基本以五层架构为标准讲解 每层常用的网络协议 层 网络协议 应用层 http DNS FTP TFTP Telnet SMTP 传输层 TCP UDP 网络层 IP ICMP RIP ICMP 数据链路层 ARP RARP 每层较重要的协议应用层 协议名称 基本介绍 http 超文本传输协议，是用于从万维网服务器传输超文本到本地浏览器的传送协议，基于TCP/IP协议通信。 DNS 将域名解析为IP地址的协议，基于UDP协议通信。 FTP 文件传输协议。 TFTP 简单文件传输协议。 Telnet 为用户提供了在本地计算机上完成远程主机工作的能力。 SMTP 简单邮件传输协议。 传输层 协议名称 基本介绍 TCP TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP UDP协议是一种无连接的简单传输协议。 网络层 协议名称 基本介绍 IP IP协议不仅定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择。 ICMP 面向无连接的协议，用于传输出错报告控制信息。（ping命令就是使用的该协议，ping虽然处在应用层，但是可以直接使用网络层的ICMP协议） RIP 是一种内部网关协议，是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。 数据链路层 协议名称 基本介绍 ARP 地址解析协议，可以根据IP地址获取物理地址。 RARP 反向地址转换协议，可以根据物理地址获取IP地址。 常用端口号概述计算机端口号总数：65535。 0-1023： 系统端口，也叫公认端口，这些端口只有系统特许的进程才能使用。 1024~65535：用户端口，用户可以自定义这些端口的作用。 常用端口 协议/服务名称 端口号 http 80 https 443 www代理服务 8080 ssh 22 DNS 53 FTP 20（用于连接）、21（用于传输） Telnet 23]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化介绍 序列化：将对象写入到IO流中 反序列化：将对象从IO流中恢复 序列化的意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在，而且这整个过程都是独立于JVM进行的。 使用场景：所有在网络上传输的对象都需要进行序列化，比如在使用RMI(远程方法调用)时；所有需要保存到磁盘上的Java对象必须是可以被序列化的。通常程序创建的每个JavaBean都要实现Serializeable接口。 实现序列化如果一个类要实现序列化，那么这个类应该实现Serializable接口或者Externalizable接口。 Serializable接口Serializable接口是个标记接口，和之前提到的RandomAccess接口一样，接口中没有任何方法。一旦实现了该类，就表明该类是可序列化的。 序列化步骤 相应的类实现Serializeable接口。 Student.java /** * @paragram: SerializeDemo * @description: 学生类 * @auhor: liuergo * @date: 2019-09-26 21:55 */public class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125; 创建一个ObjectOutputStream输出流，并调用ObjectOutputStream对象的writeObject输出可序列化对象。 public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student.txt")); Student student = new Student("二狗", 18); objectOutputStream.writeObject(student); &#125; catch (IOException e) &#123; e.printStackTrace() &#125;&#125; 这时，会生成一个Student.txt文件。 反序列化步骤创建一个ObjectInputStream输入，并调用ObjectInputStream对象的readObject方法。 public static void main(String[] args) &#123; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student.txt")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//Student&#123;name='二狗', age='18'&#125; 反序列化不需要调用构造方法，其反序列化的对象是由JVM自己生成的对象，不需要构造方法生成。 对同一个对象多次序列化public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); Student student = new Student("二狗", 18); Student student1 = new Student("大鹅", 18); Student student2 = new Student("三虎", 19); objectOutputStream.writeObject(student); objectOutputStream.writeObject(student1); objectOutputStream.writeObject(student2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//运行结果//Student&#123;name='二狗', age='18'&#125; 从运行结果可以看出，在对一个对象进行序列化之后，并不会再次对其进行序列化。 所以，该序列化算法存在这样一个问题，如果在对一个对象进行序列化之后，需要修改该对象的内容，第二次序列化并不会成功。 transient关键字如果有时候对象的某些属性不需要序列化。这时候就可以使用该关键字选择不需要序列化的属性。 public class Student implements Serializable&#123; private transient String name; private int age; ...&#125; 这时序列化的结果就变成了Student{name=&#39;null&#39;, age=&#39;18&#39;}，这样，序列化的时候就自动忽略了name这个属性。 Externalizable接口 Externalizable.java public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 可以看到，该接口有两个方法，实现该接口，必须要实现writeExternal、readExternal两个方法。 public class Student implements Externalizable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; StringBuffer reverseString = new StringBuffer(this.name).reverse(); out.writeObject(reverseString); out.writeInt(this.age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; this.name = ((StringBuffer) in.readObject()).reverse().toString(); this.age = in.readInt(); &#125;&#125; Student类继承Externalizable接口之后，实现两个方法，在writeExternal方法中，可以对其进行一加密以保证安全性，注意要在readExternal方法中写相应的解密方法；而且如果不需要对某个属性进行序列化的话，就可以直接去掉某个属性序列化的语句，相当于实现了transient关键字的作用。 public static void main(String[] args) throws Exception&#123; Student student = new Student("二狗", 18); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); objectOutputStream.writeObject(student); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student1 = (Student) objectInputStream.readObject(); System.out.println(student1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 序列化和反序列化的代码和之前的是一样的，看到这里可能或产生一个问题，在上面的一段代码中，并没有看到刚刚的writeExternal和readExternal被显式调用，那么这两个方法到底是如何被调用的呢？ 查看ObjectOutputStream的源码，对于一个实现了EXternalizable接口的类来说，可以看出writeObject的调用栈： writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeExternalData ObjectOutputStream.java private void writeObject0(Object obj, boolean unshared) throws IOException&#123;......// remaining cases if (obj instanceof String) &#123; writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared); &#125;......&#125;private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException&#123;...... if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc); &#125;......&#125;/** * Writes externalizable data of given object by invoking its * writeExternal() method. */private void writeExternalData(Externalizable obj) throws IOException &#123; PutFieldImpl oldPut = curPut; curPut = null; if (extendedDebugInfo) &#123; debugInfoStack.push("writeExternal data"); &#125; SerialCallbackContext oldContext = curContext; try &#123; curContext = null; if (protocol == PROTOCOL_VERSION_1) &#123; obj.writeExternal(this); &#125; else &#123; bout.setBlockDataMode(true); obj.writeExternal(this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; &#125; finally &#123; curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; ⭐上面的部分源码给出了调用栈的后三个方法，通过源码可以很清晰地看出，由于Externalizable接口也实现了Serializable接口，所以在writeObject0方法中首先经过obj instanceof Serializable进入writeOrdinaryObject方法，在这里对该对象是否实现了Externalizable接口进行了判断（如果是继承了Serializable接口，会调用writeSerialData方法，这种情况会在下面讲解），最后调用writeExternalData方法，可以看到在该方法中会调用在类中重写的writeExternal方法。 🐞第一次运行的时候，报了以下异常，no valid constructor，没有合法的构造器，这是因为Student类中没有一个无参的构造器。在通过实现接口Externalizable进行序列化读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器，增加一个无参构造器之后就不会报这个异常了。 serialVersionUID在学习集合类的时候经常能在源码中看见serialVersionUID，当时只是知道和序列化有关，今天就深入了解一下。 JVM是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，即serialVersionUID。 如果反序列化时候的使用的序列化ID与序列化时使用的ID不同的话，就会报InvalidClassException异常。 需要特别说明的是，如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。 ⭐所以，在编写某个JavaBean时，最好是给这个serialVersionUID赋值，这样就可以避免以后在更新类的时候产生异常，方便升级。 ArrayList的序列化最初学习序列化的原因，是因为一开始看ArrayList源码的时候，不知道serialVersionUID一大串数字是干嘛的，也不知道transient关键字的含义，现在学习完序列化之后再回过头来看ArrayList的源码。从ArrayList的源码开始，我们首先关注下面的部分。 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; transient Object[] elementData; // non-private to simplify nested class access&#125; 可以看到，底层的实现数组使用了transient关键字，也就是说，ArrayList是不会被序列化的吗？ public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ArrayList")); objectOutputStream.writeObject(list); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("ArrayList")); ArrayList&lt;Integer&gt; list1 = (ArrayList&lt;Integer&gt;) objectInputStream.readObject(); System.out.println(list1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//[1, 2, 3] 然而在经过测试之后，可以发现，ArrayList被序列化成功了，那么使用了transient关键字为什么还会被序列化？既然要序列化ArrayList，又是为什么要使用该关键字呢？ 其实事情的真相就在于ArrayList中的两个方法writeObject和readObject方法，下面是两个方法的源码部分。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 从源码可以看出，在序列化一个ArrayList时，会将size和elementData都写入输出流，这就是为什么加了transient关键字之后依然会被序列化的原因。那么为什么要加这个关键字呢？这是因为elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上面的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 现在还有一个问题就是，这两个方法是如何被调用的呢？有了前面对Externalizable接口分析的经验，直接查看ObjectOutputStream的writeSerialData方法，在该方法中调用了invokeWriteObject方法来实现序列化，下面直接看该方法。 void invokeWriteObject(Object obj, ObjectOutputStream out) throws IOException, UnsupportedOperationException&#123; requireInitialized(); if (writeObjectMethod != null) &#123; try &#123; writeObjectMethod.invoke(obj, new Object[]&#123; out &#125;); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); if (th instanceof IOException) &#123; throw (IOException) th; &#125; else &#123; throwMiscException(th); &#125; &#125; catch (IllegalAccessException ex) &#123; // should not occur, as access checks have been suppressed throw new InternalError(ex); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125;&#125; ObjectStreamClass.java writeObjectMethod = getPrivateMethod(cl, "writeObject", new Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;, Void.TYPE);readObjectMethod = getPrivateMethod(cl, "readObject", new Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;, Void.TYPE); 重点关注writeObjectMethod.invoke(obj, new Object[]{ out });这一行，其中的writewriteObjectMethod对象就是在ObjectStreamClass类中定义的，通过反射的方式调用的两个方法。 总结 实现序列化的方式主要有以下几种： 实现Serializable接口，调用ObjectOutputStream的writeObject方法，将对象序列化，这时，是使用的Java的自带的序列化方式。此时被transient关键字修饰的属性，不会被序列化。 实现Serializable接口，同时提供writeObject方法，这时ObjectOutputStream就会通过反射的方式调用writeObject方法。此时transient修饰的字段，是否会被序列化，取决于writeObject方法。 实现 Externalizable接口，并实现两个方法，这时ObjectOutputStream就会自动调用writeObject方法。此时，transient关键字不会起作用，是否会被序列化，取决于writeObject方法。 定义JavaBean时，最好都实现Serializable接口，并且定义serialVersionUID。 静态变量不会被实例化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RandomAccess接口]]></title>
    <url>%2F2019%2F09%2F24%2FRandomAccess%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通过在Java集合类中，查看类继承图和源码可以看出ArrayList和Vector都实现了RandomAccess接口，而LinkList却没有实现该接口，查看RandomAccess接口，发现里面是空的。 RandomAccess.java package java.util;/** * 一大堆注释... */public interface RandomAccess &#123;&#125; 其实，该接口只是一个标识性接口(Marker)，除了RandomAccess接口外，还有Cloneable (可拷贝克隆)、Serializable(被序列化)，之后会有文章介绍这两个接口。 该接口的官方解释 List实现使用的标记界面，表明它们支持快速（通常为恒定时间）随机访问。 此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。 当施加到顺序访问列表（如LinkedList），用于操纵随机接入列表（如ArrayList）最好算法可以产生二次行为。 鼓励通用列表算法在应用如果应用于顺序访问列表之前提供较差性能的算法，并且如果需要改变其行为以确保可接受的性能，则检查给定列表是否为instanceof此接口。 此循环： for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); 比这个循环运行得更快： for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); Collections类中的使用此接口在Collections类中有很多地方都使用到了，比如下面的binarySearch方法 Collection.java @SuppressWarnings("unchecked")public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123; if (c==null) return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key); if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key, c); else return Collections.iteratorBinarySearch(list, key, c);&#125; 上面的方法中，通过判断list是否实现了RandomAccess接口来判断执行indexedBinarySearch方法还是执行iteratorBinarySearch方法(instanceof关键字的作用是判断某个对象所在的类是否继承某个类或者是实现某个接口)。 应用下面先做一个分别使用for循环和Iterator遍历ArrayList和LinkedList的实验。 RamdomAccessDemo.java import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;/** * @paragram: CollectionDemo * @description: RandomAccess接口Demo * @auhor: liuergo * @date: 2019-09-24 23:00 */public class RandomAccessDemo &#123; public static void main(String[] args) &#123; System.out.println("arrayList使用for循环遍历" + arrayListFor()); System.out.println("arrayList使用Iterator遍历" + arrayListIterator()); System.out.println("linkedList使用for循环遍历" + linkedListFor()); System.out.println("linkedList使用Iterator遍历" + linkedListIterator()); &#125; //for循环遍历ArrayList public static long arrayListFor() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long arrayListIterator() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //for循环遍历ArrayList public static long linkedListFor() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long linkedListIterator() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125;&#125; 运行结果 可以发现，使用for循环比使用Iterator遍历ArrayList快，使用Iterator比使用for循环快。 所以，我们在使用这些集合类的时候，应该想到对于不同的集合类采取不同的遍历方式，具体采取那种方式就可以采取通过判断该类是否实现了RandomAccess接口的方式。 可以采用如下的模板： public void traverseList(List list) &#123; if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; &#125; &#125; else &#123; Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; &#125; &#125;&#125; 注：推荐使用增强for循环，增强for循环在底层也是实现的Iterator。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS+PicGo建立图床]]></title>
    <url>%2F2019%2F09%2F21%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%2BPicGo%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在本地写md文档时候插入图片是一件挺麻烦的事情，使用本地图片的话，每次在给别人分享文档或者上传博客的时候就比较难顶了。网上有两种方法可以解决这个问题，一种是使用图片的base64编码，但是图片转换为base64编码之后，编码长度会很大，文档的可读性不好，而且也会使文档的体积急剧变大，这种方法显然不太好。所以，最终使用了图床的方法将图片储存在阿里云中。 开通OSS服务​ 进入阿里云创建一个对象存储OSS的服务，之后新建一个Bucket，创建Bucket之后，我们的存储空间就创建成功了。 使用PicGo快速上传图片 PicGo下载地址https://github.com/Molunerfinn/PicGo 配置PicGo ​ KeyId和KeySecret可以从阿里的控制台获取。 ​ 储存空间名就是Bucket的名称，存储区域在访问域名可以找到。 ​ 配置完成之后就可以使用PicGo上传图片了。 踩坑记录​ 第一次使用PicGo上传图片的时候，总是提示上传失败，检查了好几遍配置，都没有什么错误，可是就是上传不了。 ​ 打开PicGo的配置文件之后，发现有下面的报错信息。 2019-09-21 21:33:11 [PicGo ERROR] StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot;------Error Stack Begin------StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot; at new StatusCodeError (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\errors.js:32:15) at Request.plumbing.callback (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:104:33) at Request.RP$callback [as _callback] (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:46:31) at Request.self.callback (E:\PicGo\resources\app.asar\node_modules\request\request.js:185:22) at Request.emit (events.js:182:13) at Request.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1157:10) at Request.emit (events.js:182:13) at IncomingMessage.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1079:12) at Object.onceWrapper (events.js:273:13) at IncomingMessage.emit (events.js:187:15)-------Error Stack End------- ​ 重点关注The difference between the request time and the current time is too large这一部分，查找阿里云OS文档，403错误及排查。看到下面的部分，就明白了出问题的原因。 ​ 由于我的电脑是Windows+Ubuntu双系统，每次切换系统的时候都会产生八个小时的时差，一直没有解决这个冲突问题，所以造成了Windows时间不正常，也就导致了今天的问题。 ​ 解决方法就很简单了，重新同步一下时钟就好了。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么输入IP地址无法访问网站]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%93%E5%85%A5IP%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[🌈学习完DNS解析之后，自己尝试写了一个Java程序解析DNS地址的小Demo。 代码： import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Arrays;/** * @paragram: DNSDemo * @description: 域名解析 * @auhor: liuergo * @date: 2019-09-18 15:41 */public class Test &#123; public static void main(String[] args) &#123; Test tester = new Test(); // tester.resolveDomain("www.baidu.com"); tester.resolveDomain("www.zhihu.com"); &#125; private void resolveDomain(String domain) &#123; InetAddress[] address; try &#123; address = InetAddress.getAllByName(domain); Arrays.stream(address) .map(InetAddress::getHostAddress) .forEach(System.out::println); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解析百度的IP地址以后，直接访问百度的IP地址可以正常访问，然而解析知乎的IP地址以后，无法正常访问。 域名可以访问然而IP不能访问，这是为什么呢？ 只输入IP地址无法访问网站的原因​ 输入IP地址无法访问的原因就是多个站点在共用这一个IP，如果只输入IP地址的话，浏览器也不知道要访问哪个站点，所以就无法访问了。 ​ 那么，浏览器不也是解析域名之后再访问的IP地址吗，最终也是访问的IP地址，那么越过DNS解析直接访问和前一种形式不应该一样吗？ ​ 有两种技术可以上面的问题： 虚拟主机技术 反向代理技术 虚拟主机技术 虚拟主机技术是apache，nginx等服务器所特有的一种功能，也就是实现多个站点在同一台服务器上放置。 那么，知乎的某台服务器可能就是下面的样子： 站点 文件存放路径 www.zhihu.com /zhihu/index www.a.com /a/index www.b.com /b/index 这样，域名和文件之间就存在映射关系了，当我们直接访问 www.zhihu.com 时，主要经历了以下几个步骤： DNS域名解析，获得解析后的结果，比如是223.111.243.190。 浏览器与IP为223.111.243.190的服务器进行三次握手，建立TCP连接。 浏览器开始构建HTTP请求报文，通过抓包可以看到报文格式： Hypertext Transfer Protocol GET / HTTP/1.1\r\n Host: www.zhihu.com\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8\r\n Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n Accept-Encoding: gzip, deflate\r\n Connection: keep-alive\r\n Upgrade-Insecure-Requests: 1\r\n \r\n [Full request URI: http://www.zhihu.com/] [HTTP request 1/18] [Response in frame: 121] 以上信息中，我们需要关注一行，就是Host: www.zhihu.com\r\n 这一行，通过这个头部字段，服务器就可以知道 到底访问的是哪个HOST，然后服务器就根据HOST和域名的对应关系，去寻找/zhihu/index文件。 反向代理技术先介绍一下正向代理和反向代理的区别： 正向代理正向代理，是在用户端的。比如需要访问某些国外网站，我们可能需要购买vpn。 并且vpn是在我们的用户浏览器端设置的(并不是在远端的服务器设置)。 浏览器先访问vpn地址，vpn地址转发请求，并最后将请求结果原路返回来。 反向代理有正向代理，就有反向代理。 反向代理是作用在服务器端的，是一个虚拟IP(VIP)。对于用户的一个请求，会转发到多个后端处理器中的一台来处理该具体请求。 大型网站都有DNS(域名解析服务器)，load balance(负载均衡器)等。 下面主要介绍反向代理技术 ​ 在计算机网络中，反向代理是代理服务器的一种。服务器根据客户端的请求，从其关联的一组或多组后端（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在。 在这种情况下，直接访问IP的时候会访问反向代理服务器，这样访问 www.zhihu.com 的时候，过程如下： 通过DNS解析获得 www.zhihu.com 的反向代理IP地址223.111.243.190。 HTTP请求到达反向代理服务器之后，该服务器会对请求做转发。 请求的HOST地址为 www.zhihu.com ，反向代理服务器会将请求报文转发到域名为www.zhihu.com的服务器上。 总结直接使用IP无法访问站点的原因 一个IP可能对应多个web站点，仅仅凭借IP无法找到相应的站点。通过域名访问就可以借助HOST分辨到底是要访问哪个站点。如果使用虚拟主机技术，那么利用HOST + IP的方式就可以访问；如果使用反向代理技术，通过代理服务器找到站点实际服务器的IP也可以访问。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java众多的集合类由两大接口衍生而来：Collection接口和Map接口 CollectionList(有序，可重复)ArrayList优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程不安全，效率高。 类继承图 ArrayList.java /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 上面的elementData就是ArrayList的底层数组的实现。 Vector优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程安全，效率低。 类继承图 Vector.java /** * Appends the specified element to the end of this Vector. * * @param e element to be appended to this Vector * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) * @since 1.2 */public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 查看Vector的源码可以发现，大部分源码都加上了synchronized关键字，比如上面的add方法，这也是Vector线程安全的原因。 LinkedList优点: 底层数据结构是链表，查询慢，增删快。缺点: 线程不安全，效率高。 类继承图 比较LinkedList和前两个集合类的区别，可以发现LinkedList实现了Deque接口，并且没有实现 RandomAccess接口，表示此集合类不支持快速随机访问，此接口有专门的文章讲解。 Set(无序，唯一)HashSet底层数据结构是哈希表（无序，唯一）。 类继承图 可以看出，HashSet也是没有实现RandomAccess接口的，不支持快速随机访问，关于HashSet是如何保证元素的唯一性的，及其无序性的原因将在HashMap中解释。 HashSet.java private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 从上面的源码可以看出，HashSet的底层实现是HashMap，每次调用add方法时，Map的value部分仅仅put了一个一个Object对象，而HashMap的Key是唯一的，也就保证了HashSet的唯一性。 LinkedHashSet底层数据结构是哈希表和链表（有序，唯一），链表保证其有序，哈希表保证其唯一。 从类继承图可以看出，LinkedHashSet继承了HashSet，从下面的源码可以看出，LinkedHashSet主要是实现了HashSet的HashSet(int initialCapacity, float loadFactor, boolean dummy)构造方法，在该方法中新建了一个LinkedHashMap对象，链表部分的实现就在LikedHashMap中实现了。 //LinkedHashSet.javapublic LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;//HashSet.javaHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; TreeSet底层数据结构是红黑树（唯一，有序）。SortedSet接口保证了其有序性，主要用于排序。 类继承图 MapHashMapMap族主要包括HashMap、LinkedHashMap、TreeMap、Hashtable HashMap 线程不安全，效率高，无序。 HashMap允许空值，并且key和value都允许。key值具有唯一性，存在的话key值不会覆盖，新的value会替代旧的value，而且HashMap是无序的，之后会有源码讲解详细解释。 LinkedHashMap 内部维持了一个双向链表，相比于HashMap来说可以保证有序。 TreeMap 内部实现是红黑树，可以对插入的元素进行自动排序。 Hashtable 很多方法加上了synchronized，所以，Hashtable是线程安全的，而且Hashtable不允许空值。 对比分析TreeSet，LinkedHashSet，HashSet对比相同点 由于实现了Set接口，都有唯一性的特点。 三者都不是线程安全的，如果想保证线程安全，可以使用Collections.synchronizedSet()方法。 不同点 是否有序：HashSet直接实现了HanshMap，是无序的，而由于LinkedHashSet实现了链表，可以保证数据按照插入顺序排序，TreeSet会对插入的数据实现排序。 是否允许空值：HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException。 测试public static void setTest() &#123; HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); for (Integer data: Arrays.asList(745, 3, 114, 526, 5, 7, 4)) &#123; hashSet.add(data); linkedHashSet.add(data); treeSet.add(data); &#125; System.out.println("HashSet：" + hashSet); System.out.println("LinkedHashSet：" + linkedHashSet); System.out.println("TreeSet：" + treeSet);&#125; 运行结果 可以看出来，遍历HashSet的结果是无序的，遍历LinkedHashSet的结果是跟插入数据的顺序保持一致，TreeSet可以对数据进行排序。 HashMap、LinkedHashMap、TreeMap、Hashtable对比相同点 都是用于储存key/value键值对，key不能重复 不同点 是否支持多线程读写：HashMap、TreeMap、LinkedHashMap线程不安全，只有Hashtable线程安全。 是否有序：HashMap、Hashtable无序，LikedHashMap可以保证数据按照插入顺序排序、TreeMap可以对数据进行排序。 是否允许空值：HashMap、LikedHashMap允许存在一条键为null的记录，Hashtable、TreeMap不允许空值存在。 遍历方式List主要有三种循环方式，for循环、增强for循环和迭代器方式。增强for循环的内部是调用iterator实现的，后两种方式的效果基本相同(在idea中也会有提示建议使用增强for循环的方式)。对于如何选择遍历方式，在RandomAccess接口中有讲到。 //List遍历private static void traverseListTest() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) &#123; arrayList.add(i); &#125; //for循环遍历 for (int i = 0; i &lt; arrayList.size(); i++) &#123; System.out.println(arrayList.get(i)); &#125; //增强for循环 for (Integer integer : arrayList) &#123; System.out.println(integer); &#125; //iterator方式 Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; Map遍历方式，主要的遍历方式有四种，第一中国方式仅仅遍历value或者key的话直接使用一个增强for循环，第二种方式是使用Map.keyset方法遍历key，可以再通过key找到value，第三种是使用Map.entrySet遍历，此方法是效率比较高的一种，第四种是使用Iterator遍历，和上一种方式基本相同，但是如果需要在遍历过程中删除元素的话，需要使用该方法。 //Map遍历private static void traverseMapTest() &#123; Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125; //仅遍历value for (Integer value : map.values()) &#123; System.out.println(value); &#125; //仅遍历key for (Integer key : map.keySet()) &#123; System.out.println(key); &#125; //Map.keySet方法 for (Integer key : map.keySet()) &#123; System.out.println(key + " " + map.get(key)); &#125; //Map.entrySet方法 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue()); &#125; //Iterator方式 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next().getKey() + " " + iterator.next().getValue()); &#125; //lambada map.forEach((key, value) -&gt; System.out.println(key + " " + value));&#125; 性能测试插入了500w条数据进行测试。 遍历方式 时间（ms） KeySet 13 values 42 keySet get(key) 51 entrySet 41 iterator 39 总结 如果只是获取key或者value，推荐使用KeySet和values方式。 同时需要key和value，推荐使用entrySet方式。 如果需要在遍历的过程中删除元素，可以使用iterator方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WireShark基本操作]]></title>
    <url>%2F2019%2F09%2F16%2FWireShark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 拦截本地回环数据（需要的时候再开启）机访问本机的回环数据是不经过网卡的，比如我们在本机访问搭建在本机上的web服务，但我们经常有服务搭建在本机的操作也经常有拦截本地回环数据包加以分析的需求，所以我们环要拦载回环数据包。操作如下。 首先，以管理员身份运行cmd（普通用户没有路由表操作权限，会提示“请求的操作需要提升”） 然后，使用ipconfig查看本机ip和网关： ipconfig 再然后，使用以下命令添加路由，指定回环数据也要先转发到网关（使用上一步获取本的本机ip和网关替换其中的和）： route add &lt;your_IP&gt; mask 255.255.255.255 &lt;gateway_IP&gt; metric 1 最后，查看路由表中路由是否已添加成功： route print 回环数据经网关再回来会增加网卡的压力，可使用以下命令删除路由（使用前边获取本的本机ip替换其中的）： route delete &lt;your_IP&gt; 2. WireShark 界面说明 区域1：该区域展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。 区域 2：该区域是区域 1 中选定的数据包的分协议层展示。 区域 3：该区域是区域 1 中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。 2. 捕获过滤器表达式在欢迎页面可以看到管理捕获过滤器。 打开以后，可以看到过滤器的各种写法。 3. 显示过滤器表达式及其书写规律显示过滤器会在WireShark捕获数据包之后，按照过滤表达的条件，有选择性地显示已经捕获的所有数据包。 3.1. 基本过滤表达式一个基本的表达式由过滤项、过滤关系、过滤值三个部分组成。 比如ip.addr == 192.168.1.1这条表达式 ip.addr是过滤项 == 是过滤关系 192.168.1.1是过滤值 表达式的意思为找出所有ip协议中源或目标地址为192.168.1.1的数据包。 3.1.1. 过滤项==过滤项 = 协议 + 协议字段== 以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。 当在应用过滤显示器中输入时，会有相应的提示。 3.1.2. 过滤关系过滤关系可以使用“English”和“C-like”两种方式，例如“==”可以写作“eq”。 3.1.3 过滤值不解释。 ###3.2. 复合规律表达式 English C-like Description Example and &amp;&amp; Logical AND ip.src==10.0.0.5 and tcp.flags.fin or || Logical OR ip.scr==10.0.0.5 or ip.src==192.1.1.1 xor ^^ Logical XOR tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! Logical NOT not llc […] Subsequence See “Slice Operator” below. in Set Membership http.request.method in {&quot;HEAD&quot; &quot;GET&quot;}. See “Membership Operator” below. 3.3. 常见用显示过滤需求及其对应表达式数据链路层： 筛选mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 网络层： 筛选ip地址为192.168.1.1的数据包—-ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据—- ip contains “192.168.1” 筛选192.168.1.1和192.168.1.2之间的数据包—-ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包—-ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2 传输层： 筛选tcp协议的数据包—-tcp 筛选除tcp协议以外的数据包—-!tcp 筛选端口为80的数据包—-tcp.port == 80 筛选12345端口和80端口之间的数据包—-tcp.port == 12345 &amp;&amp; tcp.port == 80 筛选从12345端口到80端口的数据包—-tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80 应用层： 特别说明—-http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包—-http.request.uri contains “.php” 筛选内容包含username的http数据包—-http contains “username”]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
      </tags>
  </entry>
</search>
