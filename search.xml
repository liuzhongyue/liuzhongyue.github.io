<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F11%2F20%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML定义： UML即统一建模语言（Unified Modeling Language）,它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 UML类图就是一种供软件设计师们看的可以表达类的关系的一种统一语言，只不过是用图的形式来表达。 下面有个Student类，age默认值为1，提供了get和set方法。 public class Student &#123; private String name; private int age = 1; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 下面我们来看一下该类的UML类图。 上面的类图中主要有三个部分类名、类的属性和方法，三个部分使用分隔符分隔。 类的属性和方法的表达格式： 类的属性格式：访问权限 属性名:类型[=默认值] 类的方法格式：访问权限 方法名称:类型[:返回类型] “+”表示public，”-“表示private，”#”表示protected。 类之间的关系类与类之间有下面几种关系： 泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）。 下面用Java代码和类图之间的对比来解释上述的关系。 泛化（Generalization）泛化就是Java中的继承关系，很好理解。 Student类继承于Person类，那么两个对象就是泛化关系，使用带空心三角形的实线箭头表示。 public class Student extents Person &#123; &#125; 实现（Realization）实现就是Java中实现接口的方法。 Studen类中实现了一个Skil接口，那么Student类和Skill接口之间就是实现关系，使用带空心三角形的虚线箭头表示。 public interface Skill &#123; void code();&#125;public class Student implments Skill &#123; @Override public void code() &#123; &#125;&#125; 依赖（Dependence）依赖是一种很弱的关系，如果类A访问类B的属性或者方法，或者类A负责实例化类B，那么可以说类A依赖类B。比如下面的例子，Student如果要在图书馆借书，图书馆管理员需要记录该学生的学号，Librarian类就需要访问Student类的getSno()方法来获取sno属性，那么就说Librarian类依赖于Student类，使用虚线箭头表示，箭头指向被依赖的对象。 public class Librarian &#123; public void record(int sno) &#123; //记录sno; &#125;&#125; 关联（Association）关联关系是一种比较强的关系，两者的关系是比较长久的，比如学生和家的关系，就是一种关联关系。关联关系分为两种，一种是单向关联，一种是双向关联， 如果一个类知道或者引用了另一个类，而另一个类不知道或者没有引用这个类，则这两个类是单向关联的。 比如学生和家的关系，每个学生都有家，但是每个家里并不是都有学生。单项关联使用实线箭头表示，箭头指向被引用的类。 public class Student &#123; Home home;&#125; 双向关联是双方都知道对方的存在，比如学生和老师的关系就是双向关联，双向关联用实直线表示。 public class Student &#123; Teacher teacher;&#125;public class Teacher &#123; Student student;&#125; 聚合（Aggregation）聚合关系强调的是整体和部分的关系，其部分可以脱离整体而存在。比如大雁和雁群的关系，就是聚合关系，大雁离开雁群也是可以独立存在的。聚合关系使用带空心菱形的虚线箭头表示，菱形指向整体。 public class Geese &#123; String shape; ArrayList&lt;Goose&gt; geese;&#125; 组合（Composition）组合关系也是强调的整体和部分的关系，而在此关系中部分不可以脱离整体存在。比如大雁和翅膀，就是组合关系，翅膀不能脱离大雁的存在而存在。。。组合关系使用是带实心菱形的虚线箭头表示，菱形指向整体。 public class Goose &#123; Wing wing;&#125; 组合、聚合、关联、依赖这几种关系关联程度也就显而易见了，依赖程度：组合&gt;聚合&gt;关联&gt;依赖。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—策略模式]]></title>
    <url>%2F2019%2F11%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们需要创建表示各种策略的对象和一个行为随着策略改变而改变的context对象，通过策略对象改变context对象的执行算法。 学习设计模式最重要的一点就是要搞清楚设计模式的应用场景，首先举几个例子，比如我们手机支付的时候，可以使用支付宝可以使用微信也可以使用云闪付，这些支付方式每一种都是一个策略对象，每一种策略都是可以互相替换的；再比如淘宝双十一的打折活动，可以叠津贴、用红包或者店家直接打折，每一种优惠方式也是一种策略。 策略模式做到的就是 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 实现首先我们画出该模式的UML类图： 其中，Context是上下文对象，是真正执行策略的对象，维护一个实现Strategy接口的类，Strategy接口是策略接口，是用于声明所有算法的接口，SpecificStrategy是Strategy接口的实现类，里面有算法的具体实现。 Context.java /** * @author liuergo * @description Context上下文对象 * @date 2019-11-20 16:16 */public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 执行策略的具体方法 */ public void executeStrategy() &#123; strategy.algorithmStatement(); &#125;&#125; Strategy.java /** * @author liuergo * @description 策略接口 * @date 2019-11-20 16:09 */public interface Strategy &#123; /** * 某种算法的声明 */ public void algorithmStatement();&#125; 在这里，有两个类实现了Strategy接口。 SpecificStrategyA.java /** * @author liuergo * @description 具体的策略对象 * @date 2019-11-20 16:13 */public class SpecificStrategyA implements Strategy&#123; @Override public void algorithmStatement() &#123; System.out.println("算法A"); &#125;&#125; SpecificStrategyB.java /** * @author liuergo * @description 具体的策略对象 * @date 2019-11-20 16:15 */public class SpecificStrategyA implements Strategy&#123; @Override public void algorithmStatement() &#123; System.out.println("算法B"); &#125;&#125; Tester.java public class Tester &#123; public static void main(String[] args) &#123; Context context = new Context(new SpecificStrategyA()); context.executeStrategy(); context = new Context(new SpecificStrategyB()); context.executeStrategy(); &#125;&#125;//Output://算法A//算法B 可以看到，使用策略模式之后可以动态地在代码运行过程中替换Context对象所使用的算法。 这里可以对Context对象继续做改进。 //Context.javapublic class Context &#123; private Strategy strategy; public Context() &#123; &#125; /** * 执行策略的具体方法 */ public void executeStrategy() &#123; strategy.algorithmStatement(); &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125;&#125;//Tester.javapublic class Tester &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setStrategy(new SpecificStrategyA()); context.executeStrategy(); context.setStrategy(new SpecificStrategyB()); context.executeStrategy(); &#125;&#125; 这样就不用重复地new Context对象了。 例子下面使用策略模式完成一个手机支付的例子。 首先，画出UML类图： Payment.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 支付策略 * @date 2019-11-20 20:31 */public interface Payment &#123; /** * 支付方法 * @param balance 消费前的余额 * @param price 消费的物品的价格 * @return 返回消费之后的余额 */ double pay(double balance, double price);&#125; Alipay.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 支付宝支付 * @date 2019-11-20 20:31 */public class Alipay implements Payment&#123; @Override public double pay(double balance, double price) &#123; //各种支付方式中此部分逻辑肯定不同 System.out.println("正在打开支付宝..."); System.out.println("使用支付宝支付了" + price + "元"); return balance - price; &#125;&#125; WechetPay.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 微信支付 * @date 2019-11-20 20:35 */public class WechatPay implements Payment &#123; @Override public double pay(double balance, double price) &#123; //各种支付方式中此部分逻辑肯定不同 System.out.println("正在打开微信..."); System.out.println("使用微信支付了" + price + "元"); return balance - price; &#125;&#125; Consumer.java package top.liuergo.strategy.practical;import lombok.Data;/** * @author liuergo * @description 消费者 * @date 2019-11-20 20:36 */@Datapublic class Consumer &#123; double balance; Payment payment; public void usePayment(double price) &#123; this.balance = payment.pay(balance, price); System.out.println("当前余额:"+ this.balance); &#125;&#125; Tester.java import top.liuergo.strategy.practical.Alipay;import top.liuergo.strategy.practical.Consumer;import top.liuergo.strategy.practical.WechatPay;/** * @description: 测试类 * @author liuergo * @date 2019-10-30 16:57 */public class Tester &#123; public static void main(String[] args) &#123; Consumer consumer = new Consumer(); consumer.setBalance(20000); consumer.setPayment(new Alipay()); consumer.usePayment(20); consumer.setPayment(new WechatPay()); consumer.usePayment(100); &#125;&#125; 运行程序之后的输出：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven总结]]></title>
    <url>%2F2019%2F11%2F13%2FMaven%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[由于之前一直在做安卓项目，对Gradle了解比较多，Maven用的比较少，最近趁着新一届的学弟学妹们加入团队，在学习Java Web基础，跟着学弟学妹们一起学习，对之前的笔记做一个整理，也当重新回顾一下。 Maven简单介绍，Maven是目前最受欢迎的 Java项目管理构建自动化综合工具。 Maven主要有三个功能： 管理依赖：只需要在pom文件中写入相关的属性就会自动下载并管理jar包。 项目的构建：内置很多插件，比如校验、编译、测试、打包、部署、发布等。 项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等。 安装和配置，略… 仓库配置在使用Maven时，会按照以下的步骤检查pom.xml并加载相关的依赖。 Maven会从本地仓库寻找依赖包，如果没有找到，执行2。 从中央仓库寻找依赖包，如果没有找到执行3。 如果在pom.xml中自定义了远程仓库，那么就会在远程仓库寻找依赖包，如果仍然没有找到，那么Maven就会抛出异常。 配置步骤 配置本地仓库位置。 在conf文件夹下的settings.xml，将&lt;localRepository&gt;标签中的路径改为需要作为本地仓库的路径即可。 &lt;localRepository&gt;D:\apache-maven-3.6.0\RepMaven&lt;/localRepository&gt; 使用阿里云镜像。 同样编辑settings.xml，将&lt;mirrors&gt;标签中的内容修改为下面的即可。 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置远程仓库（非必要）。 如果需要配置Maven远程仓库，在pom.xml加入下面的代码即可。 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; Maven依赖机制传统方式下假如我们现在需要使用log4j。我们需要： 去互联网上下载log4j的jar包。 复制jar包到项目路径下。 手动将其设置为项目的依赖。 这样，不仅繁琐而且不利于我们的管理，万一log4j有新的版本需要升级，则需要重复一遍上面的所有步骤。 Maven方式下 知道log4j的Maven坐标。 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 将其添加到pom.xml文件中，按照上一节中所讲的顺序，开始下载jar包并储存到本地仓库。如果version标签被忽略，会自动下载最新的版本。 在使用Maven之后，我们唯一需要做的一件事就是找到我们所需要的Jar包的坐标。 可以去中心仓库，复制所需Jar包的的Maven坐标。 中心仓库网址：https://mvnrepository.com/ 在IDEA中新建Maven项目 配置Maven插件 在IDEA自带了Maven插件，可以更加方便地使用Maven。需要首先进行下面的配置： 配置Maven安装的路径、settings.xml的路径以及中心仓库的路径。这样就可以使用右侧工具栏中的插件进行一些方便的操作。 新建Maven项目。 在IDEA中中选择Maven项目，下一步。 配置GroupId，ArtifactId，Version。 GroupId：组织名称，一般将域名倒置。 ArtifactId：Maven构建的项目名。 Version：版本号，其中的SNAPSHOT意思为快照，说明该项目还不稳定，依然处于开发阶段。 添加依赖。 在pom.xml中，加入下面的语句： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这样，我们就将log4j的依赖包添加到了项目中。 Maven 插件 Maven 是一个执行插件的框架，每一个任务实际上是由插件完成的。Maven 插件通常用于： 创建 jar 文件 创建 war 文件 编译代码文件 进行代码单元测试 创建项目文档 创建项目报告 可以使用以下的语法执行插件： mvn [plugin-name]:[goal-name] 例如，使用插件将项目打成Jar包，可以在项目目录下运行如下命令： mvn jar:jar 常见插件 插件 描述 clean 构建之后清理目标文件。删除Target目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 IDEA中的Maven插件可以很方便地使用这些插件：]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TimeUnit类使用]]></title>
    <url>%2F2019%2F11%2F09%2FTimeUnit%E7%B1%BB%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[TimeUnit使用在学习线程池的时候发现ThreadPoolExecutor类中有个TimeUnit类的参数，此类是java.util.concurrent包下的类，记录一下该类的使用。 作用： 时间粒度转换 提供了可读性更好的线程暂停操作，通常用来代替Thread.sleep() 常用的几个时间粒度TimeUnit.DAYS //天TimeUnit.HOURS //小时TimeUnit.MINUTES //分钟TimeUnit.SECONDS //秒TimeUnit.MILLISECONDS //毫秒 时间粒度转换public long toMillis(long d) //转化成毫秒public long toSeconds(long d) //转化成秒public long toMinutes(long d) //转化成分钟public long toHours(long d) //转化成小时public long toDays(long d) //转化天 Example import java.util.concurrent.TimeUnit;/** * @paragram: ThreadPoolDemo * @description: TimeUnit类测试 * @auhor: liuergo * @date: 2019-11-09 14:08 */public class TimeUnitTest &#123; public static void main(String[] args) &#123; //将一天转换为24小时 System.out.println(TimeUnit.DAYS.toHours(1)); //将一小时转换为60分钟 System.out.println(TimeUnit.HOURS.toMinutes(1)); &#125;&#125;//输出结果//24//60 延时import java.sql.Time;import java.util.Timer;import java.util.concurrent.TimeUnit;/** * @paragram: ThreadPoolDemo * @description: TimeUnit类测试 * @auhor: liuergo * @date: 2019-11-09 14:08 */public class TimeUnitTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread.sleep(60 * 60 * 1000); //可读性不高 TimeUnit.HOURS.sleep(1); //同样是线程睡眠一小时，使用TimeUnit可读性会高很多。 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—BlockingQueue]]></title>
    <url>%2F2019%2F11%2F09%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94BlockingQueue%2F</url>
    <content type="text"><![CDATA[BlockingQueue阻塞队列，所谓的阻塞是指，当队列已满时，会阻塞当前添加元素的线程，直到队列不满或者等到超时；当队列为空时，会阻塞当前获取元素的线程，直到队列不空或者等待超时。 核心方法压入元素 add(E e)：向队尾增加元素，设置成功返回true。如果使用了capacity-restricted队列，即限定了容量的队列，推荐使用offer()方法。 offer(E e)：向队尾增加元素，设置成功返回true，如果队列中没有多余的空间返回false。 put(E e)：向队尾增加元素，如果队列中没有多余的空间，该方法会一直阻塞。 弹出元素 poll()：获取并移除队首元素，如果队列为空，返回null。 take()：获取并移除队首元素，如果队列为空，该方法会一直阻塞。 peek()：获取但是并不移除队首元素，如果队列为空，返回null。 其他操作 contains(Obeject o)：判断队列中是否包含该元素。 int drainTo(Collection&lt;? super E&gt; c)：将队列转化为集合。 实现类 实现类 底层数据结构 是否有界 其他 ArrayBlockingQueue arrayList 有界 只有一把锁，入队高并发或出队高并发的情况下推荐使用 LinkedBlockingQueue linkedList 默认无界，可指定上限 两把锁，在入队与出队都高并发的情况下推荐使用 DelayQueue heap 无界 延迟期满时才能从中提取元素 PriorityBlockingQueue heap 无界 基于优先级的阻塞队列 SynchronousQueue 无 无界 无缓冲的阻塞队列，只能容纳一个元素，向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。 生产者消费者例子 Producer.java import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * @author liuergo * @description 生产者 * @date 2019-11-10 00:23 */public class Producer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Producer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int maxProductNum = 20; for (int i = 0; i &lt; maxProductNum; i++) &#123; try &#123; TimeUnit.SECONDS.sleep(1); //生产者生产 queue.put(i); System.out.println("Producer produced " + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Consumer.java import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * @author liuergo * @description 消费者 * @date 2019-11-10 00:24 */public class Consumer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Consumer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int maxConsumeTime = 20; for (int i = 0; i &lt; maxConsumeTime; i++) &#123; try &#123; TimeUnit.SECONDS.sleep(2); //消费者消费并拿到产品 int product = queue.take(); System.out.println("Consumer consumed " + product); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Tester.java import java.util.concurrent.*;/** * @author liuergo * @description 测试类 * @date 2019-11-10 13:26 */public class Tester &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); //使用线程池，避免显式地创建线程 ExecutorService service = Executors.newFixedThreadPool(2); service.execute(producer); service.execute(consumer); service.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—线程池]]></title>
    <url>%2F2019%2F11%2F07%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池？使用线程池可以： 降低资源的消耗。线程本身是一种很宝贵的资源，创建线程和销毁线程会有CPU开销，是一个比较昂贵的操作。 提高任务执行的响应速度。使用线程池以后，不必等到线程创建完毕以后再执行。 提高线程的可管理性。可以对线程进行统一的分配。 线程池处理主要流程 Executor 我们如果要自定义一个线程池或者使用java自带的几种线程池，都要使用ThreadPoolExecutor类或者使用实现了该类的工厂方法。 可以看到，Executor接口是ThreadPoolExecutor的顶层接口。 在Executor接口中，只有一个execute()方法，必须传进来实现Runnable接口的线程，该方法可以将任务交给线程池创建线程并启动。（注意，该启动方式无法拿到返回值）。 void execute(Runnable command); ExecutorService该接口继承了Executor接口，该接口： 提供了用于关闭线程池的方法，shutdown方法和shutdownNow方法，关于这两个方法，shutdown方法会将线程池的状态置为SHUTDOWN，并且不再接收新任务，同时等待线程池中所有的任务执行完成之后再结束；shutdownNow方法会将线程池的状态置为STOP，然后对线程池中所有的线程执行interrupt方法。 提供了用于检查线程池状态的两个方法，isShutdown方法和isTerminated方法，两个方法分别可以检测线程池是否被关闭和是否被终止。 提供了submit和invokeAll可以执行实现Callable接口的线程，可以使用定义一个Future类型的对象获取到线程运行之后的返回值。 ThreadPoolExecutor构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); 该类的构造方法如上，下面一一解释每个参数的含义： corePoolSize：线程池中核心线程的数量，对于超出核心线程数量以外的线程，将其称作”idle threads”。 maximumPoolSize：线程池中的最大线程数量。 keepAliveTime：空闲时间，idle threads存活的时间。 unit：空闲时间的单位。 workQueue：线程池的等待队列。 threadFactory：线程工厂，可以用来创建新线程。 handler：拒绝策略，当线程池和队列都满了时候，这时需要对继续提交进来的任务做出处理。 下面着重分析workQueue、threadFactoy和handler三个参数。 workQueue等待队列是BlockingQueue类型的，理论上，只要是它的子类，都可以用来作为等待队列。 关于BlockingQueue可以移步：BlockingQueue threadFactorypublic interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; ThreadFactory是一个接口，只有一个方法，用来创建线程。 static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; 在ThreadPoolExecutor中，默认使用Executors.defaultThreadFactory()静态方法创建线程工厂，在此方法中新建了一个DefaultThreadFactory对象，上面是该对象的源码，可以看到，通过该方法创建的线程优先级均为NORM_PRIORITY，并且是非守护线程，使用&quot;pool-&quot; + poolNumber + &quot;-thread-&quot; + threadNumber来命名线程。所以，可以通过定制一个ThreadFactory的方式来达到统一命名我们线程池中的线程的目的。 handler线程池提供了4种决绝策略： AbortPolicy：直接抛出异常，这是默认策略。 CallerRunsPolicy：用调用者所在的线程来执行任务。 DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务。 DiscardPolicy：直接丢弃任务。 ExecutorsExecutors是一个线程池工厂，提供了很多工厂方法，提供了一些创建线程池的方法。 SingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 创建单一线程的线程池，这个线程池只有一个线程。多个任务被提交到该线程后，会被缓存到一个长度为Integer.MAX_VALUE的LinkedBlockingQueue队列中，此时的maximumPoolSize实际上是不起作用的，因为缓冲区基本不会满只有缓冲区满了才会执行判断maximumPoolSize的逻辑。如果只需要创建一个线程，也推荐使用该方法代替直接new Thread的方法创建线程，避免显式地创建线程。 FixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 创建固定长度的线程池，和上面的线程池类似，只不过可以接收更多任务。 CachedThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 创建带缓存的线程池，使用该方式创建的线程核心线程数为0，最大线程数为Integer.MAX_VALUE，使用SynchronousQueue阻塞队列，此队列在BlockingQueue中有讲到，举个例子，如果此时来了一个线程A，由于当前corePoolSize为0，所以直接将其添加到队列中，由于该队列的特性，添加成功的前提是必须要有另一个线程已经在等待取出这个元素了，此时无可用线程，即没有等待取出线程A的线程，由于最大线程数为Integer.MAX_VALUE所以会创建一个新线程。此时如果又来了一个线程B，线程A仍然在运行中，同样无可用线程，会继续为B创建新线程。 此线程池是一个可根据需要创建新线程的线程池，如果现有线程没有可用的，则创建一个新线程并添加到池中，如果有被使用完但是还没销毁的线程，就复用该线程。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 ScheduledThreadPool创建定时调度的线程池，与上面三个线程池不同的是，该方法返回的是ScheduledExecutorService类型的线程池， 是一个能实现定时、周期性任务的线程池。 使用方法： BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);Producer producer = new Producer(queue);Consumer consumer = new Consumer(queue);ScheduledExecutorService service = Executors.newScheduledThreadPool(3);service.schedule(producer, 5, TimeUnit.SECONDS);service.execute(consumer); 上面的例子(此例子来源于BlockingQueue讲解)就可以实现producer线程5s后被启动。 自定义线程池对于上面的几种线程池，是不推荐直接使用的，一般还是经常会根据需要自定义线程池。自定义线程池需要结合使用背景，主要就是参数的选取。 最大线程数对于最大线程数的控制，最好不要使用无限制大小的最大线程数，可能引发OOM。 对于线程数量的确定可以参考下面的方案： 1、针对IO密集型的，当一个任务在执行IO操作的时候，其线程将被阻塞，这时，CPU就可以立即进行上下文切换，以便处理其他就绪线程。 在《Java Concurrency in Practice》一书中，给出了估算线程池大小的公式： $Nthreads=NcpuUcpu(1+w/c)$ 其中，Ncpu=CPU核心数，Ucpu=cpu使用率，0~1，W/C=等待时间与计算时间的比率。 阻塞耗时一般都是计算耗时几倍，假设阻塞耗时=计算耗时的情况下，$Nthreads=Ncpu*(1+1)=2Ncpu$，所以这种情况下，建议考虑2倍的CPU核心数做为线程数。 2、对于计算密集型的，阻塞耗时趋于0，即w/c趋于0，公式$Nthreads = Ncpu$。 自定义ThreadFactory在《阿里巴巴Java开发手册》中，有这样的一条规定： 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。创建线程池的时候请使用带ThreadFactory的构造函数，并且提供自定义ThreadFactory实现或者使用第三方实现。 所以我们在自定义一个线程池的时候，尽量指定有意义的线程名称。 类比DefaultThreadFactory，创建自定义的ThreadFactory。 import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;/** * @author liuergo * @description 自定义ThreadFactory * @date 2019-11-12 16:41 */public class MyThreadFactory implements ThreadFactory &#123; private static AtomicInteger poolNumber = new AtomicInteger(1); private AtomicInteger threadNumber = new AtomicInteger(1); private ThreadGroup group; private String namePrefix; public MyThreadFactory() &#123; this("my-pool"); &#125; public MyThreadFactory(String namePrefix) &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); this.namePrefix = namePrefix + "-" + poolNumber.getAndIncrement() + "-thread-"; &#125; @Override public Thread newThread(Runnable r) &#123; return new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); &#125;&#125; 这样，在新建线程池的时候就可以自定义线程池的名称了。 ThreadFactory factory = new MyThreadFactory("my-pool");ExecutorService service = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(1024), factory);service.execute(()-&gt; System.out.println(Thread.currentThread().getName()));service.shutdown();//输出//my-pool-1-thread-1 在《阿里巴巴Java开发手册》，提供了下面的方式新建一个ThreadFactory。 ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat("demo-pool-%d") .build();ExecutorService singleThreadPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));singleThreadPool.shutdown(); 其实上面的方式用到了Google的Guava SDK，其中ThreadFactoryBuilder是其自带的构造器模式方法。 个人推荐直接使用谷歌自带的轮子，毕竟不要重复造轮子嘛，当然学习过程中还是要自己写写Demo的。😁 程池监控可以通过一些方法来监控当前线程池的状态，在ThreadPoolExecutor中自带了一些方法： long getTaskCount()，获取已经执行或正在执行的任务数。 long getCompletedTaskCount()，获取已经执行的任务数。 int getLargestPoolSize()，获取线程池曾经创建过的最大线程数，根据这个参数，我们可以知道线程池是否满过。 int getPoolSize()，获取线程池线程数。 int getActiveCount()，获取活跃线程数（即正在执行任务的线程数）。 其次，ThreadPoolExecutor留给我们自行处理的方法有3个，它在ThreadPoolExecutor中为空实现（也就是什么都不做）。 protected void beforeExecute(Thread t, Runnable r) // 任务执行前被调用 protected void afterExecute(Runnable r, Throwable t) // 任务执行后被调用 protected void terminated() // 线程池结束后被调用 我们可以通过重写这三个方法来实现一些其他的功能。 ThreadFactory factory = new ThreadFactoryBuilder() .setNameFormat("my-pool-%d") .build();ExecutorService service = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(1024), factory) &#123; private String date = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss").format(new Date()); @Override protected void beforeExecute(Thread t, Runnable r) &#123; String date = formatter.format(new Date()); System.out.println(date + " " + Thread.currentThread().getName() + " 准备执行..."); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; String date = formatter.format(new Date()); System.out.println(date + " " + Thread.currentThread().getName() + " 执行完毕..."); &#125; @Override protected void terminated() &#123; String date = formatter.format(new Date()); System.out.println(date + " 线程池退出"); &#125;&#125;;service.execute(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);service.shutdown();//输出//2019-11-12 08:21:50 my-pool-0 准备执行...//2019-11-12 08:21:55 my-pool-0 执行完毕...//2019-11-12 08:21:55 线程池退出 上面的例子中就实现了记录线程池准备执行的时间、执行完毕的时间和线程池退出的时间。 获取处理结果和异常 线程池的处理结果、以及处理过程中的异常都被包装到Future中，并在调用Future.get()方法时获取，执行过程中的异常会被包装成ExecutionException 。 Future&lt;Object&gt; future = service.submit(() -&gt; &#123; throw new RuntimeException("exception in call");&#125;);try &#123; future.get();&#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace();&#125; 上述代码的运行结果如下： 总结 在Java中，线程是个比较昂贵的对象，我们应该避免显式地创建线程，尽量使用线程池创建线程。 关于线程池我们最需要掌握的就是线程池的处理流程和通过ThreadPoolExecutor构造方法自定义线程池，虽然Executors为我们提供了构造线程池的便捷方法，但是我们仍应该根据具体情况自定义线程池。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7配置Tomcat自启动]]></title>
    <url>%2F2019%2F10%2F30%2FCentOS7%E9%85%8D%E7%BD%AETomcat%E8%87%AA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[假设Tomcat安装目录为usr/local/tomcat 在和tomcat/bin目录平级的地方增加一个tomcat.pid文件。 在tomcat/bin目录下，增加setenv.sh配置，这样 catalina.sh启动的时候会调用，同时配置Java内存参数。 #add tomcat pid CATALINA_PID=&quot;$CATALINA_BASE/tomcat.pid&quot; #add java opts JAVA_OPTS=&quot;-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m 增加tomcat.service 在 /usr/lib/systemd/system 目录下增加tomcat.service文件。 [Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingEnvironment=&quot;JAVA_HOME=/usr/local/jdk1.8.0_191&quot;PIDFile=/usr/local/tomcat/tomcat.pidExecStart=/usr/local/tomcat/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 使用tomcat.service 配置开机启动 systemctl enable tomcat 启动tomcat systemctl start tomcat 停止tomcat systemctl stop tomcat 重启tomcat systemctl restart tomcat 因为配置pid，在启动的时候会再tomcat根目录生成tomcat.pid文件，停止之后删除。 同时tomcat在启动时候，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行。 多个tomcat可以配置在多个目录下，互不影响。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—单例模式]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在上次的Android项目中，数据库对象以及netty连接的对象都使用过单例模式，但是对单例模式一直也是一知半解，借着刚在软件工程导论课上讲了单例模式，深入了解一下。 单例模式（singleton pattern）单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 所以在单例模式中，最重要的一点就是保证其不会被实例化多次，保证其唯一性。 单例模式在Java中主要有以下几个实现方式： 懒汉式，线程不安全 饿汉式，线程安全 双重校验锁（DCL） 静态内部类 枚举 懒汉式//懒汉式(线程不安全)public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 此方式是懒加载的，也就是说，只有当调用getInstance()方法且当前类从未被实例化过，当前类才会被实例化，另外，此方法不适用于多线程，是线程不安全的。 懒汉式（线程安全方式）//懒汉式(线程不安全)public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 将getInstance方法改为同步方法就可以保证线程安全了，但是由于同步代码的执行效率是很低的，所以，此方法不是很推荐。 饿汉式//饿汉式(线程安全)public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton () &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 此方法在类初始化的时候就完成了实例化，线程不安全的问题只会在首次实例化对象的时候才会发生，所以这种方式并不会产生线程不安全的问题。 双重校验锁(DCL) JDK1.5以后可以使用 //DCL(线程安全)public class Singleton &#123; private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 此方法有两个需要注意的地方： 双重检查，相对于懒汉式（线程安全）方式，DCL方式在同步代码块外面又加了一个判断，这样既保证了线程安全，而且保证了只有在单例未被实例化的时候synchronized才会生效，保证了效率 volatile关键字的使用。可以看到上面基本上就可以保证线程安全了，但是为什么还要使用volatile关键字呢？在volatile关键字中，介绍过volatile关键字可以保证变量的有序性和可见性，在此处，使用volatile关键字就是为了保证有序性。 volatile关键字保证有序性 今天上软件工程导论的时候，老师讲到了单例模式，并且举到了DCL的例子，但是只字不提volatile关键字…… 导致可能保证不了有序性的操作是下面的一个语句： singleton = new Singleton(); 上面的一句话并不是一个原子操作，它可以被分解成以下几个语句： memory = allocate(); //1：分配对象的内存空间initInstance(memory); //2：初始化对象singleton = memory; //3：设置singleton指向刚分配的内存地址 可以看出上面的三个操作中，操作2是依赖于操作1的，而操作3并不依赖于操作2，因此，JVM就有可能对其进行重排序操作，重排序之后，上面的操作会变成下面的样子： memory = allocate(); //1：分配对象的内存空间singleton = memory; //3：设置singleton指向刚分配的内存地址（此时的对象还没有被初始化）initInstance(memory); //2：初始化对象 可以看到，如果在线程A中经过重排序之后，操作3和操作2对调了，这样在初始化对象之前，instance首先指向了一个未被初始化的内存空间，如果这时有另一个线程B访问，此时的singleton已经不是null了，会返回一个单例，这样就有可能得到”半个”单例（未完成初始化）。如下表： 线程A 线程B 分配对象的内存空间 singleton 指向一个未被初始化的内存空间 判断 singleton 是否为null 由于singleton不为null，访问引用对象 初始化对象 访问引用对象 加上volatile关键字就可以防止JVM对其进行重排序了，就可以解决这种隐患。 静态内部类//静态内部类public class Singleton &#123; private static class SingletonHolder &#123; public static Singleton instance = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 关于内部类可以看此博客Java内部类。 通过静态内部类实现，既可以实现懒汉式的懒加载又可以实现饿汉式的线程安全。 此方法同样是使用了类加载机制保证初始化单例的只有一个线程，但是此方式在Singleton类被初始化之后，instance并不会被初始化，只有当显式地调用getInstance方法之后，才会实例化instance。所以此方法可以保证懒加载。 枚举类 JDK1.5以后可以使用 public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 而且也不能通过反射来调用私有的构造方法。 总结在一般情况下，使用饿汉式就可以了，如果明确要求懒加载，可以使用静态内部类的方法，了解DCL可以帮助我们更好的理解synchronized关键字以及volatile关键字的作用，最后一种枚举类方式虽然用的少，但是还是很推荐使用该方式（毕竟是Effective Java的作者推荐的写法，听大神说的就对了👍）。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—volatile关键字]]></title>
    <url>%2F2019%2F10%2F29%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java并发编程三大特性在Java并发编程中，有三个概念：1. 原子性 2. 可见性 3. 有序性。 原子性（Atomicity）原子性指一个操作是不可中断的，要么全部执行成功要么全部执行失败，在数据库的事务中也有这个性质。 例如，a++，对于一个共享变量a的操作实际上可以分为三个步骤：1. 读取变量a的值；2. 将a的值+1；3. 将值重新赋值给a。此操作是可分割的，所以这并不是一个原子操作。像这样的操作，如果在多线程下，就有可能会产生异常，所以需要使用synchronized或者Lock来保证代码的原子性。 可见性（Visibility）可见性就是指当一个线程修改了共享变量的值，对于另外一个线程来说是可见的，其他线程能够立即得知这个修改。 Java内存模型中，线程通信是通过共享内存的方式进行的，为了加快线程通信的速度，线程一般是不会直接操作内存的，而是操作当前线程内的一个副本。这样，如果线程对变量的操作没有刷新内存的话，仅仅改变了当前线程中的副本，对于其他线程来说，就是不可见的。 volatile关键字的作用就是保证了变量的可见性，volatile变量可以保证对它的修改可以立即被刷新到主存，而当其他线程需要读取该值的时候，会从内存中去读取新的值。 另外，synchronized同样具有可见性，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。 有序性（Ordering）指程序执行的顺序应该按照代码的先后顺序执行。在Java内存模型中，是允许编译器和处理器对指令进行重排序的，但是重排序不会影响到单线程程序的运行，在单线程程序中，JVM重排序的时候会保证程序的最终执行结果和顺序执行代码的结果是一样的。但是对于多线程程序来说，这就不一定了。 例如下面的例子： //Thread 0context = loadContext();inited = true;//Thread 1while (!inited) &#123; sleep;&#125;doSomethingwithconfig(context); 在这个例子中，如果Thread0出现了重排序： inited = true;context = loadContext(); 在这种情况下，线程B就有可能拿到一个未初始化的content去执行其他方法，从而引起错误。 为了防止重排序，需要使用volatile关键字，它可以保证对变量的操作是不会被重排序的。 内心OS：要是真出了这样的BUG，不清楚有序性还真不知道咋改… volatile保证可见性public class VolatileDemo &#123; private static boolean isThreadRunning = true; public static void main(String[] args) throws InterruptedException &#123; Thread thread0 = new Thread(() -&gt; &#123; System.out.println("Thread0开始"); while (isThreadRunning) &#123; &#125; System.out.println("Thread0结束"); &#125;); Thread thread1 = new Thread(() -&gt; &#123; System.out.println("isThreadRunning被修改..."); isThreadRunning = false; &#125;); thread0.start(); Thread.sleep(2000); thread1.start(); &#125;&#125; 运行结果： 可以看到，程序陷入了死循环，虽然isThreadRunning的值被Thread1修改了，然而Thread0并没有接收到修改的值，这就是因为变量值没有被写到主存，导致本地内存中的值一直为true。 解决方法就是为isThreadRunning变量加上volatile关键字。 private volatile static boolean isThreadRunning = true; 再次运行程序，现在就不会导致死循环了。 volatile与原子性volitile关键字是不能保证原子性的，看下面一个例子： public class VolatileDemo &#123; private static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; count++; System.out.println(count); &#125; &#125;).start(); &#125; &#125;&#125; 从下面的输出结果可以看出数据产生了异常。 如果将count++操作改为sychronized操作就可以保证输出结果的正确了。 synchronized (lock) &#123; count++;&#125; 总结 volitile关键字是synchrnized的轻量级实现，volitile性能优于synchrnized。 volitile可以保证数据的可见性和有序性，而synchroized和Lock三种特性都可以保证。ti]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—线程通讯的方式]]></title>
    <url>%2F2019%2F10%2F28%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[线程通讯线程通讯的目的是使线程之间能够互相发送信号。 另一方面，线程通信使线程能够等待其他线程的信号。 线程通讯的方式： wait()/notify()机制 Condition类 ThreadLocal方式 管道方式 wait()/notify()机制wait和notify还有notifyAll方法是Object类的三个方法。 调用wait方法，相当于让当前线程释放锁，然后进入等待状态。 notify()方法主要的作用就是此方法可以唤醒一个正在等待此对象的锁释放的线程，如果所有线程都在此对象上等待，则会选择其中一个唤醒。而notifyAll()方法的作用就是将所有等待此对象的锁的线程都唤醒。 在wait方法中有这样的一句话The current thread must own this object&#39;s monitor.，也就是说使用wait方法的前提是该线程必须拥有这个对象的锁，因此调用wait方法时必须存在synchronized方法或者synchronized代码块，如果当前线程没有拥有锁的对象，就会抛出IllegalMonitorStateException。 生产者消费者模型 public class Tester &#123; Object lock = new Object(); int count = 0; public static void main(String[] args) throws Exception &#123; Tester tester = new Tester(); Thread thread = new Thread(tester.new Producer("producer 0")); Thread thread0 = new Thread(tester.new Producer("producer 1")); Thread thread1 = new Thread(tester.new Consumer("consumer 0")); thread.start(); thread0.start(); thread1.start(); &#125; class Producer implements Runnable &#123; private String name; public Producer (String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; while (count == 5) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " produced.."); count++; System.out.println("Current buffer size:" + count); lock.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; while (count == 0) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " consumed.."); count--; System.out.println("Current buffer size:" + count); lock.notifyAll(); &#125; &#125; &#125; &#125;&#125; 上面就是一个生产者消费者模型的例子，当缓冲区满了的时候生产者会停止生产，这时，如果消费者消费了一个产品，生产者就会被唤醒；当缓冲区为空的时候消费者会停止消费，这时，如果生产者了一个产品，消费者就会被唤醒。 ConditionCondition是可以用来代替传统的wait/notify方式，此方式更加安全和高效，比较推荐使用该方法。 Condition是一个接口，其基本方法有await()、signal()以及signalAll()，分别对应Object类的wait()、notify()、notifyAll()。 有关方法必须在lock和unlock之间使用。 下面是Condition类实现生产者消费者的例子： public class Tester &#123; Lock lock = new ReentrantLock(); //可重入锁，并发包会讲到 Condition condition = lock.newCondition(); int count = 0; public static void main(String[] args) throws Exception &#123; Tester tester = new Tester(); Thread thread = new Thread(tester.new Producer("producer 0")); Thread thread0 = new Thread(tester.new Producer("producer 1")); Thread thread1 = new Thread(tester.new Consumer("consumer 0")); thread.start(); thread0.start(); thread1.start(); &#125; class Producer implements Runnable &#123; private String name; public Producer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.lock(); while (count == 5) &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " produced.."); count++; System.out.println("Current buffer size:" + count); condition.signalAll(); lock.unlock(); &#125; &#125; &#125; class Consumer implements Runnable &#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.lock(); while (count == 0) &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " consumed.."); count--; System.out.println("Current buffer size:" + count); condition.signalAll(); lock.unlock(); &#125; &#125; &#125;&#125; 管道方式之前在操作系统这门课中也接触到过这种方式只不过是C版本的，现在也当再次重温一下。此方式是利用管道流在不同线程之间直接传输数据，一个线程向管道中写入数据，另一个线程从管道中读数据。 public class PipedStreamDemo &#123; public static void main(String[] args) throws IOException &#123; PipedOutputStream outputStream = new PipedOutputStream(); PipedInputStream inputStream = new PipedInputStream(); outputStream.connect(inputStream); ThreadWrite threadWrite = new ThreadWrite(outputStream); ThreadRead threadRead = new ThreadRead(inputStream); Thread thread = new Thread(threadRead); Thread thread1 = new Thread(threadWrite); thread.start(); thread1.start(); &#125;&#125;class ThreadWrite implements Runnable&#123; PipedOutputStream pipedOutputStream; public ThreadWrite(PipedOutputStream pipedOutputStream) &#123; this.pipedOutputStream = pipedOutputStream; &#125; public void write(PipedOutputStream pipedOutputStream) throws IOException &#123; System.out.println("write:"); for (int i = 0; i &lt; 100; i++) &#123; String data = "" + i; pipedOutputStream.write(data.getBytes()); System.out.println(data); &#125; pipedOutputStream.close(); &#125; @Override public void run() &#123; try &#123; this.write(pipedOutputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadRead implements Runnable&#123; PipedInputStream pipedInputStream; public ThreadRead(PipedInputStream pipedInputStream) &#123; this.pipedInputStream = pipedInputStream; &#125; public void read(PipedInputStream pipedInputStream) throws IOException &#123; System.out.println("read:"); byte[] bytes = new byte[1024]; int readLength = pipedInputStream.read(bytes); while (readLength != -1) &#123; String newData = new String(bytes, 0, readLength); System.out.print(newData); readLength = pipedInputStream.read(bytes); &#125; System.out.println(); pipedInputStream.close(); &#125; @Override public void run() &#123; try &#123; this.read(this.pipedInputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService接口开发]]></title>
    <url>%2F2019%2F10%2F26%2FWebService%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近有一个项目可能需要用到WebService技术，提前学习一下。 WebService WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 相关概念XML,SOAP和WSDL就是构成WebService平台的三大技术。 XML：扩展性标记语言 （Extensible Markup Language） 用于传输格式化的数据，是Web服务的基础。 SOAP：简单对象访问协议（Simple Object Access Protocol，SOAP）SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。 SOAP协议 = http协议 + XML数据格式 XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 WSDL：（网络服务描述语言，Web Services Description Language）WSDL是一门基于 XML 的语言，用于描述 Web Services 以及如何对它们进行访问。 在idea中新建WebServices项目编写服务端 创建新项目，选择WebServices，Version选择Axis。 在这里，我们新建一个测试类，为了展示如何将一个新建的类添加进来。 public class Test &#123; public String sayHelloWorldFrom(String from) &#123; String result = "Hello, world, from " + from; System.out.println(result); return result; &#125;&#125; 打开web-&gt;WEB-INF-&gt;server-config.wsdd文件，复制粘贴一份下面的代码，将下面两个部分的代码更换为新建的Test类名称。 这时，返回Test类可以发现Test类旁边多了两个🌏的标志，这样就配置成功了。 生成wsdl文件，新版idea需要先下载WebService插件，之后Tools-&gt;WebServices-&gt;Generate Wsdl Java Code… 这里需要先编译一下，否则报ClassNotFoundException，说明刚刚新建的类没有生成.class文件。 配置Tomcat（省略）。 配置Atifacts，一开始会报缺少依赖的错，Fix一下就好。 运行之后，默认跳转到了下面的页面，只需要在URL最后加上services就可以。 单击上面某个wsdl就可以跳转到下面的页面。 编写客户端 新建项目，选择WebService Client，Version选择Apache Axis。 导入wsdl文件，选择wsdl存放的位置，生成代码。 修改自动生产的测试类代码。 package example;import test.TestServiceLocator;public class HelloWorldClient &#123; public static void main(String[] argv) &#123; try &#123; TestServiceLocator locator = new TestServiceLocator(); System.out.println(locator.getTest().sayHelloWorldFrom("ergo")); &#125; catch (javax.xml.rpc.ServiceException ex) &#123; ex.printStackTrace(); &#125; catch (java.rmi.RemoteException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 在控制台可以看到输出的结果。 Java调用WebServic接口的方式还有很多，这里就不一一介绍了。 WebService、REST、RESTful？首先简单介绍一下这三个名词，WebService，基于SOAP协议的服务，上面已经介绍了； REST：一种软件架构风格，一种面向资源的架构，其核心操作只有 GET,PUT,POST,DELETE。 RESTful： 遵守了rest风格的web服务 ，是一个形容词。 RESTful详解 SOAP WebService和RestFul 的区别]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—synchonized关键字]]></title>
    <url>%2F2019%2F10%2F22%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94synchonized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[线程安全与共享资源在《Java并发编程实战》书中对线程安全给出了下面的定义： 当多个线程访问某个类时，这个类始终都能表现处正确的行为 下面介绍一下各种变量的线程安全性。 基础类型局部变量 基础类型的局部变量储存在栈内存中，也就是说，局部变量永远不会被多个线程共享。所以说所有的基础类型的局部变量都是线程安全的。 引用类型局部变量 由于引用类型变量的属性都储存在堆中，但是在一般情况下，别的线程是获取不到该对象的，只要该对象不能够被其他方法获取到，那么他就是线程安全的。 成员变量 由于一个对象的成员是储存在堆内存上的，如果有多个线程同时更新同一个对象的同一个成员变量，那么这种情况就不是线程安全的。 需要说明的是，只有多个线程同时访问同一个资源而且多个线程都对此资源进行了些写操作，才会产生线程安全的问题，多个线程同时对同一个资源进行读操作时不会产生线程安全问题的。 Java同步块Java同步块（synchronized block）用来可以实现同步，可以通过这种方式来有效地避免线程安全问题的出现。 synchronized关键字三种使用方式 修饰实例方法，为当前实例加锁，需要拿到当前实例的锁。 修饰静态方法，为当前类对象加锁，需要获得当前类对象的锁。 修饰代码块，指定加锁对象。 修饰实例方法看一个例子： public class Tester &#123; public static void main(String[] args) throws Exception &#123; Example example = new Example(); MyThread myThread = new MyThread(example); MyThread myThread1 = new MyThread(example); myThread.start(); myThread1.start(); &#125;&#125;class Example &#123; public synchronized void execute() throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); Thread.sleep(2000); &#125; &#125;&#125;class MyThread extends Thread &#123; private Example example; MyThread(Example example) &#123; this.example = example; &#125; @Override public void run() &#123; try &#123; example.execute(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在上面的代码中，为execute方法加上synchronized关键字之后，程序会先输出09，之后再输出一次09；如果去掉synchronized关键字之后，两个线程会同时会执行execute方法。 这说明，如果一个方法加上了synchronized关键字，那么该方法就是一个同步方法，如果一个对象有synchronized方法，某一时刻某个线程已经进入到了synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。 现在将每个MyThread构造方法的参数改为两个对象，再次运行，此时即使加上了synchronized关键字，execute方法仍然是同时执行的。这是因为Java中每个对象都有一个monitor，当一个线程去访问某个对象的synchronized方法时，会将该对象上锁，这时，任何一个线程都无法去访问该对象的同步方法了，直到此方法执行完毕或者抛出异常，该对象就会把锁释放，这时其他的线程才可以访问该方法。 MyThread myThread = new MyThread(new Example());MyThread myThread1 = new MyThread(new Example());myThread.start();myThread1.start(); 修饰静态方法当synchronized作用于静态方法时，由于静态方法并不是属于对象，而是属于类，其锁是当前类的Class对象锁，而访问非静态的synchronized方法时，是使用的当前实例的对象锁。 看一个例子： public class Tester &#123; public static void main(String[] args) throws Exception &#123; MyThread myThread = new MyThread(new Example()); MyThread myThread1 = new MyThread(new Example()); myThread.start(); myThread1.start(); synchronized (Tester.class) &#123; &#125; &#125;&#125;class Example &#123; public synchronized static void execute() throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125;class MyThread extends Thread &#123; private Example example; MyThread(Example example) &#123; this.example = example; &#125; @Override public void run() &#123; try &#123; Example.execute(); &#125; catch (InterruptedException e) &#123; e.printSzaitackTrace(); &#125; &#125;&#125; 在synchronized修饰非静态方法时，如果对于不同的实例对象来说，拿到的锁也是不同的，但是对于static方法来说，即使对不同的实例操作，也是拿到的一个Class对象锁，所以对于上面的代码中，即使有两个不同的线程传入了两个不同的Example对象，但是两个线程依然会互相制约，必须先执行完一个再执行另外一个。 修饰代码块synchronized代码块写法： synchronized (object) &#123; &#125; 表示再某个线程在执行的时候会将object对象上锁（该对象可以任意指定）。 在第一种修饰实例方法给出的代码中，将synchronized方法修改为synchronized代码块。 public void execute() throws InterruptedException &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125; 上面传入的对象是Example对象本身，这时，该锁起到的作用和synchronized实例方法的作用是相同的。如果改为synchronized(new Object())，这时由于锁是针对Object对象的一个实例的，所以，该锁就不会起到相应的作用了。 在第二种修饰静态方法给出的代码中，同样将synchronized静态方法修改为synchronized代码块. public void execute() throws InterruptedException &#123; synchronized (Exmple.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125; 上面传入的对象是Example的Class对象，这时，该锁起到的作用和synchronized实例方法的作用是相同的。同样的，如果传入其他的对象，该锁就不会起到相应的作用了。]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—创建线程的方式]]></title>
    <url>%2F2019%2F10%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多线程编程简单介绍几种创建线程的方法 线程的创建方法 继承Thread类，重写run方法；使用匿名内部类。 //继承Thread类，重写run方法class Thread0 extends Thread &#123; @Override public void run() &#123; super.run(); //do something... &#125;&#125;//匿名内部类Thread thread0 = new Thread() &#123; @Override public void run() &#123; super.run(); //do something... &#125;&#125;;class Test &#123; Thread0 thread = new Thread0(); thread.start();&#125; 实现Runnable接口，实现run方法；使用匿名内部类。 //实现Runnable接口，实现run方法class Thread0 implements Runnable &#123; @Override public void run() &#123; //do somrthing... &#125;&#125;//匿名内部类Thread thread0 = new Thread(new Runnable() &#123; @Override public void run() &#123; //do something... &#125;&#125;);class Test &#123; Thread thread = new Thread(new Thread0()); thread.start();&#125; Callable接口除了以上两种方式创建线程以外，还可以通过实现Callable接口并实现call方法的方式实现多线程，利用这种方式，执行完一个线程之后可以通过一个FutureTask对象获取返回值，而Runnable是不能获取到返回值的。并且call方法可以抛出异常，而run方法不可以。 看一个例子： class CallableThread implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); return "haha"; &#125;&#125;public class Tester &#123; public static void main(String[] args) throws Exception &#123; CallableThread thread = new CallableThread(); //使用FutureTask类接收CallableThread返回的数据 FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(thread); new Thread(task).start(); System.out.println(task.get()); &#125;&#125; 关于run和start方法虽然我们定义一个线程是重写或者实现的run方法，但是启动一个线程需要调用start方法，如果直接调用run方法，其实跟调用一个类的普通方法是一样的，run方法的执行还是处在调用该方法的线程中；调用start方法以后，虚拟机才会创建一个新的线程并且调用run方法。（同样地，继承Callable接口实现线程也不可以直接调用call方法） Thread thread0 = new Thread(() -&gt; System.out.println("Current thread: " + Thread.currentThread().getName()));thread0.start();thread0.run();----Output----Current thread: mainCurrent thread: Thread-0 看上面的代码段，调用start方法之后输出新创建的线程Thread-0，调用run方法之后输出的是依然是主线程main。]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的深拷贝和浅拷贝]]></title>
    <url>%2F2019%2F10%2F20%2FJava%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在之前做项目的时候，同组的人因为深拷贝和浅拷贝的问题产生过BUG，当时不是自己负责的部分，没对这个问题做过深入的了解，今天深入学习一下👻 在介绍深拷贝和浅拷贝之前，先温习几个概念。 数据类型Java中的数据类型有两种： 基本类型：粒度最小的数据类型。主要包括 4种整数类型：int、short、long、byte 2种浮点数类型：float、double 1种字符类型：char 1种布尔类型：boolean 引用类型：也叫做句柄，实际存放的应该是一个地址，地址指向实际内容。主要包括： 类 接口 数组 数据如何在内存中储存JVM在程序运行的时候会将内存划分为四个区域： 堆 栈 静态方法区 常量区 针对第一节的数据类型，下面分为基本数据类型的局部变量、基本数据类型的成员变量、引用类型变量来讲解。 基本数据类型的局部变量基本数据类型的局部变量的储存形式如下图所示： 方法中的基本类型的局部变量，都是储存虚拟机的堆内存中的，数据本身的值就是储存在栈内存中。每次给一个新变量赋值的时候，JVM首先会检验内存中有无该数据，如果有，就直接将这个变量指向该数据，没有的话就开辟一个新的内存空间存放数据，然后将变量指向该数据。 int age = 50;int weight = 50;int height = 100; 看上面的代码段，三个变量都是某个方法中的局部变量，当执行int age = 50的时候，首先会定义变量，存入变量表中，然后去栈中找是否存在值为50的内容，并将age变量指向50。当执行int weight = 50时，会在栈中找到50，直接将weight指向50。当方法执行完毕以后，方法局部变量会被JVM的垃圾回收机制回收。 基本数据类型的成员变量和引用类型变量前面提到，除了基本数据类型，还有一种是引用数据类型，对于引用数据类型在内存中的存储形式如下图所示。 public class Student &#123; private String name; private int age; private int grade;&#125; 上面是一个Student类，如果我们不重写toString方法，直接输出一个实例化的对象的话，会得到这样的输出： Student@1b6d3586，其实这就是Student类的地址。 所以，对于引用数据类型来说，引用数据类型只储存一个在堆内存中的地址，而成员变量和方法被储存在堆内存中。 深拷贝和浅拷贝概念前面说了这么多，现在步入正题，首先介绍深拷贝和浅拷贝的概念。 在Java中使用 “=” 做赋值操作时，对于基本数据类型，会直接将值直接赋值给变量，而对于引用数据类型来说，会将其引用赋值给另一个对象。 浅拷贝 浅拷贝会创建一个新的对象，这个对象拥有被拷贝对象的一个精确的副本。在该类的成员变量中，对于基本数据类型，拷贝的就是其值；对于引用数据类型，拷贝的就是其内存地址。如果其中一个对象改变了这个引用数据类型的变量的数据，相应地，另一个对象地该引用数据类型地数据也会随之改变。 如下图，Student类有两个成员变量，一个Schoole类成员变量，一个int类型的成员变量，Student类有两两个实例，student1是对student0的浅拷贝的对象。对于引用类型的School来说，两个对象都储存的是School对象的地址，所以说，如果有其中一个对象的School对象的内容发生了改变，另一个对象也会发生改变；对于基本类型的成员变量来说，两个对象都是直接储存的age的值，双方互不干涉。 深拷贝 深拷贝不仅会为拷贝新建对象，也会对该对象中任何的引用类型变量建立新的对象，这样，拷贝对象和原对象就是两个完全相同的对象，两者各自的成员变量也互不受影响了。 实现浅拷贝先看一个例子（不是浅拷贝）。 public class Tester &#123; public static void main(String[] args) &#123; int age = 10; int age1 = 20; String name = "aaa"; String name1 = "bbb"; Student student = new Student(); student.setAge(age); student.setName(name); Student student1 = student; student.setAge(age1); student.setName(name1); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, name='bbb'&#125;Student&#123;age=20, name='bbb'&#125; 上面代码直接使用了 “=” 对对象进行拷贝，发现，无论是基本类型还是引用类型的数据，只要其中一个对象的值被改变，另一个对象的数据也随之改变。 其实Student student1 = student;这一句代码，相当于只是将student的地址赋值给了student1，两个对象指向一个地址，所有数据都是一起共享的。 而实现浅拷贝之后，创建的新对象会单独开辟一个内存空间有自己的地址，这样对于基本类型的数据来说，每个对象都有自己的数据，而对于引用类型的数据来说，新对象是拷贝的引用类型的地址，所以两个对象是共享该成员变量的。 public class School implements Cloneable &#123; String name; public School(String name) &#123; this.name = name; &#125; ... @Override public String toString() &#123; return "School&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; public class Student implements Cloneable&#123; private int age; private School school; public Student(int age, School school) &#123; this.age = age; this.school = school; &#125; ... @Override public String toString() &#123; return "Student&#123;" + "age=" + age + ", school=" + school + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; public class Tester &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student(10, new School("QUST")); Student student1 = (Student) student.clone(); student.setAge(20); student.getSchool().setName("THU"); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, school=School&#123;name='THU'&#125;&#125;Student&#123;age=10, school=School&#123;name='THU'&#125;&#125; 以上就是一个实现浅拷贝的例子，首先，需要拷贝的类要实现Cloneable接口（此接口是个标识性接口，接口内无任何方法），重写clone方法，在拷贝对象的时候，使用Student student = (Student) student.clone()，这样就实现了浅拷贝。从测试类的输出可以看出来，修改原对象的基本数据类型的成员变量时，拷贝对象并没有收到影响，而修改原对象引用类型成员变量School的属性时，拷贝类型也受到了影响。 实现深拷贝public class School implements Cloneable&#123; String name; public School(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "School&#123;" + "name='" + name + '\'' + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; public class Student implements Cloneable&#123; private int age; private School school; public Student(int age, School school) &#123; this.age = age; this.school = school; &#125; @Override public String toString() &#123; return "Student&#123;" + "age=" + age + ", school=" + school + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Student student = (Student) super.clone(); student.school = (School) this.school.clone(); return student; &#125;&#125; public class Tester &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student(10, new School("QUST")); Student student1 = (Student) student.clone(); student.setAge(20); student.getSchool().setName("THU"); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, school=School&#123;name='THU'&#125;&#125;Student&#123;age=10, school=School&#123;name='QUST'&#125;&#125; 实现深拷贝的方法就是将类中的引用类型变量也进行拷贝，引用类型所在的类实现Cloneable接口，重写clone方法。这样就可以实现深拷贝了。 还有一种实现深拷贝的方式，就是通过序列化实现可以查看Java序列化。 总结 需要拷贝对象的时候，如果一个对象内部数据类型只有基本类型，那么就可以使用浅拷贝，如果一个对象内部还有引用数据类型，就需要使用深拷贝。 虽然深拷贝和浅拷贝可能用到的不会很多，但是对于理解JVM内部内存还是很有帮助的👅]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2019%2F10%2F19%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类所谓内部类就是在一个类的内部再定义一个类，之前自己写代码的时候一直也没用过这种方式，系统地学习一下内部类。 /** * @paragram: InnerClassDemo * @description: 内部类 * @auhor: liuergo * @date: 2019-10-19 16:30 */public class OuterClass&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; class InnerClass&#123; public InnerClass ()&#123; name = "Jack"; age = 20; &#125; &#125;&#125; 上面就是内部类的一个简单的例子。 为什么要使用内部类 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 上面是《Thinking in Java》中的一句话，我们知道，Java中是没有多继承的，所以才出现了接口来解决Java多继承的问题，但是如果使用了内部类，就可以使我们的类继承多个类。 成员内部类最普通的内部类，将内部类作为外部类的一个成员，跟成员变量各种方法是并列的。 public class OuterClass&#123; private String name; private int age; public class InnerClass&#123; public InnerClass ()&#123; name = "Jack"; age = 20; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); &#125;&#125; 实例化一个内部类需要使用外部类的对象.new来创建内部类，在内部类中，是可以随便访问外部类的成员变量的;外部类是不可以随便访问内部类的。 局部内部类在方法中定义的内部类，这时的内部类就不属于外部类的成员了，局部内部类可以访问当前代码块中的final关键字修饰的局部变量以及外部类的成员变量。 public class OuterClass&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void function() &#123; final int i = 0; class InnerClass &#123; private String innerName; void InnerFun() &#123; System.out.println(name); //直接访问外部类的变量 System.out.println(i); //访问final类型的局部变量 System.out.println(this.innerName); //使用this.成员变量访问的是内部类的成员变量 System.out.println(OuterClass.this.name); //使用外部类名.this.成员变量的方式访问成员变量 &#125; &#125; &#125;&#125; 静态内部类在static关键字一节中，提到static关键字可以修饰变量、方法、代码块，其实static还可以修饰内部类，在静态内部类中，是不保留对外部类的引用的，这就意味着，静态内部类的创建不需要依赖于外部类。这样，静态内部类也就只能访问静态变量和静态方法。外部类和内部类其实是没有关联的。 public class OuterClass&#123; private String name; private int age; static int num = 0; static class InnerClass&#123; private String innerName; public InnerClass ()&#123; System.out.println(num); //只能访问static变量 &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); InnerClass innerClass = new InnerClass(); //创建实例不依赖外部类 &#125;&#125; 匿名内部类 匿名内部类这一语法适用于创建一次性使用的类。 在Android编程中，经常会用到点击事件，这就是一个匿名内部类的例子。 btnClick.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //do something &#125;&#125;); 可以看到，在上面的例子中，new了一个View.OnClickListener对象，然而这个对象是没有名字的，这就是匿名内部类的特点。 定义匿名内部类下面是官方文档中给出的一个匿名内部类的例子： public class HelloWorldAnonymousClasses &#123; interface HelloWorld &#123; public void greet(); public void greetSomeone(String someone); &#125; public void sayHello() &#123; //实现HelloWorld接口的内部类 class EnglishGreeting implements HelloWorld &#123; String name = "world"; public void greet() &#123; greetSomeone("world"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Hello " + name); &#125; &#125; HelloWorld englishGreeting = new EnglishGreeting(); //匿名类实现HelloWorld接口 HelloWorld frenchGreeting = new HelloWorld() &#123; String name = "tout le monde"; public void greet() &#123; greetSomeone("tout le monde"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Salut " + name); &#125; &#125;; //匿名类实现HelloWorld接口 HelloWorld spanishGreeting = new HelloWorld() &#123; String name = "mundo"; public void greet() &#123; greetSomeone("mundo"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Hola, " + name); &#125; &#125;; englishGreeting.greet(); frenchGreeting.greetSomeone("Fred"); spanishGreeting.greet(); &#125; public static void main(String... args) &#123; HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); &#125; &#125; 上面的例子中，使用实现HelloWorld接口的方式来定义EnglishGreeting类，实例化之后才可以使用；frenchGreeting、spanishGreeting在定义的时候就实例化了，定义完之后就可以使用。上面的例子中，两种方法是一样的，如果一个类只需要用到一次，那么就没必要用继承父类或者是实现接口的方式再定义一个类，这时候就可以使用匿名内部类。 匿名内部类的语法匿名内部类有两种使用方法： 继承父类的匿名类 Thread thread = new Thread() &#123; @Override public void run() &#123; super.run(); &#125;&#125;; 实现接口的匿名类 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("11"); &#125;&#125;); 第二个例子实际上是将一个实现接口的匿名类作为参数传进了Thread的构造函数中。 关于匿名类的数据访问可以看这篇文章：匿名类的数据访问。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到Github文件夹大小写问题]]></title>
    <url>%2F2019%2F10%2F19%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0Github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述 今天写完博客上传github时，发现algorithm标签404了，上Github仓库一看发现tags文件夹下的algorithm是大写的Algorithm，访问tags/Algorithm，可以正常显示 原因 查询资料发现，git是默认不区分大小写的，之前hexo生成了一个Algorithm文件夹，后来将文件夹的名称改为了algorithm，然而在Github上是不会将大写改为小写的。 解决方法 进入.git文件夹，将config文件的 ignorecase=true 改为 ignorecase=false。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几数之和系列]]></title>
    <url>%2F2019%2F10%2F19%2F%E5%87%A0%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[在LeetCode的ArrayTag中，有一系列的__数之和题，这几道题都有一些相似之处，在这里做一下总结。 总览 两数之和 三数之和 最接近的三数之和 四数之和 求解方法 暴力法（不可取），时间复杂度往往为n的“几数”次方（如两数之和为$O(n^2)​$）。 HashTable减少循环次数，降低时间复杂度。 排序+双指针（推荐）。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 此题是LeetCode入坑第一题，作为一名算法小白，首先就想到了暴力求解法，方法也是简单粗暴，不做解释。 class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //暴力求解 for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[] &#123;i ,j&#125;; &#125; &#125; &#125; throw new IllegalArgumentException("no sulotion!"); &#125;&#125; 暴力终究不可取，此题还可以使用HashTable求解，减少了一次循环；上一种解法相当于是每个数都要去找一个能和别人配对的数，而利用HashTable的解法是将每个数想要配对的数存起来，并且在存起来之前，检查一遍当前的HashTable中是否已经存在了想要配对的数，如果配对成功，直接返回结果。 class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //HashMap HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int a = target - nums[i]; //想要配对的数 if (hashMap.containsKey(a) ) &#123; return new int[] &#123;hashMap.get(a),i&#125;; &#125; hashMap.put(nums[i], i); &#125; throw new IllegalArgumentException("no sulotion!"); &#125;&#125; 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，*使得 *a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 此题可以参照两数之和的解法继续使用暴力法或者是HashTable解法，但是题目要求不可以包含重复的三元组，所以去重是个大问题，目前除了想到对每个三元组进行排序再使用HashSet去重外，还没有想到别的好办法。 接下来主要介绍排序+双指针的方法。 此题最合适的方法是采用双指针的方法求解，关于双指针在之前的一道题已经使用过了，最主要的一点就是关于指针如何移动的问题。 算法详解 对数据进行排序，一般使用双指针求解都要先对数据进行排序。 确定三个指针的初始位置，k指向最左边也就是最小的数，i和j分别指向除了k处的两端，分别向中间移动，也就是说，移动方式为i++或者j–。 计算三数之和sum，如果sum = 0，直接返回结果；如果sum &gt; 0，应该向右移动i指针，解释一下，我们的目的是需要让当前的sum值减小慢慢向0趋近，i++的方式会让sum的值增大，而j–的方式会让sum的值减小，所以应该向右移动i指针；如果sum &lt; 0，应该向左移动j指针。 由于事先对数据进行了排序，去重也变得有迹可循，首先，我们需要分析重复数据是如何产生的。看下面一个例子。 去除重复数据 拿示例数据[-1, 0, 1, 2, -1, -4]来说，首先对数据排序，当前k指向-1，i指向0，j指向1，当前结果就是一个符合条件的结果 k i j -4 -1 -1 0 1 2 当k继续移动一位以后，发现当前的情况也是一个符合条件的结果，但是很明显和上一种结果重复了。由此，产生重复结果的原因就在于k了，如果存在两个k指针所指的数重复，那么下一次循环就可以直接跳过，这样就避免了重复结果的产生。 k i j -4 -1 -1 0 1 2 另外，对于其他两个指针，同样会产生重复的情况，分析过程和上面对k指针的分析相同。 代码： class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; //排序 + 双指针 List&lt;List&lt;Integer&gt;&gt; ternaryList = new ArrayList&lt;&gt;(); Arrays.sort(nums); //[-4, -1, -1, 0, 1, 2] //[-1, -1, 0, 1] for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //去重 int i = i + 1; int j = nums.length - 1; while (i &lt; j) &#123; int sum = nums[i] + nums[i] + nums[j]; if (sum == 0) &#123; ternaryList.add(Arrays.asList(nums[i], nums[i], nums[j])); while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) i++; // 去重 while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) j--; // 去重 j--; i++; &#125; else if (sum &lt; 0) &#123; i++; &#125; else if (sum &gt; 0) &#123; j--; &#125; &#125; &#125; return ternaryList; &#125;&#125; 剩下的两道题解法和三数之和基本相同，只给出代码。 最接近的三数之和class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int result = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length; i++) &#123; int j = i + 1, k = nums.length - 1; while (j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; // 移动指针 if (sum == target) &#123; return sum; &#125; if (sum &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return result; &#125;&#125; 四数之和class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //去重 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; //去重 int k = j + 1, l = nums.length - 1; while (k &lt; l) &#123; int sum = nums[i] + nums[j] + nums[k] + nums[l]; if (sum == target) &#123; result.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l])); while (k &lt; l &amp;&amp; nums[k] == nums[k + 1]) k++; while (k &lt; l &amp;&amp; nums[l] == nums[l - 1]) l--; k++; l--; &#125; else if (sum &gt; target) &#123; l--; &#125; else if (sum &lt; target)&#123; k++; &#125; &#125; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>two-pointers</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two pointer]]></title>
    <url>%2F2019%2F10%2F16%2FTwo%20pointers%2F</url>
    <content type="text"><![CDATA[盛最多水的容器 Category Difficulty Likes Dislikes algorithms Medium (58.43%) 847 - Tagsarray&nbsp;|&nbsp;two-pointers Companiesbloomberg 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 作者：LeetCode链接：https://leetcode-cn.com/problems/container-with-most-water/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 解题方法暴力法第一次Submit的时候，奈何不知道双指针，用的暴力法，还有一种LeetCode官方解答种使用Java内置Math工具类的比较简介的写法。 class Solution &#123; public int maxArea(int[] height) &#123;// //暴力法// int maxArea = 0;// for (int i = 0; i &lt; height.length; i++) &#123;// for (int j = i + 1; j &lt; height.length; j++) &#123;// int area = 0;// if (height[i] &lt;= height[j]) &#123;// area = height[i] * (j - i);// &#125; else &#123;// area = height[j] * (j - i);// &#125;// if (area &gt;= maxArea) &#123;// maxArea = area;// &#125;// &#125;// &#125;// return maxArea; //2.暴力法(精简) int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i)); &#125; &#125; return maxArea; &#125;&#125; 复杂度 时间复杂度：$O(n^2)​$。 空间复杂度：$O(1)$。 ##双指针法 思路：双指针分别位于容器两端，根据某个规则向内移动指针，并且更新面积的最大值，直到i == j，返回最大值。 水槽的面积公式：$S = min(h[i], h[j]) * (j - i)$ 如果短板或者长板向中间移动，j或者i就会-1，(j - i)就会-1。 如果移动长板，下一个短板min(h[i], h[j])会不变或者变小，然而只要指针发生了移动，(j - i)必变小，所以下一个水槽的面积一定不会大于上一个水槽的面积。 如果移动短板，下一个短板min(h[i], h[j])才可能会变大，所以下一个水槽的面积才有可能变大。 所以，移动规则就是每次向着短板的方向移动。 代码： class Solution &#123; public int maxArea(int[] height) &#123; //双指针法 int head = 0, tail = height.length - 1, maxArea = 0; while (head &lt; tail) &#123; if (height[head] &lt;= height[tail]) &#123; maxArea = Math.max(height[head] * (tail - head), maxArea); head++; &#125; else &#123; maxArea = Math.max(height[tail] * (tail - head), maxArea); tail--; &#125; &#125; return maxArea; &#125;&#125; 复杂度： 时间复杂度：$O(n)​$。 空间复杂度：$O(1)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Final arrays in Java]]></title>
    <url>%2F2019%2F10%2F10%2FFinal%20arrays%20in%20Java%2F</url>
    <content type="text"><![CDATA[之前在做第一个安卓项目时，在使用TimerTask和使用Thread创建新线程的时候，发现如果在匿名方法中对局部变量进行修改的时候会报错，但是可以访问局部变量，而使用成员变量的时候就不会报错。不过，如果将其写成下面就不会报错了，但是问题又来了，明明将变量声明成了final类型，为什么可以修改其值呢？ void myThread() &#123; final int[] i = &#123;0&#125;; Thread thread = new Thread(()-&gt; i[0]++); thread.start();&#125; 我们需要解决以下几个问题： 为什么在匿名方法中可以修改成员变量而不可以修改局部变量？ 为什么匿名方法中只能访问final类型的局部变量？ 为什么final数组的值可以被修改？ 在匿名方法中使用的局部变量为什么只能是final原因是Java设计者想要匿名函数或者Lambda函数内部外部保持数据一致性，在匿名方法中使用局部变量时，内部类并不是真正地使用该变量，而是在匿名方法中复制一个副本，由于是副本，所以即使是在匿名方法中修改了该变量，局部变量也不会发生变化，所以匿名方法使用的局部变量只能是final类型的变量。 注：在Java8以前，访问任何局部变量都要加final关键字，而在Java8之后，只要不涉及修改局部变量的操作，就可以不用加final关键字。 但是，对于成员变量来说，匿名方法会保存外部类的引用，因而内部类中对任何字段的修改都回真实的反应到外部类实例本身上，所以不需要用final来修饰它。具体可以参考该博客：https://www.cnblogs.com/qq78292959/p/3745348.html Final arrays如果非要对局部变量进行修改怎么办，那就只能用到上面的final数组方法。我们都知道，final类型的数据是不可以被修改的，但是为什么此处的final数组的值被修改了呢？ 下面是一个静态常量： public final int[] number = &#123;1, 2, 3&#125;; final关键字能保证数据不可以被修改对于基本类型来说这点是成立的，但对于数组来说就不成立了，因为数组和类以及接口一样，是引用类型，引用数据类型实际上只储存了一个指针，final只能保证其引用不变，即这个指针不变，但是数组中的对象的值还是可以改变的。而且，引用数据类型的数据是储存在堆内存中的，匿名方法可以共享。 注意：正是由于final数组的这个特性，所以在需要定义一个常量数组的时候，不要使用该方法，这样定义依然是会被修改值的。 文章开始的代码可以重写Thread类，定义Thread类的成员变量来实现相同的功能。 private void myThread()&#123; class MyThread extends Thread &#123; private int i = 0; @Override public void run() &#123; super.run(); i++; System.out.println(i); &#125; &#125; MyThread myThread = new MyThread(); myThread.start();&#125; 总结 在匿名方法中使用的局部变量只能是fianl类型的。 Java8以后，只要不对局部变量修改，局部变量即使不加final关键字也可以被匿名方法访问。 如果匿名方法要修改局部变量，可以将变量定义成final数组的形式。 如果要final发挥常量作用，final数组要慎用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static关键字]]></title>
    <url>%2F2019%2F10%2F10%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static关键字是经常会使用到的，之前一直没有对该关键字进行过深入地学习过，下面就讲述一下该关键字以及用途。 static关键字static关键字表示全局或者静态的意思，可以实现类似全局变量的作用，用static修饰变量或者方法都是独立于某个类的，会被所有的该类的实例共享，所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 public class Student &#123; private static int count; Student() &#123; count++; &#125; public static void main(String[] args) &#123; Student student = new Student(); Student student1 = new Student(); Student student2 = new Student(); System.out.println(Student.count); &#125;&#125;---------------Output:3 如上面的代码，运行结果为3，说明三个类的实例是共享静态变量count的，使用上面的代码可以统计一个类被实例化了多少次。 static关键字的用途 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 上面是《Thinking in Java》对static关键字作用的解释，总结一下，就是static方法可以在不用实例化对象的情况下使用。 static变量有static关键字修饰的变量为静态变量，而没有static修饰的变量是成员变量，在对类进行实例化的时候，无论进行多少次实例化，静态变量也只会被实例化一次，而成员变量则不同，它是伴随着实例的，每创建一个实例就会产生一个成员变量。 static成员变量的初始化顺序按照定义的顺序进行初始化。 在C/C++中static是可以作用域局部变量的，但是在Java中static是不允许用来修饰局部变量。 static方法有static关键字修饰的方法可以直接通过类名进行调用。由于static方法在类加载的时候就已经存在了，它不依赖于任何实例。 注意，在静态方法中不能调用非静态成员和非静态方法，在静态方法加载的时候非静态成员和方法还未加载；然而，在非静态方法中可以调用静态方法。 static代码块static关键字的一个比较特殊的用法就是静态代码块。静态代码块同样是在虚拟机加载类的时候就会会被加载执行，而且只执行一次。如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们。 静态代码块作用静态代码块的一个比较重要的作用就是可以优化性能。 比如下面的例子： public class Student &#123; private Date birthDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是判断该人是否是1946年到1964年之间出生的，每次isBornBoomer被调用的时候都会生成startDate和endDate两个对象，造成了空间浪费，可以改成下面的形式： public class Student &#123; private Date birthDate; private static Date startDate,endDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; static &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 所以，可以对只进行一次初始化的操作放在static代码块中进行。 静态代码块的执行时机在Java中，一个类的加载过程分为三个步骤：1. 装载 2. 连接 3. 初始化。 静态代码块是在类初始化的时候执行的，初始化阶段，jvm主要完成对静态变量的初始化，静态块执行等工作。 Class A&#123; static&#123; System.out.println("static block invoked!") &#125;&#125; 上面的代码中 new A()会执行static代码块中的内容。 Class.forName(&quot;A&quot;)会执行代码块中的内容；这个过程相当于Class.forName(&quot;A&quot;, true, A.class.getClassLoader())。 Class.forName(&quot;A&quot;, false, A.class.getClassLoader())不会执行代码块中的内容；因为false指明了在类加载的过程中不进行初始化，就不会执行static代码块了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置WireShark抓取https数据包]]></title>
    <url>%2F2019%2F09%2F29%2F%E9%85%8D%E7%BD%AEWireShark%E6%8A%93%E5%8F%96https%E6%95%B0%E6%8D%AE%E5%8C%85%2F</url>
    <content type="text"><![CDATA[配置环境变量SSLKEYLOGFILE为E:\ssl_key\sslog.log。 完全退出chrome或者firefox浏览器，然后重新打开。打开浏览器，访问一个HTTPS 网页，然后打开刚才SSLKEYLOGFILE环境变量值的文件路径就可以看到随机字符串记录。 配置WireShark。打开编辑-&gt;首选项-&gt;Protocols，打开SSL对其进行编辑（注：wireshark在某次版本更新之后去掉了SSL选项，没有SSL选项的需要设置TSL），将日志文件的路径添加到(Pre)-Master-Securet log file。 访问www.liuergo.top ，在WireShark中开始抓包，可以发现https的数据包可以被抓到了。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>WireShark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2019%2F09%2F27%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要是对《HTTP图解》这本书的学习记录，加上一些实验课中以及自己做的实验深入学习HTTP协议。 HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 协议报文解析HTTP报文大致可分为报文首部和报文主体两部分，两者由一个空行划分。通常，不一定要有报文主体（GET方法就没有报文主体）。 请求行：包含用于请求的方法，请求的URI和HTTP版本。 状态行：包含表明响应结果的状态码，状态短语和HTTP版本。 首部字段：包含表示请求和响应的各种条件和属性的各类首部。 报文主体：应被发送的数据。 实验验证 输入URL: http://gaia.cs.umass.edu/ethereal-labs/HTTP-ethereal-file3.html ，使用WireShark抓包。 输入过滤表达式tcp &amp;&amp; ip.addr==128.119.245.12 观察抓到的数据包 重点关注下面这一部分 352号包 这个包就是客户端发送给服务端HTTPGET请求，由请求行、各种首部字段和空行组成，在GET请求中，没有请求的报文主体部分。 384号包 在TCP协议中，发送双方每发出一个包都要有响应，此包就是服务端对刚刚发送的HTTP的GET包的响应。 386、387、389、390号包 首先，介绍一下WireShark中TCP segment of a ressembled PDU的概念，在TCP协议中，会将一个较大的数据包分成很多个小包发出去，在WireShark中，TCP segment of a ressembled PDU就是被TCP协议所分成的一个个小的数据包。 其实，这四个包都是TCP分成的小包，WireShark在最后一个http包中将所有的包都进行了重新拼包。 查看386号数据包 点击TCP segment data，查看此segment的数据内容，发现其中的数据就是http报文，只不过是服务器返回的http长报文的一部分。 查看390号数据包 打开4 Reassembled TCP Segments，可以看到所有被TCP所分成的四个小数据包，正是386，387，389，390号包。 查看HTTP数据包的内容 此数据包是服务端返回的HTTP报文，由状态行、首部字段、报文主体和空行组成。通过Line-based text data可以查看具体的报文主体部分的数据。 HTTP方法GET：获取资源GET方法用于从服务器端获取数据，包括静态资源(HTML、CSS、JS、Image等等)。 POST：传输实体的主体POST方法用于向服务器提交数据，比如增删改数据，提交一个表单新建一个用户、或修改一个用户等。 GET主要目的，获取资源；POST主要目的，发送数据对指定资源做处理。 GET和POST到底有什么区别？ PUT：传输文件向服务端增加某个资源文件。 ##DELETE：删除文件 删除指定的资源文件。 在RESTful风格的接口中，PUT、DELETE、GET、POST分别对应对资源的增删查改。 状态码分类 分类 描述 1XX 信息，服务器收到请求，需要请求者继续执行操作 2XX 成功，操作被成功接收并处理 3XX 重定向，需要进一步的操作以完成请求(除304) 4XX 客户端错误，请求包含语法错误或无法完成请求 5XX 服务器错误，服务器在处理请求的过程中发生了错误 2XX成功200 OK表示从客户端发来的请求在服务端被正常处理了，请求资源成功。 3XX重定向301 Moved Permanently永久重定向。表示请求的资源已经被永久地转移到了某个新的URI。 例如http协议重定向至https协议。 302 Found临时重定向。表示请求的资源是临时被分配到一个新的URI中。 304 Not Modified表示服务器端资源未发生改变，可以直接使用服务器缓存。 4XX403 Forbidden资源访问被拒绝。一般没有响应的权限的话会返回该状态码。 404 Not Found服务器上无法找到请求的资源。 5XX500 Internal Server Error服务端出BUG。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点整理（持续更新...）]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本学期学习了计算机网络，本文将整理计算机网络的一些基础知识点，供自己以后查阅。 计算机网络的几种分层结构计算机网络通常可以进行下面的几种分层方式： 七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。 五层划分为：应用层、传输层、网络层、数据链路层、物理层。 四层划分为：应用层、传输层、网络层、网络接口层。 下面基本以五层架构为标准讲解 每层常用的网络协议 层 网络协议 应用层 http DNS FTP TFTP Telnet SMTP 传输层 TCP UDP 网络层 IP ICMP RIP ICMP 数据链路层 ARP RARP 每层较重要的协议应用层 协议名称 基本介绍 http 超文本传输协议，是用于从万维网服务器传输超文本到本地浏览器的传送协议，基于TCP/IP协议通信。 DNS 将域名解析为IP地址的协议，基于UDP协议通信。 FTP 文件传输协议。 TFTP 简单文件传输协议。 Telnet 为用户提供了在本地计算机上完成远程主机工作的能力。 SMTP 简单邮件传输协议。 传输层 协议名称 基本介绍 TCP TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP UDP协议是一种无连接的简单传输协议。 网络层 协议名称 基本介绍 IP IP协议不仅定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择。 ICMP 面向无连接的协议，用于传输出错报告控制信息。（ping命令就是使用的该协议，ping虽然处在应用层，但是可以直接使用网络层的ICMP协议） RIP 是一种内部网关协议，是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。 数据链路层 协议名称 基本介绍 ARP 地址解析协议，可以根据IP地址获取物理地址。 RARP 反向地址转换协议，可以根据物理地址获取IP地址。 常用端口号概述计算机端口号总数：65535。 0-1023： 系统端口，也叫公认端口，这些端口只有系统特许的进程才能使用。 1024~65535：用户端口，用户可以自定义这些端口的作用。 常用端口 协议/服务名称 端口号 http 80 https 443 www代理服务 8080 ssh 22 DNS 53 FTP 20（用于连接）、21（用于传输） Telnet 23]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化介绍 序列化：将对象写入到IO流中 反序列化：将对象从IO流中恢复 序列化的意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在，而且这整个过程都是独立于JVM进行的。 使用场景：所有在网络上传输的对象都需要进行序列化，比如在使用RMI(远程方法调用)时；所有需要保存到磁盘上的Java对象必须是可以被序列化的。通常程序创建的每个JavaBean都要实现Serializeable接口。 实现序列化如果一个类要实现序列化，那么这个类应该实现Serializable接口或者Externalizable接口。 Serializable接口Serializable接口是个标记接口，和之前提到的RandomAccess接口一样，接口中没有任何方法。一旦实现了该类，就表明该类是可序列化的。 序列化步骤 相应的类实现Serializeable接口。 Student.java /** * @paragram: SerializeDemo * @description: 学生类 * @auhor: liuergo * @date: 2019-09-26 21:55 */public class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125; 创建一个ObjectOutputStream输出流，并调用ObjectOutputStream对象的writeObject输出可序列化对象。 public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student.txt")); Student student = new Student("二狗", 18); objectOutputStream.writeObject(student); &#125; catch (IOException e) &#123; e.printStackTrace() &#125;&#125; 这时，会生成一个Student.txt文件。 反序列化步骤创建一个ObjectInputStream输入，并调用ObjectInputStream对象的readObject方法。 public static void main(String[] args) &#123; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student.txt")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//Student&#123;name='二狗', age='18'&#125; 反序列化不需要调用构造方法，其反序列化的对象是由JVM自己生成的对象，不需要构造方法生成。 对同一个对象多次序列化public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); Student student = new Student("二狗", 18); Student student1 = new Student("大鹅", 18); Student student2 = new Student("三虎", 19); objectOutputStream.writeObject(student); objectOutputStream.writeObject(student1); objectOutputStream.writeObject(student2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//运行结果//Student&#123;name='二狗', age='18'&#125; 从运行结果可以看出，在对一个对象进行序列化之后，并不会再次对其进行序列化。 所以，该序列化算法存在这样一个问题，如果在对一个对象进行序列化之后，需要修改该对象的内容，第二次序列化并不会成功。 transient关键字如果有时候对象的某些属性不需要序列化。这时候就可以使用该关键字选择不需要序列化的属性。 public class Student implements Serializable&#123; private transient String name; private int age; ...&#125; 这时序列化的结果就变成了Student{name=&#39;null&#39;, age=&#39;18&#39;}，这样，序列化的时候就自动忽略了name这个属性。 Externalizable接口 Externalizable.java public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 可以看到，该接口有两个方法，实现该接口，必须要实现writeExternal、readExternal两个方法。 public class Student implements Externalizable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; StringBuffer reverseString = new StringBuffer(this.name).reverse(); out.writeObject(reverseString); out.writeInt(this.age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; this.name = ((StringBuffer) in.readObject()).reverse().toString(); this.age = in.readInt(); &#125;&#125; Student类继承Externalizable接口之后，实现两个方法，在writeExternal方法中，可以对其进行一加密以保证安全性，注意要在readExternal方法中写相应的解密方法；而且如果不需要对某个属性进行序列化的话，就可以直接去掉某个属性序列化的语句，相当于实现了transient关键字的作用。 public static void main(String[] args) throws Exception&#123; Student student = new Student("二狗", 18); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); objectOutputStream.writeObject(student); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student1 = (Student) objectInputStream.readObject(); System.out.println(student1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 序列化和反序列化的代码和之前的是一样的，看到这里可能或产生一个问题，在上面的一段代码中，并没有看到刚刚的writeExternal和readExternal被显式调用，那么这两个方法到底是如何被调用的呢？ 查看ObjectOutputStream的源码，对于一个实现了EXternalizable接口的类来说，可以看出writeObject的调用栈： writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeExternalData ObjectOutputStream.java private void writeObject0(Object obj, boolean unshared) throws IOException&#123;......// remaining cases if (obj instanceof String) &#123; writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared); &#125;......&#125;private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException&#123;...... if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc); &#125;......&#125;/** * Writes externalizable data of given object by invoking its * writeExternal() method. */private void writeExternalData(Externalizable obj) throws IOException &#123; PutFieldImpl oldPut = curPut; curPut = null; if (extendedDebugInfo) &#123; debugInfoStack.push("writeExternal data"); &#125; SerialCallbackContext oldContext = curContext; try &#123; curContext = null; if (protocol == PROTOCOL_VERSION_1) &#123; obj.writeExternal(this); &#125; else &#123; bout.setBlockDataMode(true); obj.writeExternal(this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; &#125; finally &#123; curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; ⭐上面的部分源码给出了调用栈的后三个方法，通过源码可以很清晰地看出，由于Externalizable接口也实现了Serializable接口，所以在writeObject0方法中首先经过obj instanceof Serializable进入writeOrdinaryObject方法，在这里对该对象是否实现了Externalizable接口进行了判断（如果是继承了Serializable接口，会调用writeSerialData方法，这种情况会在下面讲解），最后调用writeExternalData方法，可以看到在该方法中会调用在类中重写的writeExternal方法。 🐞第一次运行的时候，报了以下异常，no valid constructor，没有合法的构造器，这是因为Student类中没有一个无参的构造器。在通过实现接口Externalizable进行序列化读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器，增加一个无参构造器之后就不会报这个异常了。 serialVersionUID在学习集合类的时候经常能在源码中看见serialVersionUID，当时只是知道和序列化有关，今天就深入了解一下。 JVM是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，即serialVersionUID。 如果反序列化时候的使用的序列化ID与序列化时使用的ID不同的话，就会报InvalidClassException异常。 需要特别说明的是，如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。 ⭐所以，在编写某个JavaBean时，最好是给这个serialVersionUID赋值，这样就可以避免以后在更新类的时候产生异常，方便升级。 ArrayList的序列化最初学习序列化的原因，是因为一开始看ArrayList源码的时候，不知道serialVersionUID一大串数字是干嘛的，也不知道transient关键字的含义，现在学习完序列化之后再回过头来看ArrayList的源码。从ArrayList的源码开始，我们首先关注下面的部分。 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; transient Object[] elementData; // non-private to simplify nested class access&#125; 可以看到，底层的实现数组使用了transient关键字，也就是说，ArrayList是不会被序列化的吗？ public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ArrayList")); objectOutputStream.writeObject(list); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("ArrayList")); ArrayList&lt;Integer&gt; list1 = (ArrayList&lt;Integer&gt;) objectInputStream.readObject(); System.out.println(list1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//[1, 2, 3] 然而在经过测试之后，可以发现，ArrayList被序列化成功了，那么使用了transient关键字为什么还会被序列化？既然要序列化ArrayList，又是为什么要使用该关键字呢？ 其实事情的真相就在于ArrayList中的两个方法writeObject和readObject方法，下面是两个方法的源码部分。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 从源码可以看出，在序列化一个ArrayList时，会将size和elementData都写入输出流，这就是为什么加了transient关键字之后依然会被序列化的原因。那么为什么要加这个关键字呢？这是因为elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上面的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 现在还有一个问题就是，这两个方法是如何被调用的呢？有了前面对Externalizable接口分析的经验，直接查看ObjectOutputStream的writeSerialData方法，在该方法中调用了invokeWriteObject方法来实现序列化，下面直接看该方法。 void invokeWriteObject(Object obj, ObjectOutputStream out) throws IOException, UnsupportedOperationException&#123; requireInitialized(); if (writeObjectMethod != null) &#123; try &#123; writeObjectMethod.invoke(obj, new Object[]&#123; out &#125;); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); if (th instanceof IOException) &#123; throw (IOException) th; &#125; else &#123; throwMiscException(th); &#125; &#125; catch (IllegalAccessException ex) &#123; // should not occur, as access checks have been suppressed throw new InternalError(ex); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125;&#125; ObjectStreamClass.java writeObjectMethod = getPrivateMethod(cl, "writeObject", new Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;, Void.TYPE);readObjectMethod = getPrivateMethod(cl, "readObject", new Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;, Void.TYPE); 重点关注writeObjectMethod.invoke(obj, new Object[]{ out });这一行，其中的writewriteObjectMethod对象就是在ObjectStreamClass类中定义的，通过反射的方式调用的两个方法。 总结 实现序列化的方式主要有以下几种： 实现Serializable接口，调用ObjectOutputStream的writeObject方法，将对象序列化，这时，是使用的Java的自带的序列化方式。此时被transient关键字修饰的属性，不会被序列化。 实现Serializable接口，同时提供writeObject方法，这时ObjectOutputStream就会通过反射的方式调用writeObject方法。此时transient修饰的字段，是否会被序列化，取决于writeObject方法。 实现 Externalizable接口，并实现两个方法，这时ObjectOutputStream就会自动调用writeObject方法。此时，transient关键字不会起作用，是否会被序列化，取决于writeObject方法。 定义JavaBean时，最好都实现Serializable接口，并且定义serialVersionUID。 静态变量不会被实例化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RandomAccess接口]]></title>
    <url>%2F2019%2F09%2F24%2FRandomAccess%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通过在Java集合类中，查看类继承图和源码可以看出ArrayList和Vector都实现了RandomAccess接口，而LinkList却没有实现该接口，查看RandomAccess接口，发现里面是空的。 RandomAccess.java package java.util;/** * 一大堆注释... */public interface RandomAccess &#123;&#125; 其实，该接口只是一个标识性接口(Marker)，除了RandomAccess接口外，还有Cloneable (可拷贝克隆)、Serializable(被序列化)，之后会有文章介绍这两个接口。 该接口的官方解释 List实现使用的标记界面，表明它们支持快速（通常为恒定时间）随机访问。 此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。 当施加到顺序访问列表（如LinkedList），用于操纵随机接入列表（如ArrayList）最好算法可以产生二次行为。 鼓励通用列表算法在应用如果应用于顺序访问列表之前提供较差性能的算法，并且如果需要改变其行为以确保可接受的性能，则检查给定列表是否为instanceof此接口。 此循环： for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); 比这个循环运行得更快： for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); Collections类中的使用此接口在Collections类中有很多地方都使用到了，比如下面的binarySearch方法 Collection.java @SuppressWarnings("unchecked")public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123; if (c==null) return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key); if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key, c); else return Collections.iteratorBinarySearch(list, key, c);&#125; 上面的方法中，通过判断list是否实现了RandomAccess接口来判断执行indexedBinarySearch方法还是执行iteratorBinarySearch方法(instanceof关键字的作用是判断某个对象所在的类是否继承某个类或者是实现某个接口)。 应用下面先做一个分别使用for循环和Iterator遍历ArrayList和LinkedList的实验。 RamdomAccessDemo.java import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;/** * @paragram: CollectionDemo * @description: RandomAccess接口Demo * @auhor: liuergo * @date: 2019-09-24 23:00 */public class RandomAccessDemo &#123; public static void main(String[] args) &#123; System.out.println("arrayList使用for循环遍历" + arrayListFor()); System.out.println("arrayList使用Iterator遍历" + arrayListIterator()); System.out.println("linkedList使用for循环遍历" + linkedListFor()); System.out.println("linkedList使用Iterator遍历" + linkedListIterator()); &#125; //for循环遍历ArrayList public static long arrayListFor() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long arrayListIterator() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //for循环遍历ArrayList public static long linkedListFor() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long linkedListIterator() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125;&#125; 运行结果 可以发现，使用for循环比使用Iterator遍历ArrayList快，使用Iterator比使用for循环快。 所以，我们在使用这些集合类的时候，应该想到对于不同的集合类采取不同的遍历方式，具体采取那种方式就可以采取通过判断该类是否实现了RandomAccess接口的方式。 可以采用如下的模板： public void traverseList(List list) &#123; if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; &#125; &#125; else &#123; Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; &#125; &#125;&#125; 注：推荐使用增强for循环，增强for循环在底层也是实现的Iterator。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS+PicGo建立图床]]></title>
    <url>%2F2019%2F09%2F21%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%2BPicGo%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在本地写md文档时候插入图片是一件挺麻烦的事情，使用本地图片的话，每次在给别人分享文档或者上传博客的时候就比较难顶了。网上有两种方法可以解决这个问题，一种是使用图片的base64编码，但是图片转换为base64编码之后，编码长度会很大，文档的可读性不好，而且也会使文档的体积急剧变大，这种方法显然不太好。所以，最终使用了图床的方法将图片储存在阿里云中。 开通OSS服务​ 进入阿里云创建一个对象存储OSS的服务，之后新建一个Bucket，创建Bucket之后，我们的存储空间就创建成功了。 使用PicGo快速上传图片 PicGo下载地址https://github.com/Molunerfinn/PicGo 配置PicGo ​ KeyId和KeySecret可以从阿里的控制台获取。 ​ 储存空间名就是Bucket的名称，存储区域在访问域名可以找到。 ​ 配置完成之后就可以使用PicGo上传图片了。 踩坑记录​ 第一次使用PicGo上传图片的时候，总是提示上传失败，检查了好几遍配置，都没有什么错误，可是就是上传不了。 ​ 打开PicGo的配置文件之后，发现有下面的报错信息。 2019-09-21 21:33:11 [PicGo ERROR] StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot;------Error Stack Begin------StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot; at new StatusCodeError (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\errors.js:32:15) at Request.plumbing.callback (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:104:33) at Request.RP$callback [as _callback] (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:46:31) at Request.self.callback (E:\PicGo\resources\app.asar\node_modules\request\request.js:185:22) at Request.emit (events.js:182:13) at Request.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1157:10) at Request.emit (events.js:182:13) at IncomingMessage.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1079:12) at Object.onceWrapper (events.js:273:13) at IncomingMessage.emit (events.js:187:15)-------Error Stack End------- ​ 重点关注The difference between the request time and the current time is too large这一部分，查找阿里云OS文档，403错误及排查。看到下面的部分，就明白了出问题的原因。 ​ 由于我的电脑是Windows+Ubuntu双系统，每次切换系统的时候都会产生八个小时的时差，一直没有解决这个冲突问题，所以造成了Windows时间不正常，也就导致了今天的问题。 ​ 解决方法就很简单了，重新同步一下时钟就好了。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合类]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java众多的集合类由两大接口衍生而来：Collection接口和Map接口 CollectionList(有序，可重复)ArrayList优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程不安全，效率高。 类继承图 ArrayList.java /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 上面的elementData就是ArrayList的底层数组的实现。 Vector优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程安全，效率低。 类继承图 Vector.java /** * Appends the specified element to the end of this Vector. * * @param e element to be appended to this Vector * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) * @since 1.2 */public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 查看Vector的源码可以发现，大部分源码都加上了synchronized关键字，比如上面的add方法，这也是Vector线程安全的原因。 LinkedList优点: 底层数据结构是链表，查询慢，增删快。缺点: 线程不安全，效率高。 类继承图 比较LinkedList和前两个集合类的区别，可以发现LinkedList实现了Deque接口，并且没有实现 RandomAccess接口，表示此集合类不支持快速随机访问，此接口有专门的文章讲解。 Set(无序，唯一)HashSet底层数据结构是哈希表（无序，唯一）。 类继承图 可以看出，HashSet也是没有实现RandomAccess接口的，不支持快速随机访问，关于HashSet是如何保证元素的唯一性的，及其无序性的原因将在HashMap中解释。 HashSet.java private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 从上面的源码可以看出，HashSet的底层实现是HashMap，每次调用add方法时，Map的value部分仅仅put了一个一个Object对象，而HashMap的Key是唯一的，也就保证了HashSet的唯一性。 LinkedHashSet底层数据结构是哈希表和链表（有序，唯一），链表保证其有序，哈希表保证其唯一。 从类继承图可以看出，LinkedHashSet继承了HashSet，从下面的源码可以看出，LinkedHashSet主要是实现了HashSet的HashSet(int initialCapacity, float loadFactor, boolean dummy)构造方法，在该方法中新建了一个LinkedHashMap对象，链表部分的实现就在LikedHashMap中实现了。 //LinkedHashSet.javapublic LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;//HashSet.javaHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; TreeSet底层数据结构是红黑树（唯一，有序）。SortedSet接口保证了其有序性，主要用于排序。 类继承图 MapHashMapMap族主要包括HashMap、LinkedHashMap、TreeMap、Hashtable HashMap 线程不安全，效率高，无序。 HashMap允许空值，并且key和value都允许。key值具有唯一性，存在的话key值不会覆盖，新的value会替代旧的value，而且HashMap是无序的，之后会有源码讲解详细解释。 LinkedHashMap 内部维持了一个双向链表，相比于HashMap来说可以保证有序。 TreeMap 内部实现是红黑树，可以对插入的元素进行自动排序。 Hashtable 很多方法加上了synchronized，所以，Hashtable是线程安全的，而且Hashtable不允许空值。 对比分析TreeSet，LinkedHashSet，HashSet对比相同点 由于实现了Set接口，都有唯一性的特点。 三者都不是线程安全的，如果想保证线程安全，可以使用Collections.synchronizedSet()方法。 不同点 是否有序：HashSet直接实现了HanshMap，是无序的，而由于LinkedHashSet实现了链表，可以保证数据按照插入顺序排序，TreeSet会对插入的数据实现排序。 是否允许空值：HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException。 测试public static void setTest() &#123; HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); for (Integer data: Arrays.asList(745, 3, 114, 526, 5, 7, 4)) &#123; hashSet.add(data); linkedHashSet.add(data); treeSet.add(data); &#125; System.out.println("HashSet：" + hashSet); System.out.println("LinkedHashSet：" + linkedHashSet); System.out.println("TreeSet：" + treeSet);&#125; 运行结果 可以看出来，遍历HashSet的结果是无序的，遍历LinkedHashSet的结果是跟插入数据的顺序保持一致，TreeSet可以对数据进行排序。 HashMap、LinkedHashMap、TreeMap、Hashtable对比相同点 都是用于储存key/value键值对，key不能重复 不同点 是否支持多线程读写：HashMap、TreeMap、LinkedHashMap线程不安全，只有Hashtable线程安全。 是否有序：HashMap、Hashtable无序，LikedHashMap可以保证数据按照插入顺序排序、TreeMap可以对数据进行排序。 是否允许空值：HashMap、LikedHashMap允许存在一条键为null的记录，Hashtable、TreeMap不允许空值存在。 遍历方式List主要有三种循环方式，for循环、增强for循环和迭代器方式。增强for循环的内部是调用iterator实现的，后两种方式的效果基本相同(在idea中也会有提示建议使用增强for循环的方式)。对于如何选择遍历方式，在RandomAccess接口中有讲到。 //List遍历private static void traverseListTest() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) &#123; arrayList.add(i); &#125; //for循环遍历 for (int i = 0; i &lt; arrayList.size(); i++) &#123; System.out.println(arrayList.get(i)); &#125; //增强for循环 for (Integer integer : arrayList) &#123; System.out.println(integer); &#125; //iterator方式 Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; Map遍历方式，主要的遍历方式有四种，第一中国方式仅仅遍历value或者key的话直接使用一个增强for循环，第二种方式是使用Map.keyset方法遍历key，可以再通过key找到value，第三种是使用Map.entrySet遍历，此方法是效率比较高的一种，第四种是使用Iterator遍历，和上一种方式基本相同，但是如果需要在遍历过程中删除元素的话，需要使用该方法。 //Map遍历private static void traverseMapTest() &#123; Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125; //仅遍历value for (Integer value : map.values()) &#123; System.out.println(value); &#125; //仅遍历key for (Integer key : map.keySet()) &#123; System.out.println(key); &#125; //Map.keySet方法 for (Integer key : map.keySet()) &#123; System.out.println(key + " " + map.get(key)); &#125; //Map.entrySet方法 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue()); &#125; //Iterator方式 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next().getKey() + " " + iterator.next().getValue()); &#125; //lambada map.forEach((key, value) -&gt; System.out.println(key + " " + value));&#125; 性能测试插入了500w条数据进行测试。 遍历方式 时间（ms） KeySet 13 values 42 keySet get(key) 51 entrySet 41 iterator 39 总结 如果只是获取key或者value，推荐使用KeySet和values方式。 同时需要key和value，推荐使用entrySet方式。 如果需要在遍历的过程中删除元素，可以使用iterator方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么输入IP地址无法访问网站]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%93%E5%85%A5IP%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[🌈学习完DNS解析之后，自己尝试写了一个Java程序解析DNS地址的小Demo。 代码： import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Arrays;/** * @paragram: DNSDemo * @description: 域名解析 * @auhor: liuergo * @date: 2019-09-18 15:41 */public class Test &#123; public static void main(String[] args) &#123; Test tester = new Test(); // tester.resolveDomain("www.baidu.com"); tester.resolveDomain("www.zhihu.com"); &#125; private void resolveDomain(String domain) &#123; InetAddress[] address; try &#123; address = InetAddress.getAllByName(domain); Arrays.stream(address) .map(InetAddress::getHostAddress) .forEach(System.out::println); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解析百度的IP地址以后，直接访问百度的IP地址可以正常访问，然而解析知乎的IP地址以后，无法正常访问。 域名可以访问然而IP不能访问，这是为什么呢？ 只输入IP地址无法访问网站的原因​ 输入IP地址无法访问的原因就是多个站点在共用这一个IP，如果只输入IP地址的话，浏览器也不知道要访问哪个站点，所以就无法访问了。 ​ 那么，浏览器不也是解析域名之后再访问的IP地址吗，最终也是访问的IP地址，那么越过DNS解析直接访问和前一种形式不应该一样吗？ ​ 有两种技术可以上面的问题： 虚拟主机技术 反向代理技术 虚拟主机技术 虚拟主机技术是apache，nginx等服务器所特有的一种功能，也就是实现多个站点在同一台服务器上放置。 那么，知乎的某台服务器可能就是下面的样子： 站点 文件存放路径 www.zhihu.com /zhihu/index www.a.com /a/index www.b.com /b/index 这样，域名和文件之间就存在映射关系了，当我们直接访问 www.zhihu.com 时，主要经历了以下几个步骤： DNS域名解析，获得解析后的结果，比如是223.111.243.190。 浏览器与IP为223.111.243.190的服务器进行三次握手，建立TCP连接。 浏览器开始构建HTTP请求报文，通过抓包可以看到报文格式： Hypertext Transfer Protocol GET / HTTP/1.1\r\n Host: www.zhihu.com\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8\r\n Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n Accept-Encoding: gzip, deflate\r\n Connection: keep-alive\r\n Upgrade-Insecure-Requests: 1\r\n \r\n [Full request URI: http://www.zhihu.com/] [HTTP request 1/18] [Response in frame: 121] 以上信息中，我们需要关注一行，就是Host: www.zhihu.com\r\n 这一行，通过这个头部字段，服务器就可以知道 到底访问的是哪个HOST，然后服务器就根据HOST和域名的对应关系，去寻找/zhihu/index文件。 反向代理技术先介绍一下正向代理和反向代理的区别： 正向代理正向代理，是在用户端的。比如需要访问某些国外网站，我们可能需要购买vpn。 并且vpn是在我们的用户浏览器端设置的(并不是在远端的服务器设置)。 浏览器先访问vpn地址，vpn地址转发请求，并最后将请求结果原路返回来。 反向代理有正向代理，就有反向代理。 反向代理是作用在服务器端的，是一个虚拟IP(VIP)。对于用户的一个请求，会转发到多个后端处理器中的一台来处理该具体请求。 大型网站都有DNS(域名解析服务器)，load balance(负载均衡器)等。 下面主要介绍反向代理技术 ​ 在计算机网络中，反向代理是代理服务器的一种。服务器根据客户端的请求，从其关联的一组或多组后端（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在。 在这种情况下，直接访问IP的时候会访问反向代理服务器，这样访问 www.zhihu.com 的时候，过程如下： 通过DNS解析获得 www.zhihu.com 的反向代理IP地址223.111.243.190。 HTTP请求到达反向代理服务器之后，该服务器会对请求做转发。 请求的HOST地址为 www.zhihu.com ，反向代理服务器会将请求报文转发到域名为www.zhihu.com的服务器上。 总结直接使用IP无法访问站点的原因 一个IP可能对应多个web站点，仅仅凭借IP无法找到相应的站点。通过域名访问就可以借助HOST分辨到底是要访问哪个站点。如果使用虚拟主机技术，那么利用HOST + IP的方式就可以访问；如果使用反向代理技术，通过代理服务器找到站点实际服务器的IP也可以访问。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WireShark基本操作]]></title>
    <url>%2F2019%2F09%2F16%2FWireShark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 拦截本地回环数据（需要的时候再开启）机访问本机的回环数据是不经过网卡的，比如我们在本机访问搭建在本机上的web服务，但我们经常有服务搭建在本机的操作也经常有拦截本地回环数据包加以分析的需求，所以我们环要拦载回环数据包。操作如下。 首先，以管理员身份运行cmd（普通用户没有路由表操作权限，会提示“请求的操作需要提升”） 然后，使用ipconfig查看本机ip和网关： ipconfig 再然后，使用以下命令添加路由，指定回环数据也要先转发到网关（使用上一步获取本的本机ip和网关替换其中的和）： route add &lt;your_IP&gt; mask 255.255.255.255 &lt;gateway_IP&gt; metric 1 最后，查看路由表中路由是否已添加成功： route print 回环数据经网关再回来会增加网卡的压力，可使用以下命令删除路由（使用前边获取本的本机ip替换其中的）： route delete &lt;your_IP&gt; 2. WireShark 界面说明 区域1：该区域展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。 区域 2：该区域是区域 1 中选定的数据包的分协议层展示。 区域 3：该区域是区域 1 中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。 2. 捕获过滤器表达式在欢迎页面可以看到管理捕获过滤器。 打开以后，可以看到过滤器的各种写法。 3. 显示过滤器表达式及其书写规律显示过滤器会在WireShark捕获数据包之后，按照过滤表达的条件，有选择性地显示已经捕获的所有数据包。 3.1. 基本过滤表达式一个基本的表达式由过滤项、过滤关系、过滤值三个部分组成。 比如ip.addr == 192.168.1.1这条表达式 ip.addr是过滤项 == 是过滤关系 192.168.1.1是过滤值 表达式的意思为找出所有ip协议中源或目标地址为192.168.1.1的数据包。 3.1.1. 过滤项==过滤项 = 协议 + 协议字段== 以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。 当在应用过滤显示器中输入时，会有相应的提示。 3.1.2. 过滤关系过滤关系可以使用“English”和“C-like”两种方式，例如“==”可以写作“eq”。 3.1.3 过滤值不解释。 ###3.2. 复合规律表达式 English C-like Description Example and &amp;&amp; Logical AND ip.src==10.0.0.5 and tcp.flags.fin or || Logical OR ip.scr==10.0.0.5 or ip.src==192.1.1.1 xor ^^ Logical XOR tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! Logical NOT not llc […] Subsequence See “Slice Operator” below. in Set Membership http.request.method in {&quot;HEAD&quot; &quot;GET&quot;}. See “Membership Operator” below. 3.3. 常见用显示过滤需求及其对应表达式数据链路层： 筛选mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 网络层： 筛选ip地址为192.168.1.1的数据包—-ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据—- ip contains “192.168.1” 筛选192.168.1.1和192.168.1.2之间的数据包—-ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包—-ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2 传输层： 筛选tcp协议的数据包—-tcp 筛选除tcp协议以外的数据包—-!tcp 筛选端口为80的数据包—-tcp.port == 80 筛选12345端口和80端口之间的数据包—-tcp.port == 12345 &amp;&amp; tcp.port == 80 筛选从12345端口到80端口的数据包—-tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80 应用层： 特别说明—-http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包—-http.request.uri contains “.php” 筛选内容包含username的http数据包—-http contains “username”]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
      </tags>
  </entry>
</search>
