<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Security 入门]]></title>
    <url>%2F2020%2F02%2F12%2FSpring%20Security%2F</url>
    <content type="text"><![CDATA[Spring Security 入门介绍通常在开发web应用的时候，需要很多对页面安全的控制，可以通过拦截器、AOP实现，同样也可以使用 Spring Security、Shiro 这种用于用户认证和用户授权的框架做到，Spring Sercurity 就是Spring 全家桶中关于安全方面的一个框架，基于Spring AOP和Servlet过滤器。 主要功能 认证：验证用户名和密码是否合法（是否是系统中的用户）。 授权：为不同的用户授予相应的权限。 防御会话固定，点击劫持，跨站点请求伪造等攻击。 初体验认证 添加starter &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个测试用的controller @Controllerpublic class AppController &#123; @RequestMapping("/hello") @ResponseBody public String hello() &#123; return "hello"; &#125;&#125; 运行项目 可以看到控制台有类似下面的输出，这是一个随机生成的UUID，就是默认的密码，默认的用户名是user 访问localhost:8080/hello，Spring Security 的拦截器会重定向到/login下。 输入用户名和密码之后，就会跳转到/hello页面下了。 此处的用户名和密码可以在application.properties文件中修改，如下： spring.security.user.name=userspring.security.user.password=123 授权我们接下来会创建两个用户，两个用户有不同的权限，根据权限不同，用户可以访问的页面也不同。 创建一个继承WebSecurityConfigurerAdapter的类，重写configure方法 @Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired MyUserDetailsService myUserDetailsService; // 硬编码在内存中的用户 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser("user") .password(new BCryptPasswordEncoder().encode("user")) .roles("USER") .and() .withUser("admin") .password(new BCryptPasswordEncoder().encode("admin")) .roles("ADMIN"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() // 所有用户都可以访问/login接口 .antMatchers("/login").permitAll() // 只有具有ADMIN权限的用户才可以访问/admin下的接口 .antMatchers("/admin/*").hasRole("ADMIN") .antMatchers("/user/*").hasRole("USER") // 对于剩余的接口只要登陆成功就可以登陆 .anyRequest().authenticated() .and() .formLogin().defaultSuccessUrl("/hello"); &#125;&#125; 上面重写了两个configure方法，第一个configure方法可以创建几个硬编码在内存中的用户，注意roles(&quot;USER&quot;)添加的权限默认会加上”ROLE_”。这是spring security的核心配置类。 运行项目，使用user用户登录的时候只可以访问/user下的接口，访问/admin下的接口会报403错误。 源码分析用户参数 首先找到SecurityProperties.java，查看其中的User静态内部类。 public static class User &#123; /** * Default user name. */ private String name = "user"; /** * Password for the default user name. * 默认用户的密码，可以看到，UUID就是在此处生成的 */ private String password = UUID.randomUUID().toString(); /** * Granted roles for the default user name. * 为默认用户授予的角色 */ private List&lt;String&gt; roles = new ArrayList&lt;&gt;(); /** * 是否生成密码 */ private boolean passwordGenerated = true; .....&#125; 用户名密码验证 进入UsernamePasswordAuthenticationFilter类。 可以通过类注释看到，此类的作用是Processes an authentication form submission，处理身份验证提交的表单。 public UsernamePasswordAuthenticationFilter() &#123; super(new AntPathRequestMatcher("/login", "POST"));&#125; 上面是该类的构造器，使用提供的模式和HTTP方法以不区分大小写的方式创建匹配器。 查看该类的抽象父类 AbstractAuthenticationProcessingFilter 中的 public Authentication attemptAuthentication() 方法介绍：Performs actual authentication，此方法就是实际执行身份验证的方法： public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (postOnly &amp;&amp; !request.getMethod().equals("POST")) &#123; throw new AuthenticationServiceException( "Authentication method not supported: " + request.getMethod()); &#125; // 获取请求中参数username和password的内容 String username = obtainUsername(request); String password = obtainPassword(request); // 判空 if (username == null) &#123; username = ""; &#125; if (password == null) &#123; password = ""; &#125; // 去掉username中的空格 username = username.trim(); // 创建一个用于身份认证的Token UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); // Allow subclasses to set the "details" property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest);&#125; 整个身份验证的过程： 请求到达AbstractAuthenticationProcessingFilter的实现类UsernamePasswordAuthenticationFilter过滤器，过滤器将request中的账号密码组合成Authentication的一个实现类UsernamePasswordAuthenticationToken，创建一个用于身份认证的token。 将创建好的token传给AuthenticationManager的authenticate方法，验证token是否有效。 AuthenticationManager验证成功之后，会返回一个Authentication对象，该对象包含了（权限信息、身份信息、细节信息，密码通常会被移除）。 最后通过SecurityContextHolder.getContext().getAuthentication().getPrincipal()将Authentication设置到security context中，一般我们可以通过下面的代码来获取当前登录用户的信息，此信息是储存在HttpSession中的，可以随时拿到。 SecurityContext securityContext = SecurityContextHolder.getContext();Authentication auth = securityContext.getAuthentication(); 自定义登录接口和登录页面上面的例子中我们只使用了内存中的两个用户登录，实际项目中肯定是要从数据库中查询的，下面讲解如何自定义登录接口。 在WebSecurityConfig.java中增加配置： @Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 实现自定义的UserDetailsService接口： @Componentpublic class MyUserDetailsService implements UserDetailsService &#123; @Autowired PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 如果是从数据库中查询密码，将此处的password改成查询之后获得的结果即可 String password = passwordEncoder.encode("123"); return new User(username, password, AuthorityUtils.createAuthorityList("ROLE_ADMIN")); &#125;&#125; 注意，此处的密码需要经过编码器加密后的值，包括上面在内存中定义的两个用户，密码都需要是符合编码器的编码规则的，否则会报错。 启用自定义接口，在MySecurityConfig中，增加userDetailsService(myUserDetailsService)。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.userDetailsService(myUserDetailsService) .authorizeRequests() // 所有用户都可以访问/login接口 .antMatchers("/login").permitAll() // 只有具有ADMIN权限的用户才可以访问/admin下的接口 .antMatchers("/admin/*").hasRole("ADMIN") .antMatchers("/user/*").hasRole("USER") // 对于剩余的接口只要登陆成功就可以登陆 .anyRequest().authenticated() .and() .formLogin().defaultSuccessUrl("/hello");&#125; 自定义登录界面 在templates下创建login.html，注意，接口中的用户名密码的name要和security中的对应，接口名称要和后面要配置的.loginProcessingUrl()对应。 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;登录&lt;/h2&gt;&lt;form action="/auth/login" method="post"&gt; &lt;label&gt; &lt;input name="username" placeholder="username"&gt; &lt;/label&gt; &lt;label&gt; &lt;input name="password" placeholder="password"&gt; &lt;/label&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置WebSecurityConfig 在configure中增加配置，主要是loginPage默认登陆页面配置，loginProcessingUrl登陆请求的url，csrf().disable()关闭csrf。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .userDetailsService(myUserDetailsService) .authorizeRequests() .antMatchers("/login").permitAll() // 注意，此处的roles信息会默认加上ROLE_ .antMatchers("/admin/*").hasRole("ADMIN") .antMatchers("/user/*").hasRole("USER") // 剩余的接口，只要登录成功就可以使用 .anyRequest().authenticated() .and() .formLogin() .defaultSuccessUrl("/hello") .loginPage("/login") .loginProcessingUrl("/auth/login");&#125; 再次运行项目打开，就可以看到自定义的登陆页面了]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解递归]]></title>
    <url>%2F2020%2F02%2F10%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[基本思想写好递归要掌握几个技巧： 1 明确递归函数的作用，将递归函数看作一个黑盒我自己把该技巧称为黑盒思想，我认为黑盒思想对于理解递归有很大的作用，递归函数就是隐藏了很多细节，我们没必要去一步一步地模拟递归函数的运行，那样大脑也受不了。 比如最简单的阶乘函数，我们定义一个函数int Factorial(int n)，规定此函数的作用就是输入一个整数，返回该数的阶乘，我们解题的过程中需要时刻保持这种思想。 2 明确递归结束的条件递归另外一个重要的因素就是要明确递归的结束条件，我们知道，如果递归无法正常终止，最终会导致栈溢出，所以明确递归结束的条件是很重要的，一般我们在找这个条件的时候都要寻找这么一个情况：在该参数下该函数可以返回确切的值，一般我们需要寻找某些简单情况，这些情况下可以直接获取返回值。 例如，还是阶乘的例子，我们知道1的阶乘是1，2的阶乘是2，那么我们就可以得出如果n等于1或者2，就可以直接返回n的值，那么该函数就变成了： int Factorial(int n) &#123; if (n &lt;= 2) return n; ...&#125; 3 缩小递归范围，获得等价条件我觉着这是递归中最难的部分了，说是要确定等价条件，其实有的时候等价条件很好找，但是有些情况下并不是很明显的等价条件，一般我会分为两种问题，一种是可以很容易推导出公式的，这种问题推出公式来问题也就基本解决了，另外一种是寻找缩小递归范围的办法，使递归不断趋近递归结束条件（其实第一种也是为了达到该目的）。这一部分需要不断做题积累总结，同时黑盒思想在此处充分体现出来了。 完善阶乘的例子： 我们知道，阶乘的公式是 $f(n)=n!$，容易得出$f(n-1)=(n-1)!$，$f(n)=n(n-1)!$，那么最终得到的公式就是$f(n)=nf(n-1)$，这里的f(n)就是等价于第一步我们确定的函数Factorial(int n)，那么该函数就变成了： int Factorial(int n) &#123; if (n &lt;= 2) return n; return n * Factorial(n - 1);&#125; 现在的函数就和我们一开始推出的公式是一个意思了，向一个作用为输入一个正整数得到该数的阶乘的函数中输入参数n，根据刚刚得到的公式返回获得的结果，每次计算都会将递归范围减小，直到达到结束条件。 题目整理下面的题目都是在刷剑指offer和LeetCode中遇到的可以用递归求解的几个题目，挑了几个典型的题目，难度在我看来是按照顺序递增的。 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 斐波那契数列的公式是 $f(n) = f(n-1) + f(n-2)$，那么我们只需要确定递归的结束条件。f(0)=0，f(1)=1，f(2)=f(1)+f(0)…所以当n&lt;=1时，输入n返回n，那么我们就可以解出改题目了。 实现： int Fibonacci(int n) &#123; if (n &lt;= 2) return 1; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 这道题目最重要的就是推出公式了，我们可以先试着模拟几次，如果n=1，只有一个台阶，f(1)=1，同样地，f(2)=1。当有三个台阶，即n=3时候，要分两次跳，第一次跳有两种选择1或2，如果第一次选1，那么还剩两节台阶，问题就回到了f(2)，第二次就只有一种跳法；如果第一次选2，那么还剩一节台阶，问题回到f(1)，第二次只有一种跳法，故f(3)=f(2)+f(1)。所以，当跳n级台阶时，第一次有两种跳法，如果第一次选择了1，那么有f(n-1)中跳法；如果第一次选择了2，那么有f(n-2)种跳法，总共有f(n-1)+f(n-2)种跳法，公式为f(n)=f(n-1)+f(n-2)。 结束条件也很明显了，n&lt;=2时，返回n。 实现： int JumpFloor(int target) &#123; if (target &lt;= 2) return target; return JumpFloor(target - 1) + JumpFloor(target - 2);&#125; 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 根据上题容易推出$f(n)=f(n-1)+f(n-2)+…+f(0)$， $f(n-1)=f(n-2)+f(n-3)+…+f(0)$ 两式相减，得$f(n)=2f(n-1)$ 实现： int JumpFloor(int target) &#123; if (target &lt;= 2) return target; return 2 * JumpFloor(target - 1);&#125; 输入一个链表，反转链表后，输出新链表的表头。 对于此题来说，黑盒思想就很重要，首先明确此函数的作用，此函数的作用是输入一个链表的头节点，之后对链表进行反转，返回反转后新链表的头节点。 首先，明确结束条件，同样我们可以将某些简单情况作为结束条件，当head==null或者head.next==null（只有一个节点）时，反转链表的结果就是直接返回head，那么结束递归的条件就是if (head == null || head.next == null) return head;。 最后一步就是寻找等价关系，缩小递归范围，我们知道该函数的返回值是反转之后的新节点，这个新节点就是旧链表的尾节点，要想一步步逼近答案，显然需要一步步向后搜索，递归部分就是reverse(head.next)，先将这一句加进代码中去： Node reverse(Node head) &#123; if (head == null || head.next == null) return head; Node newNode = reverse(head.next); // 暂时不return，先用变量储存&#125; reverse(head.next)的作用即为输入头节点的下一个节点，并且将头节点后面的节点都反转，如下图所示，第二个链表就是执行reverse(head.next)之后的变化。 （可能到这里会有疑问了，我们并没有写任何将链表反转的逻辑，链表不可能自己就反转了，确实，到目前为止没有任何实际代码可以将链表反转，但是递归的一个特点就是省略了细节，而且一定要记住黑盒思想，将递归函数看作黑盒，即使函数看起什么都没有做，也要从心底里面让自己相信它现在就起了这个功能，否则你的大脑就爆栈了💥） 下一步观察上图中第二个链表，此时该链表并没有反转完毕，旧链表的头节点还没有变化，下面我们需要做的就是就要将链表完全反转。让图中2节点的next指针指向1节点，1节点的next指针指向空就可以了，最后我们再将刚刚储存的新链表的头节点返回就可以了。最终的链表就是这样子的： 最后，完整代码如下： Node reverse(Node head) &#123; if (head == null || head.next == null) return head; Node newNode = reverse(head.next); head.next.next = head; head.next = null; return newNode;&#125; 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 关于什么是数的子结构，可以自行百度。 在一开始做这个题的时候，我的想法既然前序序列和中序序列就可以唯一确定一棵二叉树，那么通过分别前序遍历和中序遍历去得到两个数的遍历序列，然而这种方法是行不通的，很容易找出反例，不要用这种方法去判断。 整个算法过程应该是这样的：首先判断两个树的根节点是否相等，如果相等，就继续判断两个树的左孩子、右孩子…否则，直接结束判断对A树的根节点的左孩子执行上面的判断。 此题需要分为两个过程：一个是对A树不断遍历，一个是对AB树的节点进行逐一判断。 首先规定函数boolean HasSubtree(TreeNode root1,TreeNode root2)的作用为输入树A、B的根节点，如果B是A的子结构，返回true，否则返回false。 第二步，确定递归结束条件，题目中提到，约定空树不是任意一个树的子结构，那么可以从这里入手，如果A、B有任何一个为空，直接返回false。实际上，此处的节点为空还包含着另一个语义，就是递归遍历结束，下面也会用到这个条件。现在函数就变成了： boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if (root1 == null || root2 == null) return false;&#125; 最后确定该函数的主体部分，我们先不写出另一个递归判断过程的函数，先将第一个递归函数的架子搭好，在本题中，缩小递归范围的方法就是遍历，放在本题中对二叉树的遍历就是判断完根节点判断左孩子、右孩子，如果根节点通过了判断，就返回true，没有通过，就递归判断左孩子…代码如下（利用了逻辑运算符的短路运算）： boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if (root1 == null || root2 == null) return false; return judge(root1, root2) || HasSubtree(root1.left, root2.left) || HasSubtree(root1.right, root2.right);&#125; 下面就是补全boolean judge(TreeNode root1,TreeNode root2)方法了，该方法的作用实际上是输入两个二叉树AB，只比较根节点，判断B是否是A的为子结构。 首先，确定递归结束条件，因为此处AB树的都不可能为空了，所以第一个递归函数的判断条件就不适用了，由于仍然需要对树进行递归判断，我们可以通过遍历结束时候的情况作为结束条件，很容易得出：如果A树先遍历完毕即root1==null，那么此时应该返回false；如果B树先遍历完毕即root2==null，那么此时应该返回true（实在理解不了画图分析一下）。 下面，补全剩下的部分，如果两个树当前的节点不相等，直接返回false；如果相等，递归判断左子树、右子树，如果都相等，返回true。 完整代码如下 boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if (root1 == null || root2 == null) return false; return judge(root1, root2) || HasSubtree(root1.left, root2.left) || HasSubtree(root1.right, root2.right);&#125;boolean judge(TreeNode root1,TreeNode root2) &#123; if (root2 == null) return true; if (root1 == null) return false; if (root1.val == root2.val) return judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right); else return false;&#125; 理解上面几个题目后，递归差不多就可以入门了，我总结的办法不一定适用于所有的递归题目，不可生搬硬套，多做题，多总结经验和方法。 参考资料： https://www.zhihu.com/question/31412436/answer/683820765 https://zhuanlan.zhihu.com/p/86745433]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2020%2F02%2F09%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树基本数据结构二叉搜索树(Binary Search Tree)是一种特殊的二叉树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。 如果有一组数组：{5, 4, 7, 6, 1, 3, 9}，按照顺序生成一棵二叉搜索树的过程如下： 最后就得到一棵下面的二叉树： 算法插入 插入的算法就是上面建立一棵二叉搜索树的过程，每次插入的时候首先判断需要插入的节点和根节点的大小，如果前者大于后者，并且右孩子不空，就设置为右孩子，右孩子为空需要递归插入，小于的话同理。 根据已有序列创建二叉搜索树 根据已有序列循环插入即可。 搜索 根据要查找的元素从根节点开始搜索，比较搜索的值和节点的值，等于就返回当前节点，搜索的值大于节点的值就递归搜索左子树，否则递归搜索右子树。 所有的算法实现如下： BSTree.java public class BSTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; /** * 根节点 */ private TreeNode&lt;T&gt; root = null; public BSTree(TreeNode&lt;T&gt; root) &#123; this.root = root; &#125; /** * 创建二叉搜索树 * * @param a 需要转换为二叉搜索树的节点 */ public void buildBSTree(List&lt;T&gt; a) &#123; for (T value : a) &#123; createBSTreeNode(root, value); &#125; &#125; /** * 对外暴露的搜索插入方法 * @param val 要插入的数值 */ public void insert(T val) &#123; createBSTreeNode(root, val); &#125; /** * 对外暴露的搜索方法 * @param val 要查找的元素值 * @return 返回 val 所在节点 */ public TreeNode&lt;T&gt; search (T val) &#123; return search(this.root, val); &#125; /** * 创建二叉搜索树节点 */ private void createBSTreeNode(TreeNode&lt;T&gt; treeNode, T val) &#123; if (root == null) &#123; root = new TreeNode&lt;&gt;(val); &#125; else &#123; int result = treeNode.getData().compareTo(val); if (result &lt;= 0) &#123; if (treeNode.getRightNode() == null) &#123; // 如果当前节点右孩子为空，就直接插入 treeNode.setRightNode(new TreeNode&lt;&gt;(val)); &#125; else &#123; // 如果当前节点右孩子不为空，就递归调用创建节点的方法 createBSTreeNode(treeNode.getRightNode(), val); &#125; &#125; else &#123; if (treeNode.getLeftNode() == null) &#123; treeNode.setLeftNode(new TreeNode&lt;&gt;(val)); &#125; else &#123; createBSTreeNode(treeNode.getLeftNode(), val); &#125; &#125; &#125; &#125; /** * 寻找二叉搜索树中的某个元素，返回该元素所在节点 * * @param treeNode 根节点 * @param val 要查找的元素值 * @return 返回 val 所在节点 */ private TreeNode&lt;T&gt; search(TreeNode&lt;T&gt; treeNode, T val) &#123; int result = treeNode.getData().compareTo(val); if (result &lt; 0) &#123; return search(treeNode.getRightNode(), val); &#125; else if (result &gt;0) &#123; return search(treeNode.getLeftNode(), val); &#125; return treeNode; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合拦截器]]></title>
    <url>%2F2020%2F02%2F08%2FSpring%20Boot%E6%95%B4%E5%90%88%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot 整合拦截器Interceptor介绍拦截器（Interceptor）同过滤器（Filter）一样，都是 AOP 的实现，当请求发送到 Controller 时，在被 Controller 处理之前，它必须经过 Interceptors（0或更多）。 关于拦截器和过滤器在框架中的区别： Filter 不依赖于框架，依赖于Servlet容器。使用时需要在注册bean并在在类上加 @Component就可以被spring框架扫描到。 Interceptor 依赖spring框架，是建议优先使用Interceptor，而不是Filter。毕竟框架封装的，接口功能会更丰富一些。 更多关于拦截器和过滤器的区别，可以移步知乎：请教一下关于过滤器，拦截器，监听器具体应用上的区别？ 自定义Interceptor如果需要自定义Interceptor，需要实现 HandlerInterceptor 接口或者继承 HandlerInterceptorAdapter 类，并且重写下面三个方法： default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;&#125;default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;&#125; 上面的 preHandle 方法如果返回 true 意味着请求会继续到达 Controller ，否则不会到达 Controller。 创建自定义 Interceptor MyInterceptor,java 此 Interceptor 过滤所有请求。 @Componentpublic class MyInterceptor implements HandlerInterceptor &#123; private String className = this.getClass().getName(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(className + "::::" + "preHandle\n"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(className + "::::" + "postHandler\n"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(className + "::::" + "afterCompletion\n"); &#125;&#125; OldLoginInterceptor.java 此拦截器的作用是：如果用户输入一个已经废弃的连接”/admin/oldLogin” ，将会重定向到新的”admin/login” @Componentpublic class OldLoginInterceptor implements HandlerInterceptor &#123; private String className = this.getClass().getName(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(className + "::::" + "preHandle"); System.out.println("Request URL: " + request.getRequestURL()); System.out.println("Sorry! This URL is no longer used, Redirect to /admin/login\n"); response.sendRedirect(request.getContextPath() + "/admin/login"); return false; &#125;&#125; AdminInterceptor.java 此拦截器的作用是拦截”/admin/*”下的请求。 @Componentpublic class AdminInterceptor implements HandlerInterceptor &#123; private String className = this.getClass().getName(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(className + "::::" + "preHandle\n"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(className + "::::" + "postHandler\n"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(className + "::::" + "afterCompletion\n"); &#125;&#125; 注册拦截器@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Autowired AdminInterceptor adminInterceptor; @Autowired MyInterceptor myInterceptor; @Autowired OldLoginInterceptor oldLoginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor); registry.addInterceptor(oldLoginInterceptor) .addPathPatterns("/admin/oldLogin"); registry.addInterceptor(adminInterceptor) .addPathPatterns("/admin/*") .excludePathPatterns("admin/oldLogin"); &#125;&#125; 自定义 Controller 验证拦截器@RestControllerpublic class LoginController &#123; @GetMapping("/test") public String test() &#123; System.out.println("Now in Controller\n"); return "test"; &#125; @Deprecated @GetMapping("/admin/oldLogin") public String oldLogin(Model model) &#123; // Code here never run. return "oldLogin"; &#125; @GetMapping("/admin/login") public String login(Model model) &#123; return "login"; &#125;&#125; 测试当访问”/test”时，后台输出如下： top.liuergo.demo.interceptor.MyInterceptor::::preHandleNow in Controllertop.liuergo.demo.interceptor.MyInterceptor::::postHandlertop.liuergo.demo.interceptor.MyInterceptor::::afterCompletion 可以看出，在进入 Controller 之前首先执行拦截器的 preHandler() 方法，如果 preHandler() 方法返回 true ，就会进入 Controller ，当 Controller 执行完毕之后才会进入 postHandler() 方法。 三个方法的作用： preHandle：在 controller 处理请求之前被调用。预处理，可以进行编码、安全控制、权限校验等处理。 postHandle：在controller处理请求执行完成后，生成视图之前执行。 afterCompletion：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。 当访问”/admin/oldLogin”时，后台输出如下： top.liuergo.demo.interceptor.OldLoginInterceptor::::preHandleRequest URL: http://localhost:8080/admin/oldLoginSorry! This URL is no longer used, Redirect to /admin/logintop.liuergo.demo.interceptor.MyInterceptor::::afterCompletiontop.liuergo.demo.interceptor.MyInterceptor::::preHandletop.liuergo.demo.interceptor.AdminInterceptor::::preHandletop.liuergo.demo.interceptor.AdminInterceptor::::postHandlertop.liuergo.demo.interceptor.MyInterceptor::::postHandlertop.liuergo.demo.interceptor.AdminInterceptor::::afterCompletiontop.liuergo.demo.interceptor.MyInterceptor::::afterCompletion]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2020%2F02%2F08%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近在刷算法题，趁着这个机会将数据结构再复习一遍，树这一部分准备按照二叉树-&gt;二叉搜索树-&gt;AVL树-&gt;红黑树的顺序学习。 二叉树二叉树的常用算法树的节点类如下： TreeNode.java public class TreeNode&lt;T&gt; &#123; /** * 右节点 */ private TreeNode&lt;T&gt; rightNode; /** * 左节点 */ private TreeNode&lt;T&gt; leftNode; /** * 数据 */ private T data; public TreeNode(T data) &#123; this.data = data; &#125; // getter and setter&#125; 遍历二叉树的遍历有三种方式：先序遍历、中序遍历、后序遍历。这里的先中后都是指的根节点在遍历中的顺序，对于左右孩子的顺序都是先左后右，先序遍历就是按照根-&gt;左-&gt;右的顺序，中序遍历就是按照左-&gt;中-&gt;右的顺序，后序遍历就是左-&gt;右-&gt;中的顺序。 如果有下面的一棵二叉树，下面分别使用递归和非递归方式遍历这棵树。 递归方式 使用递归方式遍历就非常简单了，如果递归理解不了可以多做一些递归的题目练习。 先序遍历 public void preorderTraversal(TreeNode&lt;?&gt; root) &#123; if (root != null) &#123; System.out.print(root.getData()); preorderTraversal(root.getLeftNode()); preorderTraversal(root.getRightNode()); &#125;&#125; 非递归方式(层次遍历) 非递归方式相对于递归方式来说就稍微有些麻烦了，需要用到队列先进先出的性质。 创建一个队列将根节点入队。 将队首的节点出队，每次出队一个节点，就将其左孩子和右孩子入队(如果存在的话)。 重复上述操作，直到队列为空，就遍历完了所有的元素。 还是以上面的二叉树为例，层次遍历的过程如下 代码如下： public static &lt;T&gt; ArrayList&lt;T&gt; levelTraversal(TreeNode&lt;T&gt; root) &#123; ArrayList&lt;T&gt; resultList = new ArrayList&lt;&gt;(); if (root == null) return resultList; Queue&lt;TreeNode&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode&lt;T&gt; treeNode = queue.poll(); resultList.add(treeNode.getData()); if (treeNode.getLeftNode() != null) queue.add(treeNode.getLeftNode()); if (treeNode.getRightNode() != null) queue.add(treeNode.getRightNode()); &#125; return resultList;&#125; 其他算法计算树的深度 该算法也是使用递归的方式，需要比较左子树和右子树的深度，大的才是数的深度。 public static &lt;T&gt; int getDepth(TreeNode&lt;T&gt; root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int leftDepth = getDepth(root.getLeftNode()); int rightDepth = getDepth(root.getRightNode()); return Math.max(leftDepth, rightDepth) + 1; &#125;&#125; 测试 编写一个测试类，这里使用的是JUnit 5。 public class BTreeTest &#123; private TreeNode&lt;String&gt; root = new TreeNode&lt;String&gt;("A"); @BeforeEach public void init() &#123; TreeNode&lt;String&gt; node1 = new TreeNode&lt;String&gt;("B"); TreeNode&lt;String&gt; node2 = new TreeNode&lt;String&gt;("C"); TreeNode&lt;String&gt; node3 = new TreeNode&lt;String&gt;("D"); TreeNode&lt;String&gt; node4 = new TreeNode&lt;String&gt;("E"); TreeNode&lt;String&gt; node5 = new TreeNode&lt;String&gt;("F"); TreeNode&lt;String&gt; node6 = new TreeNode&lt;String&gt;("G"); TreeNode&lt;String&gt; node7 = new TreeNode&lt;String&gt;("V"); root.setChildren(node1, node2); node1.setChildren(node3, node4); node2.setChildren(node5, node6); node6.setRightNode(node7); &#125; @Test public void traversal() &#123; System.out.print("前序遍历::"); BTreeUtils.preorderTraversal(root); System.out.println(); System.out.print("中序遍历::"); BTreeUtils.inorderTraversal(root); System.out.println(); System.out.print("后序遍历::"); BTreeUtils.postorderTraversal(root); System.out.println(); System.out.print("层次遍历::"); System.out.println(BTreeUtils.levelTraversal(root)); &#125;&#125; 测试结果如下： 总结在二叉树中，最重要的一个思想就是递归，鲁迅说过：“人理解迭代，神理解递归”(鲁迅：我没说过)，递归虽难理解，但是是很重要的一种思想，等多刷些题目之后，会再对递归做一个全面的总结。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Graphviz优雅地绘制二叉树]]></title>
    <url>%2F2020%2F02%2F08%2F%E4%BD%BF%E7%94%A8Graphviz%E4%BC%98%E9%9B%85%E5%9C%B0%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[使用Graphviz优雅地绘制二叉树本文重点讲述使用Graphviz绘制二叉树的最佳姿势z 安装Graphviz Windows：https://graphviz.gitlab.io/_pages/Download/Download_windows.html Linux：sudo apt-get install graphviz 除此之外，还需要VSCode，没有安装的可以自行去官网下载。 配置 VSCode在VSCode可以下载一个Graphviz即时渲染的工具，使用起来更加方便。 1 安装插件 安装插件Graphviz Preview和Graphviz (dot) language support for Visual Studio Code，第二个是针对.dot文件的高亮插件。 2 配置settings.json Ctrl + Shift + p 打开输入Open Settings，打开settings.json文件，加入&quot;graphvizPreview.dotPath&quot;:&quot;...(你的Graphviz安装路径)\\bin\\dot.exe&quot;，VSCode的配置就完成了。 编写dot文件此处只给出一个简单的例子，网上有很多语法讲解，本身Graphviz的语法也不难，有需要的可以自行学习 graph binary_tree&#123; node[shape=circle]; A -- B A -- C B -- D B -- E C -- F C -- G&#125; 编辑完成后在VSCode中打开，使用搜索graphviz快捷键Ctrl + K, V。就可以看到下面的预览，对dot文件的修改会即时渲染。点击右上角的Export可以直接导出文件。 美化二叉树可以看到，上面画出的二叉树还是很丑，网上有个大佬写的脚本可以将graphviz生成的二叉树变得更漂亮。 将下面的内容保存为binarytree.gvpr。 // from Emden Gansner// https://mailman.research.att.com/pipermail/graphviz-interest/2010q2/007101.html// requires GraphViz 2.28.0 (fails with 2.26.3 at least)BEGIN &#123; double tw[node_t]; // width of tree rooted at node double nw[node_t]; // width of node double xoff[node_t]; // x offset of root from left side of its tree double sp = 36; // extra space between left and right subtrees double wd, w, w1, w2; double x, y, z; edge_t e1, e2; node_t n;&#125;BEG_G &#123; $.bb = &quot;&quot;; $tvtype=TV_postfwd; // visit root after all children visited&#125;N &#123; sscanf ($.width, &quot;%f&quot;, &amp;w); w *= 72; // convert inches to points nw[$] = w; if ($.outdegree == 0) &#123; tw[$] = w; xoff[$] = w/2.0; &#125; else if ($.outdegree == 1) &#123; e1 = fstout($); w1 = tw[e1.head]; tw[$] = w1 + (sp+w)/2.0; if (e1.side == &quot;left&quot;) xoff[$] = tw[$] - w/2.0; else xoff[$] = w/2.0; &#125; else &#123; e1 = fstout($); w1 = tw[e1.head]; e2 = nxtout(e1); w2 = tw[e2.head]; wd = w1 + w2 + sp; if (w &gt; wd) wd = w; tw[$] = wd; xoff[$] = w1 + sp/2.0; &#125;&#125;BEG_G &#123; $tvtype=TV_fwd; // visit root first, then children&#125;N &#123; if ($.indegree == 0) &#123; sscanf ($.pos, &quot;%f,%f&quot;, &amp;x, &amp;y); $.pos = sprintf(&quot;0,%f&quot;, y); &#125; if ($.outdegree == 0) return; sscanf ($.pos, &quot;%f,%f&quot;, &amp;x, &amp;y); wd = tw[$]; e1 = fstout($); n = e1.head; sscanf (n.pos, &quot;%f,%f&quot;, &amp;z, &amp;y); if ($.outdegree == 1) &#123; if (e1.side == &quot;left&quot;) n.pos = sprintf(&quot;%f,%f&quot;, x - tw[n] - sp/2.0 + xoff[n], y); else n.pos = sprintf(&quot;%f,%f&quot;, x + sp/2.0 + xoff[n], y); &#125; else &#123; n.pos = sprintf(&quot;%f,%f&quot;, x - tw[n] - sp/2.0 + xoff[n], y); e2 = nxtout(e1); n = e2.head; sscanf (n.pos, &quot;%f,%f&quot;, &amp;z, &amp;y); n.pos = sprintf(&quot;%f,%f&quot;, x + sp/2.0 + xoff[n], y); &#125;&#125; 这样，在生成二叉树的时候，使用下面的命令就可以生成一个比较漂亮的二叉树了 dot test.dot | gvpr -c -f binarytree.gvpr | neato -n -Tpng -o tree.png 总结所以最舒服的姿势就是在VSCode中直接编辑dot文件，可以即时预览树的结构和基本形状，需要输出的时候直接使用VSCode集成的终端（在这里我使用的是wsl）生成图片，建议创建一个专门的文件夹作为工作区，并把脚本文件就放在该文件夹下，更加方便绘制。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Graphviz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合过滤器]]></title>
    <url>%2F2020%2F02%2F07%2FSpring%20Boot%E6%95%B4%E5%90%88%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot整合过滤器Filter的概念就不多介绍了，Filter 过滤器是面向切面编程——AOP 的具体实现。 Filter 使用实现一个过滤器只需要实现 Filter 接口，重写三个方法就可以。 @Componentpublic class MyFilter implements Filter &#123; // 初始化过滤器时的操作 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; // 对请求进行过滤 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; &#125; // 过滤器销毁之后的操作 @Override public void destroy() &#123; &#125;&#125; 自定义Filter在 Spring Boot 中实现一个过滤器，有下面两种方式。 1. 手动注册配置实现 Filter 接口，并重写其中的三个方法。 @Componentpublic class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("初始化过滤器：" + filterConfig.getFilterName()); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("过滤器开始对请求进行预处理"); HttpServletRequest request = (HttpServletRequest) servletRequest; String requestUri = request.getRequestURI(); System.out.println("请求的接口为：" + requestUri); long startTime = System.currentTimeMillis(); //通过 doFilter 方法实现过滤功能 filterChain.doFilter(servletRequest, servletResponse); // 上面的 doFilter 方法执行结束后用户的请求已经返回 long endTime = System.currentTimeMillis(); System.out.println("该用户的请求已经处理完毕，请求花费的时间为：" + (endTime - startTime)); &#125; @Override public void destroy() &#123; System.out.println("销毁过滤器"); &#125;&#125; 在配置类中注册自定义的过滤器 @Configurationpublic class MyFilterConfig &#123; @Autowired MyFilter myFilter; @Bean public FilterRegistrationBean&lt;MyFilter&gt; myFilterFilterRegistrationBean() &#123; FilterRegistrationBean&lt;MyFilter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(); filterRegistrationBean.setFilter(myFilter); filterRegistrationBean.setUrlPatterns(new ArrayList&lt;&gt;(Collections.singletonList("/api/*"))); return filterRegistrationBean; &#125;&#125; 2. 使用 @WebFilter 注解@WebFilter(filterName = "MyFilterWithAnnotation", urlPatterns = "/api/*")public class MyFilterWithAnnotation implements Filter &#123; ...&#125; 此外，还需要在 Spring Boot 的启动类中添加 @ServletComponentScan 注解。 自定义 Controller 验证过滤器@RestController@RequestMapping("/api")public class MyController &#123; @GetMapping("/hello") public String hello() &#123; return "hello"; &#125;&#125; 控制台的输出：]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA连表查询和分页]]></title>
    <url>%2F2020%2F02%2F06%2FJPA%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[此节是在Spring Data JPA学习的基础上写的 相关实体类 Person.java /** * @author LiuZhongYue * @date 2020/02/06 */@Data@Entity@Builder(toBuilder = true)@AllArgsConstructor@NoArgsConstructorpublic class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column(unique = true) private String name; private int age; private Long companyId; private Long schoolId; public Person(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; Company.java /** * 公司类 * * @author LiuZhongYue * @date 2020/02/06 */@Data@Entity@NoArgsConstructorpublic class Company &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(unique = true) private String companyName; private String description; public Company(String companyName, String description) &#123; this.companyName = companyName; this.description = description; &#125;&#125; School.java /** * 学校类 * * @author LiuZhongYue * @date 2020/02/06 */@Data@Entity@NoArgsConstructorpublic class School &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(unique = true) private String schoolName; private String description; public School(String schoolName, String description) &#123; this.schoolName = schoolName; this.description = description; &#125;&#125; 多表联查实现 首先建立一个UserDTO用来储存联查后的结果。 UserDTO.java /** * @author LiuZhongYue * @date 2020/02/06 */@Data@NoArgsConstructor@AllArgsConstructor@Builder(toBuilder = true)public class UserDTO &#123; private String name; private int age; private String companyName; private String schoolName;&#125; 在PersonRepository接口中增加下面的方法 @Query("select new top.liuergo.demo.DTO.UserDTO" + "(p.name, p.age, c.companyName, s.schoolName) " + "from Person p " + "left join Company c on p.companyId = c.id " + "left join School s on p.schoolId = s.id " + "where p.id = :id")Optional&lt;UserDTO&gt; findUserInformation(@Param("id") Long personId); 上面的 sql 语句中有两个需要注意的点： select 后面 new 了一个 UserDTO 对象，直接将 sql 返回的数据映射到一个新的 UserDTO 对象上。 注意 left join 的使用，这样如果一个用户没有设置 compnayId 或者 schoolId，也会返回相应的结果，注意根据业务使用不同的连接方法。 分页实现@Query(value = "select new top.liuergo.demo.DTO.UserDTO" + "(p.name, p.age, c.companyName, s.schoolName) " + "from Person p " + "left join Company c on p.companyId = c.id " + "left join School s on p.schoolId = s.id ", countQuery = "select count(p.id) " + "from Person p " + "left join Company c on p.companyId = c.id " + "left join School s on p.schoolId = s.id")Page&lt;UserDTO&gt; getUserInformationList(Pageable pageable); 为了实现分页，需要设置一个Pageable参数，对于其中的countQuery属性，源码中是这样解释的： Defines a special count query that shall be used for pagination queries to lookup the total number of elements for a page. If non is configured we will derive the count query from the original query or {@link #countProjection()} query if any. 大体意思就是说这是一个可能被分页查询用到的特殊的 sql 语句，其作用是为了查询每个页面的元素总数，如果你不设置这个属性JPA会直接从原始的 sql 中自动获取。 分页使用： PageRequest pageRequest = PageRequest.of(2, 10, Sort.Direction.DESC, "age");Page&lt;UserDTO&gt; result = personRepository.getUserInformationList(pageRequest);System.out.println("总页数：" + result.getTotalPages());System.out.println(result.getContent());]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 学习]]></title>
    <url>%2F2020%2F02%2F05%2FSpring%20Data%20JPA%2F</url>
    <content type="text"><![CDATA[官方文档： https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference JPA，Java Persistence API（Java持久层API）的简称。 相关依赖&lt;!--这里使用mysql数据库--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据库连接信息和JPA# mysql数据库连接相关配置spring.datasource.url=jdbc:mysql://localhost:3306/springboot_jpa?useSSL=false&amp;serverTimezone=CTTspring.datasource.username=rootspring.datasource.password=123456# 打印出 sql 语句spring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=createspring.jpa.open-in-view=false# 创建的表的 ENGINE 为 InnoDBspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL55Dialect spring.jpa.hibernate.ddl-auto选项有四个常用的属性： create:每次重新启动项目都会重新创新表结构，会导致数据丢失 create-drop:每次启动项目创建表结构，关闭项目删除表结构 update:每次启动项目会更新表结构 validate:验证表结构，不对数据库进行任何更改 注：在生产环境不要使用 ddl 自动生成表结构。 创建实体类package top.liuergo.demo.entity;import lombok.Data;import lombok.NoArgsConstructor;import javax.persistence.*;/** * @author LiuZhongYue * @date 2020/02/06 */@Data@Entity@NoArgsConstructorpublic class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column(unique = true) private String name; @Column private int age; public Person(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; @Entity：表示该类是数据库持久化类。 @Id：指明某字段为主键id @GeneratedValue(strategy = GenerationType.IDENTITY)：配置自动增长的主键 此时运行项目如果可以看到控制台打印出了建表的DDL就说明上面的步骤没有问题。 Hibernate: drop table if exists personHibernate: create table person ( id bigint not null auto_increment, age integer, name varchar(255), primary key (id)) engine=InnoDBHibernate: alter table person add constraint UK_p0wr4vfyr2lyifm8avi67mqw5 unique (name) 实现操作数据库的 Repository 接口@Repositorypublic interface PersonRepository extends JpaRepository&lt;Person, Long&gt; &#123;&#125; JpaRepository接口继承了PagingAndSortingRepository&lt;T, ID&gt;、QueryByExampleExecutor&lt;T&gt;接口，只要继承了JpaRepository接口，就可以使用基本的增删查改、分页查询等等。 简单CRUD首先编写一个测试类进行测试 @SpringBootTest(classes = DemoApplication.class)@RunWith(SpringRunner.class)@TestPropertySource(locations = &#123;"classpath:application.properties"&#125;)public class DemoApplicationTests &#123; @Autowired PersonRepository personRepository; @Test public void jpaTest() &#123; &#125;&#125; 保存用户信息到数据库 Person person = new Person("Jack", 22);personRepository.save(person); 该方法所对应的 sql 语句就是insert into person (age, name) values (?, ?)，在控制台也可以看到打印。 根据 id 查找用户 Optional&lt;Person&gt; personOptional = personRepository.findById(id);personOptional.ifPresent(value -&gt; System.out.println(value.getName())); 上述方法就可以打印出相应 id 的 name，findById()方法返回的是Optional类型的对象，通过get()方法就可以取得相应的Person对象，但是注意要使用ifPresent()方法对其进行判空，否则如果findById()方法没有找到相应的对象信息就会抛出NoSuchElementException异常，如果不想抛出异常就要使用ifPresent()方法，建议配合lambada表达式进行书写。 根据 id 删除用户 personRepository.deleteById(id); 对应的 sql 语句：delete from person where id=? 更新用户 更新操作也是通过save()方法实现的 Person person = new Person("Jack", 12);personRepository.save(person);// 更新person的name字段person.setName("JJJJack");personRepository.save(person); 自定义 SQL 语句 根据 name 查找 Person @Query("select p from Person p where p.name = :name")Optional&lt;Person&gt; findByName(@Param("name") String name); 根据 id 更新 name @Modifying@Transactional@Query("update Person p set p.name = :name where p.id = :id")void updateNameById(@Param("name") String name, @Param("id") Long id); 注意一定要加上@Modifying和@Transcational注释，否则会报Not supported for DML operations的错误，因为JPA要求，”没有事务支持，不能执行更新和删除操作“，增删改查除了查都是事务级别的，都需要加上@Transcationa注释，注意该注释应该加载Service层，此处没有Service层，所以直接加在了dao层。 注意事项以及踩坑 注意Optional类的使用，主要是ifPresent()和get()方法的配合使用，之后会专门对该类进行总结。 注意@Transcational注释的使用，增删改都需要事务的支持。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令整理]]></title>
    <url>%2F2020%2F02%2F04%2Fgit%E5%91%BD%E4%BB%A4%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[git 官方指南：https://git-scm.com/book/zh/v2/ 配置命令1. 查看配置信息# 查看所有配置git config --list# 查看用户名git config user.name# 查看邮箱git config user.email 2. 全局配置用户名和邮箱# 全局配置用户名git config --global user.name "username"# 全局配置邮箱git config --global user.email "xxx@xxx.com" 基本命令1. 查看状态# 查看当前文件状态git status# 作用同上，输出信息更加简短git status -s 2. 跟踪文件# 跟踪文件，将文件储存在暂存区git add README.MD# 跟踪所有文件(一般不要用)git add . 3. 提交文件# 启动文本编辑器以便输入本次提交的说明git commit# 直接将本次提交说明写在-m之后(此方法使用的比较多)git commit -m "added new benchmarks"# 把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤git commit -a -m "added new benchmarks" 4. 查看提交历史git log# 仅显示最近的 n 条提交git log -(n) 5. 撤销操作# 取消暂存的文件git reset HEAD &lt;file&gt;、# 撤销对某个文件的修改git checkout -- README.MD 6. 版本回退# 版本回退，回退到上一个版本git reset --hard HEAD^# 版本回退，id为版本号或者操作号git reset --hart &lt;id&gt;# 查看操作记录git reflog SSH公钥# 生成SSH公钥，默认储存在~/.ssh目录下ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# 检验公钥是否配置成功ssh -T git@github.com 版本问题分支1. 查看分支# 查看本地分支git branch# 查看远程分支git branch -r# 查看所有分支git branch -a 2. 分支操作# 创建分支developgit branch develop# 删除分支developgit branch -d develop# 切换分支git checkout develop# 创建并切换到develop分支# 等价于 git branch develop + git checkout developgit checkout -b devlop# 合并分支git merge develog# 将分支 develop 推送到远程git push origin develop# 删除远程分支developgit push origin --delete develop]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh基本配置以及操作]]></title>
    <url>%2F2020%2F02%2F01%2Fzsh%2F</url>
    <content type="text"><![CDATA[自从电脑上安装wsl以后，对zsh的折腾就一发不可收拾，不可否认zsh确实可以很有效地提高我们的工作效率，在此记录一下一些基本配置以及操作供自己查阅。 安装 安装zsh sudo apt-get install zsh 配置默认Shell chsh -s /bin/zsh 安装oh-my-zsh sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 配置主题 编辑 oh-my-zsh 配置文件 vim ~/.zshrc 修改主题 修改ZSH_THEME=&quot;ys&quot;，自带的主题都可以在~/.oh-my-zsh/themes文件夹下找到。 使配置生效 source ~/.zshrc 安装插件 以安装语法高亮插件为例 在~/.oh-my-zsh/plugins目录下克隆插件。 cd ~/.oh-my-zsh/plugins &amp;&amp; git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 编辑 oh-my-zsh 配置文件 vim ~/.zshrc 修改其中的plugins字段，zsh默认只有一个 git 插件，将刚刚下载的zsh-syntax-highlighting添加进去。 plugins=( git zsh-syntax-highlighting) 使配置生效 source ~/.zshrc zsh会自带很多插件，所有自带的插件都可以在~/.oh-my-zsh/plugins文件夹下找到，部分插件直接在.zshrc文件中添加相应的名称即可 快捷键在zsh中有很多比较方便的快捷键，此处整理几个自己经常用到的： [Ctrl] + [U]：删除整行 [Ctrl] + [W]：删除光标之前的字母 [Ctrl] + [L]：清屏 [Ctrl] + [R]：搜索历史输入 [Ctrl] + [A]：将光标移动行首 [Ctrl] + [E]：将光标移动行尾 插件推荐git此插件是git默认开启的，主要是使用一些alias，可以在~/.oh-my-zsh/plugins/git/git.plugin.zsh文件中查看到这些alias。 zsh-autosuggestions此插件会记录你之前输入过的所有命令，并自动匹配你可能想要输入命令，按→就可以补全命令 aoutojump实现目录之间的快速跳转，j + 目录名就可以直接进入那个目录不用再频繁地使用cd进入了。 sudo忘记加sudo了？安装这个插件之后双击ESC就会给你自动加上。]]></content>
      <categories>
        <category>zsh</category>
      </categories>
      <tags>
        <tag>-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实现热部署]]></title>
    <url>%2F2020%2F02%2F01%2FSpring%20Boot%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[使用spring-boot-devtools实现简单的热部署 热部署指的是在我们调试程序的时候无需每次都重新启动项目，就可以更新程序，特别是项目比较大，每次重新运行都需要耗费大量时间的时候，使用热部署可以很有效地节省时间。 添加依赖 Maven &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 更改配置 打开Settings-&gt;Compiler，勾选 Build project automatically。 快捷键Ctrl+Shift+Alt+/，选择Registry 勾选 compiler.automake.allow.when.app.running]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux知识回顾]]></title>
    <url>%2F2020%2F01%2F20%2FLinux%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[文件系统 一切皆文件，在Linux系统中，所有被操作系统管理的资源，例如网卡、IO设备等都被看做是一个文件 文件类型和目录结构Linux支持五种文件类型： 文件类型 描述 示例 普通文件 在存储设备上存储信息和数据 源程序代码、可执行文件、图片、音频等 目录文件 表示和管理系统中的文件 /root、/dev 链接文件 不同目录下文件的共享(可类比Windows中的快捷方式) 设备文件 用来访问设备文件 Linux下访问网卡、IO设备等 命名管道(FIFO) 一种特殊类型的文件，Linux系统下进程之间的通讯可以通过该文件进行 Linux文件目录说明 /bin： 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里； /etc： 存放系统管理和配置文件； /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示； /usr ： 用于存放系统应用程序比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录； /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里； /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息； /root： 超级用户（系统管理员）的主目录； /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等； /dev： 用于存放设备文件； /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统； /boot： 存放用于系统引导时使用的各种文件； /lib ： 存放着和系统运行相关的库文件 ； /tmp： 用于存放各种临时文件，是公用的临时文件存储点； /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等； /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。 Linux基本命令Linux命令大全：http://man.linuxde.net/ 目录切换命令 cd：切换到某个目录。 cd ..：切换到上一层目录。 cd /：切换到根目录。 cd ~：切换到用户主目录，相当于cd /home/username或者cd /root。 cd -：返回进入此目录之前所在的目录。 cd !$：把上个命令的参数作为cd参数使用。 目录操作 mkdir 目录名称：添加一个目录。 ls 目录名称：查看目录信息。 ls -l 或者 ll： 查看目录详细信息。 ls -a：显示目录所有信息(包括隐藏文件)。 find 目录名称 参数：寻找某个目录。 示例： find .：列出当前目录及子目录下所有文件和文件夹 find /usr -name &quot;*.txt&quot;：在/usr目录下查找所有扩展名为”.txt”的文件。 find /usr -iname &quot;*.txt&quot;：同上，但是忽略大小写。 find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;：在当前目录下查找所有以.txt和.pdf结尾的文件。 文件操作 touch 文件名称：创建文件。 cat/more/less/tail：查看文件内容。 cat：查看文件全部内容。 more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看。 less：可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看。 tail-10 ：查看文件的后10行，Ctrl+C结束。 注：命令 tail -f可以对某个文件进行动态监控，例如某些日志文件会随着程序的变化而变化，使用tail -f xxx.log就可以监控文件的变化。 权限命令在任意一个目录下执行ll命令： 重点关注框出来的部分：drwxr-xr-x，包括文件类型和权限说明两部分，权限说明中分为3*3三组文件有所有者、所在组、其它组，每组权限又分为读（readable）、写（writable）、执行（executable）。 文件类型： d：代表目录 -：代表文件 l：代表软链接 权限类型： r：可读权限，可以用数字4表示。 w：可写权限，可以用数字2表示。 x：可执行权限，可以用数字1表示。 -：不具有任何权限，可以用数字0表示。 三组权限分别为对应文件所有者、所在组、其他组 文件所有者 一般为文件的创建者谁创建文件谁就是文件所有者，使用ll命令出现的信息的第三列即为该文件的所有者，可以使用chown来修改文件所有者。 文件所在组 当前文件所在的用户组，当某个文件被创建之后，创建该文件的用户所在组就成了该文件的文件所在组。可以使用chgrp命令来修改文件所在组。 其他组 除了文件所有者和文件所在组之外的用户都属于其他组。 修改文件权限的命令：chmod 示例：修改文件abc.txt的属主权限为所有权限，属组权限为可读可写，其他组权限为只读。有下面两种表示方法： chmod 764 abc.txt chmod u=rwx,g=rw,o=r 如果为该文件添加权限可以使用： chmod u+rwx,g+rw,o+r 需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。 其他命令 ps -aux / ps-ef：一般使用这两个命令查询当前进程 grep 要搜索的字符串 要搜索的文件：搜索命令，经常配合其他命令使用比如查找tomcat进程，可以使用ps -aux | grep tomcat，该命令由一个管道符|连接两个命令，管道符的作用是讲上一个命令的结果作为下一个命令的参数使用，此命令的含义就是先查找出所有的进程，之后再将查找出的信息作为grep命令的参数，搜索其中的tomcat字符，返回搜索结果。也可以使用pgrep tomcat查找。 kill -9：杀死某进程（-9表示强制），使用的时候会结合上面的命令先查出某进程的PID，再将其杀死。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2020%2F01%2F15%2F%E8%AE%A1%E7%BD%91%E2%80%94HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 协议报文解析HTTP报文大致可分为报文首部和报文主体两部分，两者由一个空行划分。通常，不一定要有报文主体（GET方法就没有报文主体）。 请求行：包含用于请求的方法，请求的URI和HTTP版本。 状态行：包含表明响应结果的状态码，状态短语和HTTP版本。 首部字段：包含表示请求和响应的各种条件和属性的各类首部。 报文主体：应被发送的数据。 实验验证 输入URL: http://gaia.cs.umass.edu/ethereal-labs/HTTP-ethereal-file3.html ，使用WireShark抓包。 输入过滤表达式tcp &amp;&amp; ip.addr==128.119.245.12 观察抓到的数据包 重点关注下面这一部分 352号包 这个包就是客户端发送给服务端HTTPGET请求，由请求行、各种首部字段和空行组成，在GET请求中，没有请求的报文主体部分。 384号包 在TCP协议中，发送双方每发出一个包都要有响应，此包就是服务端对刚刚发送的HTTP的GET包的响应。 386、387、389、390号包 首先，介绍一下WireShark中TCP segment of a ressembled PDU的概念，在TCP协议中，会将一个较大的数据包分成很多个小包发出去，在WireShark中，TCP segment of a ressembled PDU就是被TCP协议所分成的一个个小的数据包。 其实，这四个包都是TCP分成的小包，WireShark在最后一个http包中将所有的包都进行了重新拼包。 查看386号数据包 点击TCP segment data，查看此segment的数据内容，发现其中的数据就是http报文，只不过是服务器返回的http长报文的一部分。 查看390号数据包 打开4 Reassembled TCP Segments，可以看到所有被TCP所分成的四个小数据包，正是386，387，389，390号包。 查看HTTP数据包的内容 此数据包是服务端返回的HTTP报文，由状态行、首部字段、报文主体和空行组成。通过Line-based text data可以查看具体的报文主体部分的数据。 HTTP方法GET：获取资源GET方法用于从服务器端获取数据，包括静态资源(HTML、CSS、JS、Image等等)。 POST：传输实体的主体POST方法用于向服务器提交数据，比如增删改数据，提交一个表单新建一个用户、或修改一个用户等。 GET主要目的，获取资源；POST主要目的，发送数据对指定资源做处理。 GET和POST到底有什么区别？ PUT：传输文件向服务端增加某个资源文件。 ##DELETE：删除文件 删除指定的资源文件。 在RESTful风格的接口中，PUT、DELETE、GET、POST分别对应对资源的增删查改。 状态码分类 分类 描述 1XX 信息，服务器收到请求，需要请求者继续执行操作 2XX 成功，操作被成功接收并处理 3XX 重定向，需要进一步的操作以完成请求(除304) 4XX 客户端错误，请求包含语法错误或无法完成请求 5XX 服务器错误，服务器在处理请求的过程中发生了错误 2XX成功200 OK表示从客户端发来的请求在服务端被正常处理了，请求资源成功。 3XX重定向301 Moved Permanently永久重定向。表示请求的资源已经被永久地转移到了某个新的URI。 例如http协议重定向至https协议。 302 Found临时重定向。表示请求的资源是临时被分配到一个新的URI中。 304 Not Modified表示服务器端资源未发生改变，可以直接使用服务器缓存。 4XX403 Forbidden资源访问被拒绝。一般没有响应的权限的话会返回该状态码。 404 Not Found服务器上无法找到请求的资源。 5XX500 Internal Server Error服务端出BUG。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—ARP协议]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%A1%E7%BD%91%E2%80%94ARP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[为什么需要ARP协议？无论是主机到主机的通信，还是主机到路由器的通信，实质都是网卡之间的数据传递。为了传输成功，需要在已知IP地址的前提下获取目的网卡地址，这就是ARP(Address Resolution Protocol)协议所做的事情，获得某个IP的MAC地址。 ARP表在每个IP节点(主机或路由器)的每个接口都有一个ARP模块，内有一个缓存表，这就是ARP表。在ARP表中记录了局域网内的一些节点的IP/MAC的映射关系。 Windows下，输入arp -a命令查看ARP缓存表： ARP表中的每一条映射记录都有动态和静态之分，静态类型设定之后就不会变化了，而动态的记录会在超过TTL后过期删除，实时更新。 ARP表具备自学习的能力。 地址解析的过程 查表：发送方A查找ARP表，如果查询到了IP所对应的MAC则结束，如果没有查到，进行第二步。 询问：以广播的形式(目的MAC地址为ff:ff:ff:ff:ff:ff)向LAN中的所有节点发送ARP请求包，询问拥有目的IP的主机的MAC。 学习：所有收到ARP请求包的主机都会将主机A的IP和MAC的映射关系存到自己的ARP表中。 应答：拥有目的IP的MAC的主机会返回主机A一个应答包，告知主机A目的IP的MAC。 保存：发送方A得到目的IP的MAC后，将其存入ARP表中。 报文格式 硬件类型：发送方物理网络类型，1代表以太网。 协议类型：发送方请求解析的协议地址类型， 0x0800代表IP协议。 操作类型：1—ARP 请求；2—ARP 响应。 发送者硬件地址：6 Bytes 发送者IP地址：4 Bytes 目的硬件地址：6 Bytes 目的IP地址：4 Bytes ARP请求或响应报文是被组装在以太网帧中被传输的。 关于ARP协议属于哪一层的问题，众说纷纭。在教材上是把ARP协议划到网络层的，是因为ARP协议属于TCP/IP协议簇中的一员。如果按照OSI的标准，数据在传递时每层会加上自己的信息。当网络层的IP包进入链路层时，链路层通过ARP协议添加链路信息，而这不是网络层的功能，所以也有很多人说ARP是链路层的。 可以这样认为，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。（PS:考试的时候考到是网络层就完事了） 抓包询问 以太网帧中的目的MAC地址为ff:ff:ff:ff:ff:ff，协议类型为ARP(0x0806)，再看ARP协议报文，由于目前并不知道目的IP的MAC地址，所以目的MAC地址为00:00:00:00:00:00。 应答 在应答包中ARP协议报文Opcode字段被置为了reply(2)，Sender MAC address 即为发送方需要的MAC地址。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ARP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—CSMA/CD协议]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%A1%E7%BD%91%E2%80%94CSMACD%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[CSMA/CD协议引出协议最初的以太网都是采用总线型的拓扑结构，将许多计算机都连接到一台主机上。如下图： 总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。 其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。 这时候就有一个问题，总线在同一时间只能允许一台计算机发送信息，如果多台计算机同时向总线发送数据，就会产生冲突，为了解决冲突就出现了CSMA/CD(Carrier Sense Multiple Access with Collision Detection,载波监听多点接入/碰撞检测)协议。 基本思想 某站点想要发送数据，必须首先侦听信道； 如果信道空闲，立即发送数据；如果信道忙，则继续侦听信道。直到信道变为空闲，立即发送数据； 站点在发送过程中继续检测信道，若一直未检测到碰撞，则把该数据成功发送完毕；如果检测到冲突，立即停止发送数据，发送干扰信号，然后执行指数退避算法，等待一随机长的时间，重新侦听信道，返回第2步。 CSMA/CD技术实现 先听后发：载波侦听技术 边发边听：碰撞检测技术 冲突停止：发送干扰信号 延迟重发：截断二进制指数退避算法 先听后发以太网使用曼彻斯特编码传送数据 编码规则： 每比特的周期T分为前T/2和后T/2两个部分。 前T/2传送该比特的反码，后T/2传送该比特的原码。 每个比特中间有一次电平跳变。 这样就可以通过判断总线的电平是否出现跳变来判断总线的闲忙，实现载波侦听。 边发边听 站点检测冲突 检测电平信号变化幅度是否超过一定的门限值。 编码违例法 检查从总线上接收的信号是否违反曼彻斯特编码规则。 如果检测到了碰撞，总线上传输的信号就会产生严重的失真，无法从中回复出有用的信息。每一个正在发送数据的站点，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 为什么在发送过程中可能产生冲突？ 因为有传播时延对载波侦听的影响，导致可能出现冲突。 在上图中，第一个状态，A检测到信道空闲，开始发送数据，还没发送到B端的时候，B端此时检测到信道也是空闲的，同样会发送数据，这时候就会产生冲突💥。 检测冲突时间 这里有两种极端情况： 最短冲突时间：当A和B同时发送一个数据帧，在信道的中心处发生冲突后继续向两个方向传播，在这种情况下，只需要一个单向传播延迟。 最长冲突时间：A先发送一个数据帧，当A即将到达主机B时，B发送数据帧，这时主机B会立即检测到冲突，而主机A则需要再经过一个单向传播延迟之后才会检测到冲突。 冲突窗口 在一个局域网中，A、B两结点是距离最远的两点，相距D，信号传播速度V，A在发送数据后最多在W时间后可以检测出所有可能的冲突：W=2D/V,W被称为冲突窗口(争用期)； A、B两结点是距离最远的两点，A在冲突窗口内可以检测到所有可能的冲突，那么其它点当然可以在冲突窗口内检测到。 局域网中的所有结点在冲突窗口W时间内可以检测到所有可能的冲突，若在冲突窗口内没有检测到冲突, 则可以确认自己竞争到了总线的使用权，不再会与其他站点发生冲突。 冲突停止如果发送节点检测到冲突，则停止发送数据，并发出一个4字节或6字节的阻塞信号来加强冲突，增加编码违例的位数，使其他站点快速检测到。然后等待随机长的时间后再重新侦听信道。 延迟重发采取截断式二进制指数退避算法。算法过程： 确定基本退避时间片B，一般取冲突窗口值2t（两倍的单向传播时延）。 定义参数k，即k ＝ Min(重传次数,10) 。 从离散的整数集合[0,1,…,(2k - 1)]中等概率随机取出一个数，记为r。 重传所需的时延就是r倍的基本退避时间，即r*B。 当重传达16次仍不能成功时，则丢弃该帧，并向高层报告。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—交换局域网]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%A1%E7%BD%91%E2%80%94%E4%BA%A4%E6%8D%A2%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[交换局域网两个概念 冲突域：网络中的一组设备集合；域内的不同设备同时发出的以太网帧会互相冲突；特点为：每台主机的可用带宽很低，信息传输安全得不到保证。 广播域：网络中的一组设备集合；当这些设备中的一个发出一个广播时，所有其他的设备都能接收到这个广播帧。 为什么要使用交换机？使用集线器有下面几个缺点： 随着共享式以太网规模的扩大，冲突域不断扩大，导致网络带宽下降。 不同数据传输速率的以太网无法通过集线器互联。 所以，使用交换机将共享式局域网转变为交换式局域网，可以解决上面两个问题。 交换机的工作原理交换机表的生成和维护在Packet Tracer中查看Mac地址表： 此时的Mac地址表为空，PC0向PC1发送Ping包之后，再次查看交换机表： 此时表中就多了两条Mac地址的记录。 Mac地址表建立过程： PC0向PC1发送了一个数据包(数据包中含有源Mac地址和目的Mac地址)，当数据帧从交换机的f0/1进入交换机后，首先检查Mac地址表中的记录，当前没有该记录，就会将此记录添加进Mac地址表，这样就将PC0的Mac地址和f0/1端口建立了联系，此时，Mac地址表中没有关于PC1的记录，这时候，交换机会向除了f0/1端口之外的所有端口转发，从而保证PC1可以接收到该数据帧。当PC1向PC0发送数据包的时候，就会将PC1的Mac地址添加到Mac地址表中，此时就只会向f0/1端口转发，不影响其他端口。 如果数据帧为广播帧，那么交换机会直接将数据帧转发至所有端口。 每当加入一条新记录或更新一条记录时，就会设置一个定时器，当定时器超时记录仍然没有被更新，就视为“过时”，被删除。在交换机中可以查看这个时间。 过一会再查看Mac地址表，刚刚的两条的记录就消失了。 端口安全交换机的端口安全特性可以阻止非授权用户将集线器、交换机等设备接入到局域网中。 在Packet Tracer中实现端口安全拓扑图 配置过程 这里限制f0/1接口只允许Router0接入。 首先，查看R0的f0/0接口的Mac地址。 配置f0/0的ip和子网掩码。 Router&gt;enableRouter#config terminal Router(config)#int f0/0Router(config-if)#no shutdownRouter(config-if)#ip address 172.16.0.101 255.255.0.0 使用命令show int f0/0查看f0/0接口的Mac地址： 配置交换端口安全 Switch(config)#int f0/1Switch(config-if)#shutdown//将端口改为访问模式，即用来接入计算机Switch(config-if)#switchport mode access//打开交换机的端口安全功能Switch(config-if)#switchport port-security//该端口下的Mac条目最大数量为1，即只允许一台设备接入Switch(config-if)#switchport port-security maximum 1//该命令的作用是当有新的计算机接入的时候，该接口的MAC条目超过最大数量时交换机的处理策略//switchport port-security violation &#123;shutdown|protect|restrict&#125;//一共有三种处理策略//1.protect:新的计算机将无法接入，而原有的计算机不受影响；//2.shutdown:该接口将会被关闭，则这个新的计算机和原有的计算机都无法接入，需要管理员使用no shutdown&quot;命令重新打开。//3.restrict:这个新的计算机可以接入，然而交换机将向发送警告信息。Switch(config-if)#switchport port-security violation shutdown//配置允许接入的设备的Mac地址Switch(config-if)#switchport port-security mac-address 0007.ec03.4401Switch(config-if)#no shutdown Switch(config-if)#int vlan 1Switch(config-if)#no shutdown Switch(config-if)#ip address 172.16.0.1 255.255.0.0 配置完毕以后，查看交换机的Mac地址表，刚刚的Mac地址Type为静态： 使用命令show port-security可以查看当前的端口安全的设置情况： 模拟非法接入，修改R0的f0/0接口的Mac地址，模拟另一台设备接入， Router(config)#int f0/0Router(config-if)#mac-address 0012.1234.5678 此时，在R0上执行ping 172.16.0.1，ping不通交换机配置的vlan。 生成树协议为什么需要生成树协议？下面是一个交换局域网的冗余设计，这样的拓扑设计消除了由于单点故障所以引起的网络不通的问题，但是也会使网络中产生环路，会带来广播风暴、重复帧和Mac地址表不稳定的问题，这时候就需要使用生成树协议来解决这个问题。 广播风暴产生的过程那上图作为例子，其中有一个主机X、SW0、SW1、路由器Y。当主机X向路由器Y发出一个数据帧时，假如数据帧先到达了SW0，然而该交换机的Mac地址表中并没有路由器Y的记录，这时候SW1就会发广播，SW1接收到广播之后会按照SW0一样的处理方式发广播，这样的这个数据帧就在这个封闭的环路中无限的循环…… 生成树协议STP生成树协议所做的事情就是将其中的环路斩断，形成一个树形结构，这样就不会无线循环下去了。 算法过程 选举根桥。首先选举根桥(Root)，将此交换机作为生成树的根。在选举出根交换机之前，每个交换机都会认为自己是根交换机，每个都会发送BPDU。通过比较BPDU的桥ID字段，桥ID最小的交换机就会成为根桥。桥ID由桥优先级（Bridge Priority） 和48位的MAC地址构成。桥ID可以人工设置， 优先级最高的设备（数值越小越优先）会被选举为根桥。 如果优先级相同， 则会比较MAC地址， MAC地址越小则越优先 。 选举根端口。计算到所有端口的所有的路径代价，将代价最小的作为根端口(Root Port)。要注意的是，同一交换机上不同端口之间的路径开销值为0。如果有两个或两个以上的端口计算得到的累计路径开销相同，那么比较非根交换机的上行交换机桥ID，桥ID小的作为根端口。在根路径开销，指定桥ID都相同的情况下，上行交换机的最小端口号（物理编号）所连接的非交换机的端口为根端口。 比较过程： 计算非根交换机到达根桥的链路开销； 比较非根交换机的上行交换机桥ID（由优先级与MAC地址决定）； 上行交换机的物理最小端口号所连接的非交换机的端口为根端口。 选举指定端口。根桥的每个端口都是指定端口，与根端口直连的端口也是指定端口。，比较该网段中每个端口到根桥的路径代价，代价最小的做指定端口。 所有未被选作根端口或指定端口的端口都是非指定端口，进入阻塞状态。 在Packet Tracer中测试STP生成树协议拓扑图 在每个交换机上执行Switch#show spanning-tree命令，查看生成树信息： SW0： SW1： SW2： SW3： 下面分析协议执行的过程： (1) 首先选举根桥，四个交换机的桥优先级相同，都是32769，所以比较Mac地址，SW3的Mac地址值最小，所以选举SW3为根桥。 (2) 选举根端口，比较每个非根桥到根桥的路径代价，SW1的f0/2端口和SW2的f0/2端口到根桥的代价最小，都为19，所以SW1的f0/2接口和SW2接口为根端口。由于SW0的两个接口的路径代价都为38，代价相同，所以继续比较上行交换机的桥ID，SW1的桥ID小于SW2的桥ID，所以SW0的f0/1为根端口。 (3) 选举指定端口，现在根桥的所有接口都是指定接口，即SW3的所有接口都是指定端口，与根端口直连的端口也是指定端口，所以SW1的f0/1也是指定端口，再比较SW0的f0/2和SW2的f0/1接口，SW2的f0/1接口代价小于SW0的f0/2接口的代价，所以SW2的f0/1为指定端口，现在只剩下SW0的f0/2接口，该接口就成为了非指定端口，所以该端口被阻塞，生成树过程结束。 虚拟局域网VLAN为什么使用VLAN？当广播域中的结点不断增多的时候，网络中过多的广播包会严重影响通信的效率，这时候就需要使用vlan在物理接线的基础上改变逻辑分组的方式来缩小广播域。 VLAN的划分 一个VLAN = 一个广播域 = 一个逻辑网段（子网） 划分方法 静态VLAN：使用端口号定义 例如： VLAN1：1、3、4端口 VLAN2：2、5、6端口 动态VLAN：使用MAC地址等定义 例如： VLAN10：MAC2、MAC3、MAC4 ​ VLAN20：MAC1、MAC5、MAC6 VLAN间的路由在交换机上划分VLAN后，VLAN内部的通信通过交换机转发，但是VLAN间的计算机就无法通信了。VLAN间的通信需要借助第3层具有路由功能的设备 VLAN间的路由可以通过两种方式实现： 单臂路由 如果每个VLAN连接一个路由器端口,则占用太多的路由器端口，单臂路由可以节省端口 三层交换机 三层交换机的功能本质上就是一个交换机+路由器。 在Packet Tracer中配置VLAN使用三层交换机来配置VLAN，进行VLAN间的路由。 拓扑图 图中的Multilayer Switch 0就是一台三层交换机。 配置过程 在SW0上，执行下面的命令： //开启路由功能Switch(config)#ip routing//配置vlan 1Switch(config)#int vlan 1Switch(config-if)#no shutdownSwitch(config-if)#ip address 172.16.1.254 255.255.255.0//配置vlan 2Switch(config)#int vlan 2Switch(config-if)#no shutdownSwitch(config-if)#ip address 172.16.2.254 255.255.255.0 配置完毕以后，可以执行Switch#show ip route来查看路由表： 配置两台主机的IP、子网掩码和默认网关。 PC0 IP地址：172.16.1.1，子网掩码：255.255.255.0，默认网关：172.16.1.254 PC2 IP地址：172.16.2.1，子网掩码：255.255.255.0，默认网关：172.16.2.254 配置完毕以后，在PC0上Ping PC1，如果配置没有问题的话，就可以Ping通。 参考博客： https://blog.csdn.net/zainwei1766/article/details/41707447 https://blog.csdn.net/lycb_gz/article/details/17347189]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>交换机</tag>
        <tag>Packet Tracer</tag>
        <tag>STP</tag>
        <tag>VLAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—以太网帧]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%A1%E7%BD%91%E2%80%94%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[MAC地址 MAC地址固化在网卡中，又称物理地址，它是网络节点全球唯一的物理标识，与其物理位置无关。 MAC地址是数据链路层进行寻址的依据。 网络节点的每一个网络接口都有一个唯一的MAC地址。一个节点允许有多个MAC地址，取决于该站点网络接口的个数。 格式 总长度为48位每八位做一个分隔。 在windows下输入ipconfig/all查看本机的MAC地址： MAC帧的格式常用的以太网MAC帧格式有两种标准： DIX Ethernet V2 标准 IEEE 的 802.3 标准 下面主要分析Ethernet V2标准的以太网帧格式 当以太网帧到达物理层后，会在帧的前面插入的 8 字节中的第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段是帧开始定界符，表示后面的信息就是以太网帧。以太网帧并不是最终的传输形式。 Ethernet Ⅱ 帧格式 前导符和起始符：8 Bytes 7个10101010 字节尾随1个10101011字节，用来同步收发双方的时钟速率，稳定收发电路状态，并进行帧定界 。 目的地址和源地址：6 Bytes + 6 Bytes 发送主机和接收主机的物理MAC地址。 类型：2 Bytes 以太网支持多种网络层的协议，比如IP协议的编号就是0800，ARP协议的编号就是0806。 数据：46~1500 Bytes 以太网规定，以太网数据帧数据域长度最小为46 Bytes，总长度最小为64 Bytes，即6 + 6 + 2 + 46 + 4 = 64，当数据的字节不足46 Bytes时，会对其进行填充；以太网的MTU为1500 Bytes，即最大字节数为1500 Bytes。 CRC：4 Bytes 采用32位的CRC校验，在接收端校验，如果出错，则将该帧丢弃。 最小帧长度问题在CSMA/CD协议一节中提到了使用载波侦听技术来检测冲突，靠判断总线的电平是否出现跳变来判断总线的闲忙。以太网帧的最小帧长度的限制就和CSMA/CD协议有关。 在上图的第一个过程中，A主机发送了一个以太网帧，如果帧长度过短的话，就会造成在发生冲突之前就收到了发送完毕的信号，就检测不到冲突了，所以最小帧长度必须要保证发送时间大于所有工作站监测到冲突并发送碰撞的时间。 所以为了避免上述情况的产生，就要求以太网帧至少需要冲突窗口时间才能发送完毕，即发送方在发送的时候，如果有冲突一定在发送完以前能检测到。$$数据帧的传输时延t_1 = 数据帧长度 / 数据传输速率$$ $$信号的传输时延t_2 = 两站点之间的距离 / 信号传播速度$$ 如果要保证帧在传输中可以正常检测到冲突，则有$$t_1 &gt;= 2t_2$$按照标准，10Mbps以太网采用中继器时，连接的最大长度是2500米，最多经过4个中继器，因此规定对10Mbps以太网一帧的最小发送时间为51.2微秒。这段时间所能传输的数据为512位，512位＝64字节，这就是以太网帧最小64字节的原因。 结论 在以太网中，由于冲突窗口的限制，最小帧长 $F_{min}$、传输速率 $R$、网络跨距 $S$ 三者之间必须满足一定的关系：$$F_{min} = kSR，(k:系数)$$]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>以太网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—概述]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%A1%E7%BD%91%E2%80%94%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[计算机网络的分类按照不同作用范围分类 广域网 WAN (Wide Area Network) 城域网 MAN (Metropolitan Area Network) 局域网 LAN (Local Area Network) 个人区域网 PAN (Personal Area Network) 按照不同网络的使用者进行分类 公用网 (public network) 专用网 (private network) 虚拟专用网（Virtual Private Network）：在公用网上建立专用网的技术。 按照拓扑结构分类 星型结构 环型结构 总线型结构 网状结构 计算机网络中的性能指标1 速率 比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。一个比特就是二进制数字中的一个 1 或 0。 速率即比特率(bit rate)，单位时间内网络传递的比特数。是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等。 2 带宽 “带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。 现在“带宽”是数字信道所能传送的“最高数据率” ，单位是“比特每秒”，或 b/s (bit/s)。 常用单位 n千比每秒，即 kb/s （10^3b/s） n兆比每秒，即 Mb/s（10^6 b/s） n吉比每秒，即 Gb/s（10^9 b/s） n太比每秒，即 Tb/s（10^12 b/s） 关于速率、网速和带宽 此处讲到的速率和我们平时说的网速不是一个概念，平时说的网速比如下载一个文件的速度是2MB/s，此处是用储存单位衡量的这个网速实际上是每秒2M Byte，然而此处的速率是在信息论中使用的单位，如果网络的速率为2Mb/s指的是每秒2M bit，1Byte = 8 bit，带宽的单位就是和速率相同了，如果你家的带宽为100Mb/s，那么理论上的下载速度即网速应该为12.5MB/s。 3 吞吐量 吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的实际数据量。 吞吐量经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 4 时延 时延是指数据从网络的一端传送到另一端所需要的时间。网络时延是由传输时延（发送时延）、传播时延、处理时延、排队时延累加得到的。 传输时延(发送时延) 传输时延（发送时延 ）：发送数据时，数据块从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 发送时延 = 数据块长度(bit) / 发送速率(bit/s)传播时延电磁波在信道中需要传播一定的距离所花费的时间。 传播时延 = 信道长度(m) / 信号在信道上的传播速率(m/s)关于传输时延和传播时延 传输时延重在发送的时候产生的时延，与网络两端的距离无关，而当消息被发送到网线中后的时延就是传播时延，传播时延就是距离的函数了。 处理时延交换结点为存储转发而进行一些必要的处理所花费的时间。 排队时延 结点缓存队列中分组排队所经历的时延。排队时延的长短往往取决于网络中当时的通信量。 总时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延 5 往返时间(RTT)从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间(在TCP协议中可以判断拥堵)。 6 时延带宽积若发送端连续发送数据，从发送数据开始，到发送的第一个比特即将到达终点时，发送端已经发送的比特数。 时延带宽积 = 传播时延 * 信道带宽7 利用率利用率分为信道利用率和网络利用率。 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。 时延与网络利用率的关系 若令 $D_0$ 表示网络空闲时的时延，D表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 $D_0$之间的关系： D = \frac{D_0}{1-U}U是网络的利用率，数值在 0 到 1 之间。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网—TCP协议详解]]></title>
    <url>%2F2019%2F12%2F10%2F%E8%AE%A1%E7%BD%91%E2%80%94TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[我们经常会拿UD跟TCP进行比较，在介绍TCP之前首先介绍一下UDP协议 UDP 全称：用户数据报协议（UDP，User Datagram Protocol），UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。 数据报格式 源端口号和目的端口号：源端程序和目的端程序进程的端口号。 总长度：UDP包的字节数，包括头部和数据，最小长度为8 Byte(头部长度为8 Byte)。 校验和：对伪包头 + UDP头部 + UDP数据三部分的校验。 WireShark中抓到的包(DNS解析报文) 首部格式 UDP协议的首部有一个特别的地方就是伪首部，伪首部是不会被传输的，仅仅是在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起，伪首部只是为了计算检验和。 总结从UDP的数据报格式上就可以看出UDP是一种不可靠的传输层协议： (1) UDP无连接，即通信的双方无需建立连接就可以收发数据。 (2) 不进行差错控制，而且不能保证数据可以准确到达。 (3) 不会进行流量控制、拥塞控制。 然而，UDP的缺点就是TCP的优点，UDP的缺点也正是TCP的优点。 TCP协议 传输控制协议（TCP，Transmission Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信协议。 数据报格式 源端口和目的端口：各2 Byte源端程序和目的端程序进程的端口号。 发送序号：4 Byte，指出本报文段中的数据的第一个字节在发送方本次连接上发送的数据流中的位置。 确认序号：4 Byte，期望收到对方下一个报文段的第一个数据字节的序号，与 ACK = 1配合使用； 头部长度：4 bit，以4字节为单位指出头部的长度，如该位为5，则头部长度为20 Byte。 URG：6 bit当 URG = 1 时，表明此报文是紧急数据，应尽快传送出去，接收方应优先处理。 ACK：当ACK = 1 时确认序号字段才有意义。 PSH：当 PSH = 1 时，该包连同传送缓冲区的其它包应立即进行传送，而无需等待缓冲区满了才送，接收端必须尽快将此数据交给程序处理。 RST：当 RST = 1 时，表明出现严重差错，复位产生差错的连接。 SYN、FIN：与三次握手和四次挥手有关，将在后面解释。 窗口大小：2 Byte，用于流量控制，将在后面解释。 校验和：2 Byte，和UDP相同，校验范围也是伪包头 + TCP头部 + TCP数据。 紧急指针：2 Byte，当 URG = 1 的时，紧急指针就会指示出紧急数据所在位置。 可选项：长度可变，可选项的长度要么是 0 ，要么就是 32 bit 的整倍数。TCP 只规定了一种选项，即最长报文段MSS(Maximum Segment Size)，限定了每个TCP报文段中数据字段的最大长度。 最长报文段MSS：为了避免发送主机对IP报文进行分片，限定TCP报文段中数据量的最大长度，与数据链路层MTU有关。 可以看出，TCP协议从数据报格式上来看就比UDP麻烦了很多。 连接的建立和释放三次握手TCP协议是面向连接的传输层协议，发送数据前首先要建立连接，TCP建立连接的方式就是三次握手。 三次握手的过程： (1) 发起连接的一方，即客户端发送SYN = 1，ACK = 0，Sequence Number = x (这里的x是一个随机数，原因后面说明) 的TCP报文。 (2) 接受连接的一方，即服务端接收到客户端发送的连接请求后，返回SYN = 0，ACK = 1，Ack Number = x + 1的报文。 (3) 客户端收到服务端的响应后，再发送一个SYN = 0，ACK = 1，Sequence Number = x + 1的报文。 为什么序列号初始值为随机数？ Sequence number的起始值就是从三次握手的第一次开始确定的，而且起始值是生成的随机数，这样做的原因是为了防止黑客猜出初始序列号进行攻击。 SEQ和ACK SEQ代表：发送这个包中的第一位应该在整个数据流中所处的位置。 ACK代表：接收方希望收到的下一个Sequence number是多少。 举例： 假如发出了Seq num为100的包，那么返回的Ack num就应该是对前100号包的确认，Ack num = 101，表示 实例 分析WireShark中抓到的三次握手的数据包。 (1) 第一次握手 由客户端发出，可以看到，第一次握手SYN被置1，同时给出了初始的Sequence number(此处WireShark为了便于分析将序列号变成了相对序列号，从0开始)。 (2) 第二次握手 由服务端返回，第二次握手SYN和ACK都被置1，Ack number被置为了1，这里要注意，虽然Segment Len为0，但是Ack number增加了1。 (3) 第三次握手 由客户端返回，ACK被置1，凡是由客户端发出的数据帧只有该包的ACK是被置为1的 差错控制差错控制的主要任务是发生下列异常情况的时候，要能检测到并且采取措施来纠正差错。 (1) 报文段出错 (2) 报文段丢失 (3) 报文段确认丢失 报文段丢失 发送方每发送一个报文段，就会启动一个重传定时器，若某个报文段丢失，发送方的定时器就会超时，然后对其进行重传。 报文段出错 当每次接收端收到一个报文段，都会首先对其进行差错检测，正确就接收并返回确认，错误则不进行确认相应，这样，当启动的定时器超时之后，发送方就会重传。 确认丢失 如果确认包丢失了，那么发送方的定时器会超时，对数据包进行重传，接收方通过数据包的序号可以判断出是否收到了重复包，如果收到的是重复包会将该包丢弃，之后再返回一次确认。 流量控制差错控制中给出的几个图，都是基于停等技术来举的例子，然而发送方每发出一个报文段，就停下来等待接收方的确认的方法通信效率极低，所以需要一次性发送多个数据包以提升网络通信的效率。然而，如果一次性发送的数据包太多，数据发送过快，接收方会来不及接收，这样通信效率反而会降低。 TCP协议有专门的流量控制技术，就是使用滑动窗口技术。 滑动窗口技术采用滑动窗口技术以后，允许发送方在未获得确认的情况下连续发送多个数据包，但是会限制连续发送多包的最大数量，缓和传输效率和流量控制的矛盾。 上图就是一个发送窗口的简单示例，窗口大小为4，那么发送端会一次性就会发送4个数据包，当发送端收到接收端的1号包的响应的时候，窗口就会向前滑动。 在TCP协议中的滑动窗口技术是动态的，因为通讯过程是支持全双工的，所以TCP有两个滑动窗口，一个是发送窗口，一个是接收窗口，发送窗口大小 = 接收窗口大小。在TCP协议数据报格式一节中，其中TCP数据报的头部有一个窗口大小字段，该字段就是控制滑动窗口的大小的，双方会该字段来限制滑动窗口的大小，进行流量控制。 基于滑动窗口技术的差错控制使用了滑动窗口技术之后，差错控制就不是仅仅为每个数据包开启一个定时器 当对报文段的确认超时，根据发送方采取措施的不同，差错控制分为两种： 回退N差错控制 所谓的回退N差错控制指的是如果某个报文段确认超时，那么发送方会按需重发该包以及其后所发的所有包，接收端会对重复的包进行丢弃；接收方可以进行累计确认。 这种方法对于接收方来说做出的处理相对简答，但是缺点也很明显，就是会导致某些已经正确接受的数据重传，降低通信效率。 选择重传差错控制 某个报文段的确认超时，发送方只重传定时器超时的那一个报文段，接收方可以暂存序号在出错数据包之后（接收窗口内）的数据，直到收到正确的，排好序后上传应用层；接收方不采用累积确认。 拥塞控制在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏—产生拥塞(congestion)。 TCP的拥塞控制机制需要发送方采取某些措施来尽量避免拥塞控制的发生或者对已经发生的拥塞做出响应。 这样，拥塞控制就可以分为两部分：拥塞避免和拥塞控制。 发送方如何探测网络的拥塞状况？如果发生了网络拥塞，那么数据包的传输必定收到影响，拥塞的网络会导致数据包传输延迟变长或者被丢弃。 在TCP中两种策略来检测当前网络是否拥堵。 重传定时器超时，虽然重传定时器超时是用来差错检测的，但是一般来说由于出数据包差错而被丢弃的概率是很小的。所以只要出现了超时的情况，就可以猜想网络出现了拥堵。 收到三个重复的ACK，个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。 另外，如果TCP协议检测到了拥塞状况的产生，那么就会采取流量控制，通过改变滑动窗口的大小来控制流量。 发送窗口大小 = Min(rwnd, cwnd) 拥塞控制算法TCP拥塞控制算法：慢开始、拥塞避免、快速重传、快速回复。 TCP会为每个连接维持两个变量： 拥塞窗口：cwnd 慢开始门限：ssthresh 慢启动算法思路：由小到大逐渐增大拥塞窗口的数值。 SMMS：Sender Maximum Segment Size，发送方一次传输发送的最大数据段长度。发送方发送的每个报文段也就是1 SMMS大小。 初始拥塞窗口数值的设定： 在新的RFC 5681中把初始的拥塞窗口值指定为2~4个SMMS的值： If SMSS &gt; 2190 bytes: IW = 2 * SMSS bytes and MUST NOT be more than 2 segmentsIf (SMSS &gt; 1095 bytes) and (SMSS &lt;= 2190 bytes): IW = 3 * SMSS bytes and MUST NOT be more than 3 segmentsIf SMSS &lt;= 1095 bytes: IW = 4 * SMSS bytes and MUST NOT be more than 4 segments 慢启动过程：现在假定拥塞窗口cwnd的初始值为1(1个SMSS的长度)，发送方每收到一个ACK，那么cwnd就增加1，也就是说每经过一个RTT的时间，cwnd就加倍。 注意：慢启动的慢指的是拥塞窗口的初值小，慢启动的过程可以说是一点都不慢 在慢启动进行到一定的时间之后，如果不加以限制，就会造成网络拥塞，设定一个慢启动门限ssthresh，当cwnd &gt;= ssthresh时，开始进入下一个阶段：拥塞避免。 拥塞避免算法思路：使拥塞窗口的值平缓地增大 算法过程： 拥塞避免阶段不再采用指数增长的形式，而是采用线性增长的形式。 (1) 当检测到cwnd &gt; ssthresh之后，就会将慢启动转换为拥塞避免。 (2) 无论在慢启动还是拥塞避免阶段，只要发送方判断网络出现了拥塞(定时器超时或者收到三个重复的ACK)，就会采取下面的策略： ssthresh = cwnd / 2 cwnd = 1 开始执行慢启动算法 上图就是一个TCP执行拥塞避免的全过程： 当TCP建立连接以后，将拥塞窗口设置为了1，开始慢启动，cwnd指数增长，cwnd等于ssthresh的初值之后进行拥塞避免，cwnd开始线性增长，在12传输轮次中，发生了超时事件，ssthresh = 16 / 2 = 8，cwnd = 1，并且重新进入慢启动、拥塞避免，到④后，发送了收到三个重复的ACK的情况，这时发送方改为执行==快重传和快恢复算法==。 快重传发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。 快恢复当发送端收到连续三个重复的确认时n由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法： ssthresh = cwnd / 2 cwnd = ssthresh 开始执行拥塞避免算法 所以，在上面的图中，到达④之后，进行了快恢复算法，ssthresh = 16 / 2 = 8，cwnd = ssthresh，下面开始进行拥塞避免算法。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Packet Tracer实现远程管理交换机]]></title>
    <url>%2F2019%2F12%2F09%2F%E5%9C%A8Packet%20Tracer%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BA%A4%E6%8D%A2%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[使用PC远程控制交换机的方式有两种，一种是将电脑的RS 232和交换机的console口连接，这种管理方式不占用交换机的网络端口，第一次配置交换机的时候必须利用该方法；第二种方式是利用采用telnet方式远程连接交换机。下面在Packet Tracer中分别介绍这两种方式。 console方式 新建拓扑图 点击PC0，打开Desktop-&gt;Terminal。 打开Terminal之后配置下面的信息，点击OK。 这样就可以控制交换机了，下面配置telnet远程连接交换机就可以直接在这里面进行。 Telnet远程控制 拓扑图中需要增加一根网线。 依次输入下面的命令。 Switch&gt;enable //进入特权模式Switch#config terminal //进入全局配置模式SWl(config)#hostname SW1 //为交换机设置别名SWl(config)#line vty 0 4 //远程登录用户最多5个SWl(config-line)#password 123456 //设置远程登录密码SWl(config-line)#login //允许远程登录访问SWl(config-line)#exit SWl(config)#interface vlan l //配置vlanSWl(config-if)#ip address 192.168.1.1 255.255.255.0 //配置vlan 1管理接口的IP地址和子网掩码SWl (config-if)#no shutdown //开启vlan1接口 配置PC0的IP和子网掩码，保证和交换机在同一网段下。 先试一下可不可以Ping通。 使用Telnet远程连接交换机，现在就可以在PC0的命令行中看到交换机SW1了。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>交换机</tag>
        <tag>Packet Tracer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程—UML]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E2%80%94UML%2F</url>
    <content type="text"><![CDATA[用例图 用例图(Use Case Diagram): 也称为用户模型图，是从软件需求分析到最终实现的第一步，从客户的角度来描述系统功能。 基本组件 参与者：与系统打交道的人或其他系统即使用该系统 的人或事物。 用例：代表系统的某项完整的功能。 子系统：用来展示系统的一部分功能，这部分功能联系紧密。 关系：用例之间的关系。 关系类型 说明 符号 关联 参与者和用例之间的关系 泛化 参与者之间或用例之间的关系 包含 用例之间的关系 扩展 用例之间的关系 ​ (1) 关联 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 ​ (2) 泛化 和类图中的泛化相同，都是表示继承关系，子用例可以继承父用例，子参与者也可以继承父参与者。 ​ (3) 包含 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。 ​ (4) 扩展 扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。 顺序图 顺序图也叫时序图，描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序 顺序图的X轴表示不同的对象，Y轴表示时间 对象间的通信表示为对象生命线之间的消息传递 基本组件 对象 对象是类的实例。 图示： 生命线 表示对象的生存时间。生命线从对象创建开始到对象销毁时终止。 消息 对象之间的交互是通过相互发消息来实现的。一个对象可以请求（要求）另一个对象做某件事件。 消息的分类 状态图状态图刻划特定对象所有可能的状态及状态变迁。 基本组件状态：矩形，四角为圆弧转移：箭头起点：一个黑点终点：一个圈加一个黑点 实例 图书馆的书籍状态说明：书籍在未变成图书馆在库书籍时，为新书籍状态。书籍处于在库状态时既可以预订也可以外借，外借后变为借出状态。处于预订状态时也可以外借，超出预订时间期限则从预订状态直接转为可用状态。借阅者在规定的预订时间内也可以考虑取消预订，取消预订后书籍的状态转为可用。外借书籍归还后变为可用状态。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件工程—七大设计原则]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E2%80%94%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1、开闭原则（Open Close Principle） 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是在原有的代码上进行扩展，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。 2、里氏替换原则（Liskov Substitution Principle） 任意父类可以出现的地方，子类也可以出现。最重要的一点就是子类对象可以替换基类对象。尽量继承虚类，避免继承实体类。 3、依赖倒置原则（Dependence Inversion Principle） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。客户不应该依赖他们不用到的方法，只给每个客户它所需要的接口。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、组合复用原则（Composite Reuse Principle） 多用组合少用继承。 7. 单一职责原则（Single Responsibility Principle） 一个类，只有一个引起它变化的原因。一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小。如果一个类承担的职责过多，就相当于把职责耦合在一起，当其中一个职责发生变化时，可能会影响其他职责的运行。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F11%2F20%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML定义： UML即统一建模语言（Unified Modeling Language）,它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 UML类图就是一种供软件设计师们看的可以表达类的关系的一种统一语言，只不过是用图的形式来表达。 下面有个Student类，age默认值为1，提供了get和set方法。 public class Student &#123; private String name; private int age = 1; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 下面我们来看一下该类的UML类图。 上面的类图中主要有三个部分类名、类的属性和方法，三个部分使用分隔符分隔。 类的属性和方法的表达格式： 类的属性格式：访问权限 属性名:类型[=默认值] 类的方法格式：访问权限 方法名称:类型[:返回类型] “+”表示public，”-“表示private，”#”表示protected。 类之间的关系类与类之间有下面几种关系： 泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）。 下面用Java代码和类图之间的对比来解释上述的关系。 泛化（Generalization）泛化就是Java中的继承关系，很好理解。 Student类继承于Person类，那么两个对象就是泛化关系，使用带空心三角形的实线箭头表示。 public class Student extents Person &#123; &#125; 实现（Realization）实现就是Java中实现接口的方法。 Studen类中实现了一个Skil接口，那么Student类和Skill接口之间就是实现关系，使用带空心三角形的虚线箭头表示。 public interface Skill &#123; void code();&#125;public class Student implments Skill &#123; @Override public void code() &#123; &#125;&#125; 依赖（Dependence）依赖是一种很弱的关系，如果类A访问类B的属性或者方法，或者类A负责实例化类B，那么可以说类A依赖类B。比如下面的例子，Student如果要在图书馆借书，图书馆管理员需要记录该学生的学号，Librarian类就需要访问Student类的getSno()方法来获取sno属性，那么就说Librarian类依赖于Student类，使用虚线箭头表示，箭头指向被依赖的对象。 public class Librarian &#123; public void record(int sno) &#123; //记录sno; &#125;&#125; 关联（Association）关联关系是一种比较强的关系，两者的关系是比较长久的，比如学生和家的关系，就是一种关联关系。关联关系分为两种，一种是单向关联，一种是双向关联， 如果一个类知道或者引用了另一个类，而另一个类不知道或者没有引用这个类，则这两个类是单向关联的。 比如学生和家的关系，每个学生都有家，但是每个家里并不是都有学生。单项关联使用实线箭头表示，箭头指向被引用的类。 public class Student &#123; Home home;&#125; 双向关联是双方都知道对方的存在，比如学生和老师的关系就是双向关联，双向关联用实直线表示。 public class Student &#123; Teacher teacher;&#125;public class Teacher &#123; Student student;&#125; 聚合（Aggregation）聚合关系强调的是整体和部分的关系，其部分可以脱离整体而存在。比如大雁和雁群的关系，就是聚合关系，大雁离开雁群也是可以独立存在的。聚合关系使用带空心菱形的虚线箭头表示，菱形指向整体。 public class Geese &#123; String shape; ArrayList&lt;Goose&gt; geese;&#125; 组合（Composition）组合关系也是强调的整体和部分的关系，而在此关系中部分不可以脱离整体存在。比如大雁和翅膀，就是组合关系，翅膀不能脱离大雁的存在而存在。。。组合关系使用是带实心菱形的虚线箭头表示，菱形指向整体。 public class Goose &#123; Wing wing;&#125; 组合、聚合、关联、依赖这几种关系关联程度也就显而易见了，依赖程度：组合&gt;聚合&gt;关联&gt;依赖。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—工厂模式]]></title>
    <url>%2F2019%2F11%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 简单工厂模式下面给出一个《Head First设计模式》中的披萨店的例子，现在有一个披萨店，这个披萨店中有许多不同种类的披萨，芝士🍕、培根🍕。对于这种情况，就可以创建一个制作披萨的工厂，向这个工厂类中传入披萨的名称就可以实例化出相应的🍕。 下面给出代码： Pizza.java package top.liuergo.factory.simple;/** * @author liuergo * @description 披萨类 * @date 2019-11-21 21:18 */public interface Pizza &#123; /** * 准备方法 */ void prepare(); /** * 烘焙方法 */ void bake(); /** * 披萨切片的方法 */ void cut();&#125; CheesePizza.java package top.liuergo.factory.simple;/** * @author liuergo * @description 芝士披萨 * @date 2019-11-21 21:21 */public class CheesePizza implements Pizza &#123; public CheesePizza() &#123; System.out.println("做一个CheesePizza"); &#125; @Override public void prepare() &#123; &#125; @Override public void bake() &#123; &#125; @Override public void cut() &#123; &#125;&#125; BaconPizza.java package top.liuergo.factory.simple;/** * @author liuergo * @description 培根披萨 * @date 2019-11-21 21:23 */public class BaconPizza implements Pizza &#123; public BaconPizza() &#123; System.out.println("做一个BaconPizza"); &#125; @Override public void prepare() &#123; &#125; @Override public void bake() &#123; &#125; @Override public void cut() &#123; &#125;&#125; SimplePizzaFactory.java package top.liuergo.factory.simple;import java.security.PublicKey;/** * @author liuergo * @description 披萨工厂类 * @date 2019-11-21 21:24 */public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new CheesePizza(); &#125; else if ("bacon".equals(type)) &#123; pizza = new BaconPizza(); &#125; return pizza; &#125;&#125; PizzaStore.java package top.liuergo.factory.simple;/** * @author liuergo * @description 披萨店 * @date 2019-11-21 22:15 */public class PizzaStore &#123; SimplePizzaFactory factory; public PizzaStore (SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza oderPizza(String type) &#123; Pizza pizza; pizza = factory.createPizza(type); pizza.bake(); pizza.cut(); return pizza; &#125;&#125; Tester.java package top.liuergo.factory.simple;/** * @author liuergo * @description 测试类 * @date 2019-11-21 21:28 */public class Tester &#123; public static void main(String[] args) &#123; PizzaStore pizzaStore = new PizzaStore(new SimplePizzaFactory()); pizzaStore.oderPizza("cheese"); pizzaStore.oderPizza("bacon"); &#125;&#125; 运行结果： 注：上面createPizza方法也可以定义成静态方法，这样就是一个静态工厂，这样就不需要实例化工厂类了，但是使用静态工厂就不可以使用继承了来改变创建方法的行为了。 简单工厂模式其实不是一个设计模式，它更像是一种编程习惯。下面开始介绍工厂模式。 工厂模式还是上面披萨店的例子，假如现在你的披萨店生意越来越红火，你开始在全国范围内开分店，然而每个分店的都想要发挥自己店的特点，这样所有的店不能都使用一个披萨工厂，我们需要使用另外的方式来创建工厂。 最主要的地方就是PizzaStore类，将该类中的SimplePizzaFactory删掉，把createPizza方法拿到该类中，并声明为抽象方法。 package top.liuergo.factory.veritable;import javax.security.auth.login.CredentialException;/** * @author liuergo * @description 披萨店 * @date 2019-11-21 22:15 */public abstract class PizzaStore &#123; /** * 创建披萨的抽象方法 * @param type * @return */ public abstract Pizza createPizza(String type); public Pizza oderPizza(String type) &#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); return pizza; &#125;&#125; 这样，所有的PizzaStore必须要继承该类，并重写createPizza方法，实现自己的createPizza方法。 package top.liuergo.factory.veritable.store;import top.liuergo.factory.veritable.Pizza;import top.liuergo.factory.veritable.PizzaStore;import top.liuergo.factory.veritable.pizza.BeijingBaconPizza;import top.liuergo.factory.veritable.pizza.BeijingCheesePizza;/** * @author liuergo * @description 北京的披萨店 * @date 2019-11-21 23:52 */public class BeijingPizzaStore extends PizzaStore &#123; @Override public Pizza createPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new BeijingCheesePizza(); &#125; else if ("bacon".equals(type)) &#123; pizza = new BeijingBaconPizza(); &#125; return pizza; &#125;&#125; 我们再看一下工厂模式的定义：工厂模式定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 这里我们就使PizzaStore的子类BeijingPizzaStore来决定了实例化哪个类，做到了使其创建过程延迟到子类中进行。 你也可以使用创建工厂接口的方式来实现在实现了工厂接口的类中实例化类的方式。 PizzaFactory.java package top.liuergo.factory.veritable2;/** * @author liuergo * @description 披萨工厂 * @date 2019-11-22 00:10 */public interface PizzaFactory &#123; /** * 工厂方法 * @param type 披萨的种类 * @return 返回做好的🍕 */ Pizza createPizza(String type);&#125; PizzaStore.java package top.liuergo.factory.veritable2;/** * @author liuergo * @description 披萨店 * @date 2019-11-21 22:15 */public abstract class PizzaStore &#123; PizzaFactory pizzaFactory; public PizzaStore(PizzaFactory pizzaFactory) &#123; this.pizzaFactory = pizzaFactory; &#125; public Pizza oderPizza(String type) &#123; Pizza pizza; pizza = pizzaFactory.createPizza(type); pizza.bake(); pizza.cut(); return pizza; &#125;&#125; 这样对于不同的披萨店来说，需要实现各自的披萨工厂，实现自己的createPizza方法，抽象类和接口只是实现方式不同，思想是一样的。但是对于当前的例子来说，显然使用抽象工厂方法代替接口式工厂的方式更合适。（《Head First设计模式》并没有使用工厂接口的方式实现，如果此处使用有错误请指出） 抽象工厂模式我们首先补全一下Pizza，给Pizza基类添加几个属性，将其改为抽象类。 package top.liuergo.factory.veritable;import top.liuergo.factory.veritable.ingredient.Cheese;import top.liuergo.factory.veritable.ingredient.Dough;import top.liuergo.factory.veritable.ingredient.Sauce;/** * @author liuergo * @description 披萨类 * @date 2019-11-21 21:18 */public abstract class Pizza &#123; Sauce sauce; Cheese cheese; Dough dough; /** * 准备方法 */ public void prepare()&#123;&#125;; /** * 烘焙方法 */ public void bake()&#123;&#125;; /** * 披萨切片的方法 */ public void cut()&#123;&#125;;&#125; 现在，又来了新需求，我们的众多分店制作披萨的原料都需要在不同的地方进货，比如北京的披萨想要黑龙江的酱料、上海的芝士、云南的面胚…面对这个需求，我们就可以使用抽象工厂模式，建立一个原料工厂，分别生产每个分店所需的五花八门的原料。 新建一个PizzaIngredientFactory接口，其中声明了三个工厂方法。 package top.liuergo.factory.veritable;import top.liuergo.factory.veritable.ingredient.Cheese;import top.liuergo.factory.veritable.ingredient.Dough;import top.liuergo.factory.veritable.ingredient.Sauce;/** * @author liuergo * @description 披萨原料工厂 * @date 2019-11-22 14:42 */public interface PizzaIngredientFactory &#123; /** * 创建酱料的工厂方法 * @return 酱料 */ Sauce createSauce(); /** * 创建芝士的工厂方法 * @return 芝士 */ Cheese createCheese(); /** * 创建面胚的工厂方法 * @return 面胚 */ Dough createDough();&#125; 这样，如果北京的分店想要自己定制原料来源的话就可以创建一个北京的原料工厂，自己决定进哪的原料。 package top.liuergo.factory.veritable;import top.liuergo.factory.veritable.ingredient.*;/** * @author liuergo * @description 北京的原料工厂 * @date 2019-11-22 14:45 */public class BeijingIngredientFactory implements PizzaIngredientFactory&#123; @Override public Sauce createSauce() &#123; //使用上海的酱料 return new ShanghaiSauce(); &#125; @Override public Cheese createCheese() &#123; //使用北京的芝士 return new BeijingCheese(); &#125; @Override public Dough createDough() &#123; //使用北京的面胚 return new BeijingDough(); &#125;&#125; 我们再对抽象披萨类和实际披萨类做一下修改： 将抽象披萨类的prepare方法修改为抽象方法。 package top.liuergo.factory.veritable;import top.liuergo.factory.veritable.ingredient.Cheese;import top.liuergo.factory.veritable.ingredient.Dough;import top.liuergo.factory.veritable.ingredient.Sauce;/** * @author liuergo * @description 披萨类 * @date 2019-11-21 21:18 */public abstract class Pizza &#123; Sauce sauce; Cheese cheese; Dough dough; /** * 将准备方法修改为抽象方法，子类必须重写该方法 */ public abstract void prepare(); /** * 烘焙方法 */ public void bake()&#123;&#125;; /** * 披萨切片的方法 */ public void cut()&#123;&#125;;&#125; 重写prepare方法，根据构造器传入的原料工厂自定义原料。在此方法中你甚至可以不要某个原料。 package top.liuergo.factory.veritable.pizza;import top.liuergo.factory.veritable.Pizza;import top.liuergo.factory.veritable.PizzaIngredientFactory;/** * @author liuergo * @description 培根披萨 * @date 2019-11-21 21:23 */public class BeijingBaconPizza extends Pizza &#123; private PizzaIngredientFactory ingredientFactory; public BeijingBaconPizza(PizzaIngredientFactory ingredientFactory) &#123; System.out.println("做一个北京BaconPizza"); this.ingredientFactory = ingredientFactory; &#125; @Override public void prepare() &#123; ingredientFactory.createSauce(); ingredientFactory.createDough(); ingredientFactory.createCheese(); &#125;&#125; 最后，我们的点披萨代码不需要发生任何改变。 BeijingPizzaStore beijingPizzaStore = new BeijingPizzaStore();beijingPizzaStore.oderPizza("cheese");ShanghaiPizzaStore shanghaiPizzaStore = new ShanghaiPizzaStore();shanghaiPizzaStore.oderPizza("bacon"); 原料工厂就是一个抽象工厂模式的例子，下面给出定义： 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 我们最初在PizzaIngredientFactory接口中声明了三个工厂方法，PizzaIngredientFactory就是这个超级工厂，利用这个超级工厂我们可以创建多个工厂。 如果对工厂模式和抽象工厂模式的区别还有疑问的童鞋可以看下这个知乎的问题： https://www.zhihu.com/question/20367734 最后给出最终的UML类图： 完整代码地址： https://github.com/liuzhongyue/DesignPatterns 以上例子均来源于《Head First设计模式》，介绍的肯定不如原书详细，只是简单地对书中的思路和内容做了总结，并加上自己的理解和想法对其中和的例子稍微做了修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—策略模式]]></title>
    <url>%2F2019%2F11%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们需要创建表示各种策略的对象和一个行为随着策略改变而改变的context对象，通过策略对象改变context对象的执行算法。 学习设计模式最重要的一点就是要搞清楚设计模式的应用场景，首先举几个例子，比如我们手机支付的时候，可以使用支付宝可以使用微信也可以使用云闪付，这些支付方式每一种都是一个策略对象，每一种策略都是可以互相替换的；再比如淘宝双十一的打折活动，可以叠津贴、用红包或者店家直接打折，每一种优惠方式也是一种策略。 策略模式做到的就是 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 实现首先我们画出该模式的UML类图： 其中，Context是上下文对象，是真正执行策略的对象，维护一个实现Strategy接口的类，Strategy接口是策略接口，是用于声明所有算法的接口，SpecificStrategy是Strategy接口的实现类，里面有算法的具体实现。 Context.java /** * @author liuergo * @description Context上下文对象 * @date 2019-11-20 16:16 */public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 执行策略的具体方法 */ public void executeStrategy() &#123; strategy.algorithmStatement(); &#125;&#125; Strategy.java /** * @author liuergo * @description 策略接口 * @date 2019-11-20 16:09 */public interface Strategy &#123; /** * 某种算法的声明 */ public void algorithmStatement();&#125; 在这里，有两个类实现了Strategy接口。 SpecificStrategyA.java /** * @author liuergo * @description 具体的策略对象 * @date 2019-11-20 16:13 */public class SpecificStrategyA implements Strategy&#123; @Override public void algorithmStatement() &#123; System.out.println("算法A"); &#125;&#125; SpecificStrategyB.java /** * @author liuergo * @description 具体的策略对象 * @date 2019-11-20 16:15 */public class SpecificStrategyA implements Strategy&#123; @Override public void algorithmStatement() &#123; System.out.println("算法B"); &#125;&#125; Tester.java public class Tester &#123; public static void main(String[] args) &#123; Context context = new Context(new SpecificStrategyA()); context.executeStrategy(); context = new Context(new SpecificStrategyB()); context.executeStrategy(); &#125;&#125;//Output://算法A//算法B 可以看到，使用策略模式之后可以动态地在代码运行过程中替换Context对象所使用的算法。 这里可以对Context对象继续做改进。 //Context.javapublic class Context &#123; private Strategy strategy; public Context() &#123; &#125; /** * 执行策略的具体方法 */ public void executeStrategy() &#123; strategy.algorithmStatement(); &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125;&#125;//Tester.javapublic class Tester &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setStrategy(new SpecificStrategyA()); context.executeStrategy(); context.setStrategy(new SpecificStrategyB()); context.executeStrategy(); &#125;&#125; 这样就不用重复地new Context对象了。 例子下面使用策略模式完成一个手机支付的例子。 首先，画出UML类图： Payment.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 支付策略 * @date 2019-11-20 20:31 */public interface Payment &#123; /** * 支付方法 * @param balance 消费前的余额 * @param price 消费的物品的价格 * @return 返回消费之后的余额 */ double pay(double balance, double price);&#125; Alipay.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 支付宝支付 * @date 2019-11-20 20:31 */public class Alipay implements Payment&#123; @Override public double pay(double balance, double price) &#123; //各种支付方式中此部分逻辑肯定不同 System.out.println("正在打开支付宝..."); System.out.println("使用支付宝支付了" + price + "元"); return balance - price; &#125;&#125; WechetPay.java package top.liuergo.strategy.practical;/** * @author liuergo * @description 微信支付 * @date 2019-11-20 20:35 */public class WechatPay implements Payment &#123; @Override public double pay(double balance, double price) &#123; //各种支付方式中此部分逻辑肯定不同 System.out.println("正在打开微信..."); System.out.println("使用微信支付了" + price + "元"); return balance - price; &#125;&#125; Consumer.java package top.liuergo.strategy.practical;import lombok.Data;/** * @author liuergo * @description 消费者 * @date 2019-11-20 20:36 */@Datapublic class Consumer &#123; double balance; Payment payment; public void usePayment(double price) &#123; this.balance = payment.pay(balance, price); System.out.println("当前余额:"+ this.balance); &#125;&#125; Tester.java import top.liuergo.strategy.practical.Alipay;import top.liuergo.strategy.practical.Consumer;import top.liuergo.strategy.practical.WechatPay;/** * @description: 测试类 * @author liuergo * @date 2019-10-30 16:57 */public class Tester &#123; public static void main(String[] args) &#123; Consumer consumer = new Consumer(); consumer.setBalance(20000); consumer.setPayment(new Alipay()); consumer.usePayment(20); consumer.setPayment(new WechatPay()); consumer.usePayment(100); &#125;&#125; 运行程序之后的输出：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven总结]]></title>
    <url>%2F2019%2F11%2F13%2FMaven%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[由于之前一直在做安卓项目，使用Gradle比较多，Maven用的比较少，最近趁着新一届的学弟学妹们加入团队，在学习Java Web基础，跟着学弟学妹们一起学习，对之前的笔记做一个整理，也当重新回顾一下。 Maven简单介绍，Maven是目前最受欢迎的 Java项目管理构建自动化综合工具。 Maven主要有三个功能： 管理依赖：只需要在pom文件中写入相关的属性就会自动下载并管理jar包。 项目的构建：内置很多插件，比如校验、编译、测试、打包、部署、发布等。 项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等。 安装和配置，略… 仓库配置在使用Maven时，会按照以下的步骤检查pom.xml并加载相关的依赖。 Maven会从本地仓库寻找依赖包，如果没有找到，执行2。 从中央仓库寻找依赖包，如果没有找到执行3。 如果在pom.xml中自定义了远程仓库，那么就会在远程仓库寻找依赖包，如果仍然没有找到，那么Maven就会抛出异常。 配置步骤 配置本地仓库位置。 在conf文件夹下的settings.xml，将&lt;localRepository&gt;标签中的路径改为需要作为本地仓库的路径即可。 &lt;localRepository&gt;D:\apache-maven-3.6.0\RepMaven&lt;/localRepository&gt; 使用阿里云镜像。 同样编辑settings.xml，将&lt;mirrors&gt;标签中的内容修改为下面的即可。 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置远程仓库（非必要）。 如果需要配置Maven远程仓库，在pom.xml加入下面的代码即可。 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; Maven依赖机制传统方式下假如我们现在需要使用log4j。我们需要： 去互联网上下载log4j的jar包。 复制jar包到项目路径下。 手动将其设置为项目的依赖。 这样，不仅繁琐而且不利于我们的管理，万一log4j有新的版本需要升级，则需要重复一遍上面的所有步骤。 Maven方式下 知道log4j的Maven坐标。 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 将其添加到pom.xml文件中，按照上一节中所讲的顺序，开始下载jar包并储存到本地仓库。如果version标签被忽略，会自动下载最新的版本。 在使用Maven之后，我们唯一需要做的一件事就是找到我们所需要的Jar包的坐标。 可以去中心仓库，复制所需Jar包的的Maven坐标。 中心仓库网址：https://mvnrepository.com/ 在IDEA中新建Maven项目 配置Maven插件 在IDEA自带了Maven插件，可以更加方便地使用Maven。需要首先进行下面的配置： 配置Maven安装的路径、settings.xml的路径以及中心仓库的路径。这样就可以使用右侧工具栏中的插件进行一些方便的操作。 新建Maven项目。 在IDEA中中选择Maven项目，下一步。 配置GroupId，ArtifactId，Version。 GroupId：组织名称，一般将域名倒置。 ArtifactId：Maven构建的项目名。 Version：版本号，其中的SNAPSHOT意思为快照，说明该项目还不稳定，依然处于开发阶段。 添加依赖。 在pom.xml中，加入下面的语句： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这样，我们就将log4j的依赖包添加到了项目中。 Maven 插件 Maven 是一个执行插件的框架，每一个任务实际上是由插件完成的。Maven 插件通常用于： 创建 jar 文件 创建 war 文件 编译代码文件 进行代码单元测试 创建项目文档 创建项目报告 可以使用以下的语法执行插件： mvn [plugin-name]:[goal-name] 例如，使用插件将项目打成Jar包，可以在项目目录下运行如下命令： mvn jar:jar 常见插件 插件 描述 clean 构建之后清理目标文件。删除Target目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 IDEA中的Maven插件可以很方便地使用这些插件：]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—BlockingQueue]]></title>
    <url>%2F2019%2F11%2F09%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94BlockingQueue%2F</url>
    <content type="text"><![CDATA[BlockingQueue阻塞队列，所谓的阻塞是指，当队列已满时，会阻塞当前添加元素的线程，直到队列不满或者等到超时；当队列为空时，会阻塞当前获取元素的线程，直到队列不空或者等待超时。 核心方法压入元素 add(E e)：向队尾增加元素，设置成功返回true。如果使用了capacity-restricted队列，即限定了容量的队列，推荐使用offer()方法。 offer(E e)：向队尾增加元素，设置成功返回true，如果队列中没有多余的空间返回false。 put(E e)：向队尾增加元素，如果队列中没有多余的空间，该方法会一直阻塞。 弹出元素 poll()：获取并移除队首元素，如果队列为空，返回null。 take()：获取并移除队首元素，如果队列为空，该方法会一直阻塞。 peek()：获取但是并不移除队首元素，如果队列为空，返回null。 其他操作 contains(Obeject o)：判断队列中是否包含该元素。 int drainTo(Collection&lt;? super E&gt; c)：将队列转化为集合。 实现类 实现类 底层数据结构 是否有界 其他 ArrayBlockingQueue arrayList 有界 只有一把锁，入队高并发或出队高并发的情况下推荐使用 LinkedBlockingQueue linkedList 默认无界，可指定上限 两把锁，在入队与出队都高并发的情况下推荐使用 DelayQueue heap 无界 延迟期满时才能从中提取元素 PriorityBlockingQueue heap 无界 基于优先级的阻塞队列 SynchronousQueue 无 无界 无缓冲的阻塞队列，只能容纳一个元素，向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。 生产者消费者例子 Producer.java import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * @author liuergo * @description 生产者 * @date 2019-11-10 00:23 */public class Producer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Producer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int maxProductNum = 20; for (int i = 0; i &lt; maxProductNum; i++) &#123; try &#123; TimeUnit.SECONDS.sleep(1); //生产者生产 queue.put(i); System.out.println("Producer produced " + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Consumer.java import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * @author liuergo * @description 消费者 * @date 2019-11-10 00:24 */public class Consumer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Consumer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int maxConsumeTime = 20; for (int i = 0; i &lt; maxConsumeTime; i++) &#123; try &#123; TimeUnit.SECONDS.sleep(2); //消费者消费并拿到产品 int product = queue.take(); System.out.println("Consumer consumed " + product); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Tester.java import java.util.concurrent.*;/** * @author liuergo * @description 测试类 * @date 2019-11-10 13:26 */public class Tester &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); //使用线程池，避免显式地创建线程 ExecutorService service = Executors.newFixedThreadPool(2); service.execute(producer); service.execute(consumer); service.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TimeUnit类使用]]></title>
    <url>%2F2019%2F11%2F09%2FTimeUnit%E7%B1%BB%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[TimeUnit使用在学习线程池的时候发现ThreadPoolExecutor类中有个TimeUnit类的参数，此类是java.util.concurrent包下的类，记录一下该类的使用。 作用： 时间粒度转换 提供了可读性更好的线程暂停操作，通常用来代替Thread.sleep() 常用的几个时间粒度TimeUnit.DAYS //天TimeUnit.HOURS //小时TimeUnit.MINUTES //分钟TimeUnit.SECONDS //秒TimeUnit.MILLISECONDS //毫秒 时间粒度转换public long toMillis(long d) //转化成毫秒public long toSeconds(long d) //转化成秒public long toMinutes(long d) //转化成分钟public long toHours(long d) //转化成小时public long toDays(long d) //转化天 Example import java.util.concurrent.TimeUnit;/** * @paragram: ThreadPoolDemo * @description: TimeUnit类测试 * @auhor: liuergo * @date: 2019-11-09 14:08 */public class TimeUnitTest &#123; public static void main(String[] args) &#123; //将一天转换为24小时 System.out.println(TimeUnit.DAYS.toHours(1)); //将一小时转换为60分钟 System.out.println(TimeUnit.HOURS.toMinutes(1)); &#125;&#125;//输出结果//24//60 延时import java.sql.Time;import java.util.Timer;import java.util.concurrent.TimeUnit;/** * @paragram: ThreadPoolDemo * @description: TimeUnit类测试 * @auhor: liuergo * @date: 2019-11-09 14:08 */public class TimeUnitTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread.sleep(60 * 60 * 1000); //可读性不高 TimeUnit.HOURS.sleep(1); //同样是线程睡眠一小时，使用TimeUnit可读性会高很多。 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—观察者模式]]></title>
    <url>%2F2019%2F11%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式定义 观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 定义很明确，如果学过Android的童鞋肯定对Android中的广播不陌生，广播就是观察者模式的一种实现。 实现下面举个例子来说明观察者模式，某个明星在微博发布了一个动态，说他会唱跳rap篮球，然后所有关注他的粉丝都第一时间就收到了他的动态。这就是一个典型的观察者模式，粉丝作为观察者观察明星，明星一旦有状态改变就通知所有粉丝。 首先画出UML类图： Observer接口：在此接口中，只声明了一个update()方法，用来更新每个观察者的状态。 Ikun观察者类：此类实现了Observer接口，是一个实际的观察者，在我们例子中，一个Ikun对象就是Kunkun的粉丝之一。 Subject接口：在此接口中，声明了添加、删除以及通知观察者的方法。 Kunkun被观察者类：此类实现了Subject接口，是一个实际的被观察者，用一个ArrayList变量储存Observer，这样addObserver方法就是向ArrayList中add新元素，即为Kunkun添加一个新ikun；removeObserver就是remove某个元素，即为Kunkun踢出一个ikun；notify方法就是遍历所有的Observer，执行update方法，通知所有的ikun。 下面给出Java代码： Subject.java package top.liuergo.observer.simple;/** * @author liuergo * @description 被观察者 * @date 2019-11-21 09:59 */public interface Subject &#123; /** * 为该Subject添加观察者 * @param o 一个观察者对象 */ public void addObserver(Observer o); /** * 删除某个观察者 * @param o 一个观察者对象 */ public void removeObserver(Observer o); /** * 通知所有观察者 */ public void notifyAllObservers();&#125; Observer.java package top.liuergo.observer.simple;/** * @author liuergo * @description 观察者 * @date 2019-11-21 09:58 */public interface Observer &#123; /** * 更新观察者的状态 * @param message 状态 */ public void update(String message);&#125; Kunkun.java package top.liuergo.observer.pratical;import top.liuergo.observer.simple.Observer;import top.liuergo.observer.simple.Subject;import java.util.ArrayList;import java.util.List;/** * @author liuergo * @description 明星Kunkun * @date 2019-11-21 10:31 */public class Kunkun implements Subject &#123; private List&lt;Observer&gt; ikuns; private String message; public Kunkun() &#123; ikuns = new ArrayList&lt;&gt;(); &#125; @Override public void addObserver(Observer o) &#123; //为Kunkun增加一个ikun ikuns.add(o); &#125; @Override public void removeObserver(Observer o) &#123; //将一个ikun踢出粉丝群 ikuns.remove(o); &#125; @Override public void notifyAllObservers() &#123; for (Observer ikun : ikuns) &#123; ikun.update(this.message); &#125; &#125; public void sendMessage(String message) &#123; this.message = message; notifyAllObservers(); &#125;&#125; Ikun.java package top.liuergo.observer.pratical;import top.liuergo.observer.simple.Observer;/** * @author liuergo * @description Kunkun粉丝 * @date 2019-11-21 10:35 */public class Ikun implements Observer &#123; private String name; public Ikun(String name) &#123; this.name = name; &#125; @Override public void update(String message) &#123; //ikun更新自己的状态 System.out.println(name + "收到了消息：" + message); &#125;&#125; Tester.java package top.liuergo.observer.pratical;/** * @author liuergo * @description 测试类 * @date 2019-11-21 10:46 */public class Tester &#123; public static void main(String[] args) &#123; Ikun ikunA = new Ikun("张三"); Ikun ikunB = new Ikun("李四"); Kunkun kunkun = new Kunkun(); kunkun.addObserver(ikunA); kunkun.addObserver(ikunB); kunkun.sendMessage("我是练习时常两年半的偶像练习生，喜欢唱、跳、rap、篮球~"); &#125;&#125; 运行结果： 这样Kukun的两个ikun都收到了Kunkun发布的消息。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—线程池]]></title>
    <url>%2F2019%2F11%2F07%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池？使用线程池可以： 降低资源的消耗。线程本身是一种很宝贵的资源，创建线程和销毁线程会有CPU开销，是一个比较昂贵的操作。 提高任务执行的响应速度。使用线程池以后，不必等到线程创建完毕以后再执行。 提高线程的可管理性。可以对线程进行统一的分配。 线程池处理主要流程 Executor 我们如果要自定义一个线程池或者使用java自带的几种线程池，都要使用ThreadPoolExecutor类或者使用实现了该类的工厂方法。 可以看到，Executor接口是ThreadPoolExecutor的顶层接口。 在Executor接口中，只有一个execute()方法，必须传进来实现Runnable接口的线程，该方法可以将任务交给线程池创建线程并启动。（注意，该启动方式无法拿到返回值）。 void execute(Runnable command); ExecutorService该接口继承了Executor接口，该接口： 提供了用于关闭线程池的方法，shutdown方法和shutdownNow方法，关于这两个方法，shutdown方法会将线程池的状态置为SHUTDOWN，并且不再接收新任务，同时等待线程池中所有的任务执行完成之后再结束；shutdownNow方法会将线程池的状态置为STOP，然后对线程池中所有的线程执行interrupt方法。 提供了用于检查线程池状态的两个方法，isShutdown方法和isTerminated方法，两个方法分别可以检测线程池是否被关闭和是否被终止。 提供了submit和invokeAll可以执行实现Callable接口的线程，可以使用定义一个Future类型的对象获取到线程运行之后的返回值。 ThreadPoolExecutor构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); 该类的构造方法如上，下面一一解释每个参数的含义： corePoolSize：线程池中核心线程的数量，对于超出核心线程数量以外的线程，将其称作”idle threads”。 maximumPoolSize：线程池中的最大线程数量。 keepAliveTime：空闲时间，idle threads存活的时间。 unit：空闲时间的单位。 workQueue：线程池的等待队列。 threadFactory：线程工厂，可以用来创建新线程。 handler：拒绝策略，当线程池和队列都满了时候，这时需要对继续提交进来的任务做出处理。 下面着重分析workQueue、threadFactoy和handler三个参数。 workQueue等待队列是BlockingQueue类型的，理论上，只要是它的子类，都可以用来作为等待队列。 关于BlockingQueue可以移步：BlockingQueue threadFactorypublic interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; ThreadFactory是一个接口，只有一个方法，用来创建线程。 static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; 在ThreadPoolExecutor中，默认使用Executors.defaultThreadFactory()静态方法创建线程工厂，在此方法中新建了一个DefaultThreadFactory对象，上面是该对象的源码，可以看到，通过该方法创建的线程优先级均为NORM_PRIORITY，并且是非守护线程，使用&quot;pool-&quot; + poolNumber + &quot;-thread-&quot; + threadNumber来命名线程。所以，可以通过定制一个ThreadFactory的方式来达到统一命名我们线程池中的线程的目的。 handler线程池提供了4种决绝策略： AbortPolicy：直接抛出异常，这是默认策略。 CallerRunsPolicy：用调用者所在的线程来执行任务。 DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务。 DiscardPolicy：直接丢弃任务。 ExecutorsExecutors是一个线程池工厂，提供了很多工厂方法，提供了一些创建线程池的方法。 SingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 创建单一线程的线程池，这个线程池只有一个线程。多个任务被提交到该线程后，会被缓存到一个长度为Integer.MAX_VALUE的LinkedBlockingQueue队列中，此时的maximumPoolSize实际上是不起作用的，因为缓冲区基本不会满只有缓冲区满了才会执行判断maximumPoolSize的逻辑。如果只需要创建一个线程，也推荐使用该方法代替直接new Thread的方法创建线程，避免显式地创建线程。 FixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 创建固定长度的线程池，和上面的线程池类似，只不过可以接收更多任务。 CachedThreadPoolpublic static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 创建带缓存的线程池，使用该方式创建的线程核心线程数为0，最大线程数为Integer.MAX_VALUE，使用SynchronousQueue阻塞队列，此队列在BlockingQueue中有讲到，举个例子，如果此时来了一个线程A，由于当前corePoolSize为0，所以直接将其添加到队列中，由于该队列的特性，添加成功的前提是必须要有另一个线程已经在等待取出这个元素了，此时无可用线程，即没有等待取出线程A的线程，由于最大线程数为Integer.MAX_VALUE所以会创建一个新线程。此时如果又来了一个线程B，线程A仍然在运行中，同样无可用线程，会继续为B创建新线程。 此线程池是一个可根据需要创建新线程的线程池，如果现有线程没有可用的，则创建一个新线程并添加到池中，如果有被使用完但是还没销毁的线程，就复用该线程。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 ScheduledThreadPool创建定时调度的线程池，与上面三个线程池不同的是，该方法返回的是ScheduledExecutorService类型的线程池， 是一个能实现定时、周期性任务的线程池。 使用方法： BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);Producer producer = new Producer(queue);Consumer consumer = new Consumer(queue);ScheduledExecutorService service = Executors.newScheduledThreadPool(3);service.schedule(producer, 5, TimeUnit.SECONDS);service.execute(consumer); 上面的例子(此例子来源于BlockingQueue讲解)就可以实现producer线程5s后被启动。 自定义线程池对于上面的几种线程池，是不推荐直接使用的，一般还是经常会根据需要自定义线程池。自定义线程池需要结合使用背景，主要就是参数的选取。 最大线程数对于最大线程数的控制，最好不要使用无限制大小的最大线程数，可能引发OOM。 对于线程数量的确定可以参考下面的方案： 1、针对IO密集型的，当一个任务在执行IO操作的时候，其线程将被阻塞，这时，CPU就可以立即进行上下文切换，以便处理其他就绪线程。 在《Java Concurrency in Practice》一书中，给出了估算线程池大小的公式： $Nthreads=NcpuUcpu(1+w/c)$ 其中，Ncpu=CPU核心数，Ucpu=cpu使用率，0~1，W/C=等待时间与计算时间的比率。 阻塞耗时一般都是计算耗时几倍，假设阻塞耗时=计算耗时的情况下，$Nthreads=Ncpu*(1+1)=2Ncpu$，所以这种情况下，建议考虑2倍的CPU核心数做为线程数。 2、对于计算密集型的，阻塞耗时趋于0，即w/c趋于0，公式$Nthreads = Ncpu$。 自定义ThreadFactory在《阿里巴巴Java开发手册》中，有这样的一条规定： 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。创建线程池的时候请使用带ThreadFactory的构造函数，并且提供自定义ThreadFactory实现或者使用第三方实现。 所以我们在自定义一个线程池的时候，尽量指定有意义的线程名称。 类比DefaultThreadFactory，创建自定义的ThreadFactory。 import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;/** * @author liuergo * @description 自定义ThreadFactory * @date 2019-11-12 16:41 */public class MyThreadFactory implements ThreadFactory &#123; private static AtomicInteger poolNumber = new AtomicInteger(1); private AtomicInteger threadNumber = new AtomicInteger(1); private ThreadGroup group; private String namePrefix; public MyThreadFactory() &#123; this("my-pool"); &#125; public MyThreadFactory(String namePrefix) &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); this.namePrefix = namePrefix + "-" + poolNumber.getAndIncrement() + "-thread-"; &#125; @Override public Thread newThread(Runnable r) &#123; return new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); &#125;&#125; 这样，在新建线程池的时候就可以自定义线程池的名称了。 ThreadFactory factory = new MyThreadFactory("my-pool");ExecutorService service = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(1024), factory);service.execute(()-&gt; System.out.println(Thread.currentThread().getName()));service.shutdown();//输出//my-pool-1-thread-1 在《阿里巴巴Java开发手册》，提供了下面的方式新建一个ThreadFactory。 ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat("demo-pool-%d") .build();ExecutorService singleThreadPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));singleThreadPool.shutdown(); 其实上面的方式用到了Google的Guava SDK，其中ThreadFactoryBuilder是其自带的构造器模式方法。 个人推荐直接使用谷歌自带的轮子，毕竟不要重复造轮子嘛，当然学习过程中还是要自己写写Demo的。😁 程池监控可以通过一些方法来监控当前线程池的状态，在ThreadPoolExecutor中自带了一些方法： long getTaskCount()，获取已经执行或正在执行的任务数。 long getCompletedTaskCount()，获取已经执行的任务数。 int getLargestPoolSize()，获取线程池曾经创建过的最大线程数，根据这个参数，我们可以知道线程池是否满过。 int getPoolSize()，获取线程池线程数。 int getActiveCount()，获取活跃线程数（即正在执行任务的线程数）。 其次，ThreadPoolExecutor留给我们自行处理的方法有3个，它在ThreadPoolExecutor中为空实现（也就是什么都不做）。 protected void beforeExecute(Thread t, Runnable r) // 任务执行前被调用 protected void afterExecute(Runnable r, Throwable t) // 任务执行后被调用 protected void terminated() // 线程池结束后被调用 我们可以通过重写这三个方法来实现一些其他的功能。 ThreadFactory factory = new ThreadFactoryBuilder() .setNameFormat("my-pool-%d") .build();ExecutorService service = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(1024), factory) &#123; private String date = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss").format(new Date()); @Override protected void beforeExecute(Thread t, Runnable r) &#123; String date = formatter.format(new Date()); System.out.println(date + " " + Thread.currentThread().getName() + " 准备执行..."); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; String date = formatter.format(new Date()); System.out.println(date + " " + Thread.currentThread().getName() + " 执行完毕..."); &#125; @Override protected void terminated() &#123; String date = formatter.format(new Date()); System.out.println(date + " 线程池退出"); &#125;&#125;;service.execute(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);service.shutdown();//输出//2019-11-12 08:21:50 my-pool-0 准备执行...//2019-11-12 08:21:55 my-pool-0 执行完毕...//2019-11-12 08:21:55 线程池退出 上面的例子中就实现了记录线程池准备执行的时间、执行完毕的时间和线程池退出的时间。 获取处理结果和异常 线程池的处理结果、以及处理过程中的异常都被包装到Future中，并在调用Future.get()方法时获取，执行过程中的异常会被包装成ExecutionException 。 Future&lt;Object&gt; future = service.submit(() -&gt; &#123; throw new RuntimeException("exception in call");&#125;);try &#123; future.get();&#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace();&#125; 上述代码的运行结果如下： 总结 在Java中，线程是个比较昂贵的对象，我们应该避免显式地创建线程，尽量使用线程池创建线程。 关于线程池我们最需要掌握的就是线程池的处理流程和通过ThreadPoolExecutor构造方法自定义线程池，虽然Executors为我们提供了构造线程池的便捷方法，但是我们仍应该根据具体情况自定义线程池。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7配置Tomcat自启动]]></title>
    <url>%2F2019%2F10%2F30%2FCentOS7%E9%85%8D%E7%BD%AETomcat%E8%87%AA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[假设Tomcat安装目录为usr/local/tomcat 在和tomcat/bin目录平级的地方增加一个tomcat.pid文件。 在tomcat/bin目录下，增加setenv.sh配置，这样 catalina.sh启动的时候会调用，同时配置Java内存参数。 #add tomcat pid CATALINA_PID=&quot;$CATALINA_BASE/tomcat.pid&quot; #add java opts JAVA_OPTS=&quot;-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m 增加tomcat.service 在 /usr/lib/systemd/system 目录下增加tomcat.service文件。 [Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingEnvironment=&quot;JAVA_HOME=/usr/local/jdk1.8.0_191&quot;PIDFile=/usr/local/tomcat/tomcat.pidExecStart=/usr/local/tomcat/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 使用tomcat.service 配置开机启动 systemctl enable tomcat 启动tomcat systemctl start tomcat 停止tomcat systemctl stop tomcat 重启tomcat systemctl restart tomcat 因为配置pid，在启动的时候会再tomcat根目录生成tomcat.pid文件，停止之后删除。 同时tomcat在启动时候，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行。 多个tomcat可以配置在多个目录下，互不影响。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式—单例模式]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在上次的Android项目中，数据库对象以及netty连接的对象都使用过单例模式，但是对单例模式一直也是一知半解，借着刚在软件工程导论课上讲了单例模式，深入了解一下。 单例模式（singleton pattern）单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 所以在单例模式中，最重要的一点就是保证其不会被实例化多次，保证其唯一性。 单例模式在Java中主要有以下几个实现方式： 懒汉式，线程不安全 饿汉式，线程安全 双重校验锁（DCL） 静态内部类 枚举 懒汉式//懒汉式(线程不安全)public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 此方式是懒加载的，也就是说，只有当调用getInstance()方法且当前类从未被实例化过，当前类才会被实例化，另外，此方法不适用于多线程，是线程不安全的。 懒汉式（线程安全方式）//懒汉式(线程不安全)public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 将getInstance方法改为同步方法就可以保证线程安全了，但是由于同步代码的执行效率是很低的，所以，此方法不是很推荐。 饿汉式//饿汉式(线程安全)public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton () &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 此方法在类初始化的时候就完成了实例化，线程不安全的问题只会在首次实例化对象的时候才会发生，所以这种方式并不会产生线程不安全的问题。 双重校验锁(DCL) JDK1.5以后可以使用 //DCL(线程安全)public class Singleton &#123; private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 此方法有两个需要注意的地方： 双重检查，相对于懒汉式（线程安全）方式，DCL方式在同步代码块外面又加了一个判断，这样既保证了线程安全，而且保证了只有在单例未被实例化的时候synchronized才会生效，保证了效率 volatile关键字的使用。可以看到上面基本上就可以保证线程安全了，但是为什么还要使用volatile关键字呢？在volatile关键字中，介绍过volatile关键字可以保证变量的有序性和可见性，在此处，使用volatile关键字就是为了保证有序性。 volatile关键字保证有序性 今天上软件工程导论的时候，老师讲到了单例模式，并且举到了DCL的例子，但是只字不提volatile关键字…… 导致可能保证不了有序性的操作是下面的一个语句： singleton = new Singleton(); 上面的一句话并不是一个原子操作，它可以被分解成以下几个语句： memory = allocate(); //1：分配对象的内存空间initInstance(memory); //2：初始化对象singleton = memory; //3：设置singleton指向刚分配的内存地址 可以看出上面的三个操作中，操作2是依赖于操作1的，而操作3并不依赖于操作2，因此，JVM就有可能对其进行重排序操作，重排序之后，上面的操作会变成下面的样子： memory = allocate(); //1：分配对象的内存空间singleton = memory; //3：设置singleton指向刚分配的内存地址（此时的对象还没有被初始化）initInstance(memory); //2：初始化对象 可以看到，如果在线程A中经过重排序之后，操作3和操作2对调了，这样在初始化对象之前，instance首先指向了一个未被初始化的内存空间，如果这时有另一个线程B访问，此时的singleton已经不是null了，会返回一个单例，这样就有可能得到”半个”单例（未完成初始化）。如下表： 线程A 线程B 分配对象的内存空间 singleton 指向一个未被初始化的内存空间 判断 singleton 是否为null 由于singleton不为null，访问引用对象 初始化对象 访问引用对象 加上volatile关键字就可以防止JVM对其进行重排序了，就可以解决这种隐患。 静态内部类//静态内部类public class Singleton &#123; private static class SingletonHolder &#123; public static Singleton instance = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 关于内部类可以看此博客Java内部类。 通过静态内部类实现，既可以实现懒汉式的懒加载又可以实现饿汉式的线程安全。 此方法同样是使用了类加载机制保证初始化单例的只有一个线程，但是此方式在Singleton类被初始化之后，instance并不会被初始化，只有当显式地调用getInstance方法之后，才会实例化instance。所以此方法可以保证懒加载。 枚举类 JDK1.5以后可以使用 public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 而且也不能通过反射来调用私有的构造方法。 总结在一般情况下，使用饿汉式就可以了，如果明确要求懒加载，可以使用静态内部类的方法，了解DCL可以帮助我们更好的理解synchronized关键字以及volatile关键字的作用，最后一种枚举类方式虽然用的少，但是还是很推荐使用该方式（毕竟是Effective Java的作者推荐的写法，听大神说的就对了👍）。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—volatile关键字]]></title>
    <url>%2F2019%2F10%2F29%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java并发编程三大特性在Java并发编程中，有三个概念：1. 原子性 2. 可见性 3. 有序性。 原子性（Atomicity）原子性指一个操作是不可中断的，要么全部执行成功要么全部执行失败，在数据库的事务中也有这个性质。 例如，a++，对于一个共享变量a的操作实际上可以分为三个步骤：1. 读取变量a的值；2. 将a的值+1；3. 将值重新赋值给a。此操作是可分割的，所以这并不是一个原子操作。像这样的操作，如果在多线程下，就有可能会产生异常，所以需要使用synchronized或者Lock来保证代码的原子性。 可见性（Visibility）可见性就是指当一个线程修改了共享变量的值，对于另外一个线程来说是可见的，其他线程能够立即得知这个修改。 Java内存模型中，线程通信是通过共享内存的方式进行的，为了加快线程通信的速度，线程一般是不会直接操作内存的，而是操作当前线程内的一个副本。这样，如果线程对变量的操作没有刷新内存的话，仅仅改变了当前线程中的副本，对于其他线程来说，就是不可见的。 volatile关键字的作用就是保证了变量的可见性，volatile变量可以保证对它的修改可以立即被刷新到主存，而当其他线程需要读取该值的时候，会从内存中去读取新的值。 另外，synchronized同样具有可见性，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。 有序性（Ordering）指程序执行的顺序应该按照代码的先后顺序执行。在Java内存模型中，是允许编译器和处理器对指令进行重排序的，但是重排序不会影响到单线程程序的运行，在单线程程序中，JVM重排序的时候会保证程序的最终执行结果和顺序执行代码的结果是一样的。但是对于多线程程序来说，这就不一定了。 例如下面的例子： //Thread 0context = loadContext();inited = true;//Thread 1while (!inited) &#123; sleep;&#125;doSomethingwithconfig(context); 在这个例子中，如果Thread0出现了重排序： inited = true;context = loadContext(); 在这种情况下，线程B就有可能拿到一个未初始化的content去执行其他方法，从而引起错误。 为了防止重排序，需要使用volatile关键字，它可以保证对变量的操作是不会被重排序的。 内心OS：要是真出了这样的BUG，不清楚有序性还真不知道咋改… volatile保证可见性public class VolatileDemo &#123; private static boolean isThreadRunning = true; public static void main(String[] args) throws InterruptedException &#123; Thread thread0 = new Thread(() -&gt; &#123; System.out.println("Thread0开始"); while (isThreadRunning) &#123; &#125; System.out.println("Thread0结束"); &#125;); Thread thread1 = new Thread(() -&gt; &#123; System.out.println("isThreadRunning被修改..."); isThreadRunning = false; &#125;); thread0.start(); Thread.sleep(2000); thread1.start(); &#125;&#125; 运行结果： 可以看到，程序陷入了死循环，虽然isThreadRunning的值被Thread1修改了，然而Thread0并没有接收到修改的值，这就是因为变量值没有被写到主存，导致本地内存中的值一直为true。 解决方法就是为isThreadRunning变量加上volatile关键字。 private volatile static boolean isThreadRunning = true; 再次运行程序，现在就不会导致死循环了。 volatile与原子性volitile关键字是不能保证原子性的，看下面一个例子： public class VolatileDemo &#123; private static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; count++; System.out.println(count); &#125; &#125;).start(); &#125; &#125;&#125; 从下面的输出结果可以看出数据产生了异常。 如果将count++操作改为sychronized操作就可以保证输出结果的正确了。 synchronized (lock) &#123; count++;&#125; 总结 volitile关键字是synchrnized的轻量级实现，volitile性能优于synchrnized。 volitile可以保证数据的可见性和有序性，而synchroized和Lock三种特性都可以保证。ti]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—线程通讯的方式]]></title>
    <url>%2F2019%2F10%2F28%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[线程通讯线程通讯的目的是使线程之间能够互相发送信号。 另一方面，线程通信使线程能够等待其他线程的信号。 线程通讯的方式： wait()/notify()机制 Condition类 ThreadLocal方式 管道方式 wait()/notify()机制wait和notify还有notifyAll方法是Object类的三个方法。 调用wait方法，相当于让当前线程释放锁，然后进入等待状态。 notify()方法主要的作用就是此方法可以唤醒一个正在等待此对象的锁释放的线程，如果所有线程都在此对象上等待，则会选择其中一个唤醒。而notifyAll()方法的作用就是将所有等待此对象的锁的线程都唤醒。 在wait方法中有这样的一句话The current thread must own this object&#39;s monitor.，也就是说使用wait方法的前提是该线程必须拥有这个对象的锁，因此调用wait方法时必须存在synchronized方法或者synchronized代码块，如果当前线程没有拥有锁的对象，就会抛出IllegalMonitorStateException。 生产者消费者模型 public class Tester &#123; Object lock = new Object(); int count = 0; public static void main(String[] args) throws Exception &#123; Tester tester = new Tester(); Thread thread = new Thread(tester.new Producer("producer 0")); Thread thread0 = new Thread(tester.new Producer("producer 1")); Thread thread1 = new Thread(tester.new Consumer("consumer 0")); thread.start(); thread0.start(); thread1.start(); &#125; class Producer implements Runnable &#123; private String name; public Producer (String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; while (count == 5) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " produced.."); count++; System.out.println("Current buffer size:" + count); lock.notifyAll(); &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; while (count == 0) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " consumed.."); count--; System.out.println("Current buffer size:" + count); lock.notifyAll(); &#125; &#125; &#125; &#125;&#125; 上面就是一个生产者消费者模型的例子，当缓冲区满了的时候生产者会停止生产，这时，如果消费者消费了一个产品，生产者就会被唤醒；当缓冲区为空的时候消费者会停止消费，这时，如果生产者了一个产品，消费者就会被唤醒。 ConditionCondition是可以用来代替传统的wait/notify方式，此方式更加安全和高效，比较推荐使用该方法。 Condition是一个接口，其基本方法有await()、signal()以及signalAll()，分别对应Object类的wait()、notify()、notifyAll()。 有关方法必须在lock和unlock之间使用。 下面是Condition类实现生产者消费者的例子： public class Tester &#123; Lock lock = new ReentrantLock(); //可重入锁，并发包会讲到 Condition condition = lock.newCondition(); int count = 0; public static void main(String[] args) throws Exception &#123; Tester tester = new Tester(); Thread thread = new Thread(tester.new Producer("producer 0")); Thread thread0 = new Thread(tester.new Producer("producer 1")); Thread thread1 = new Thread(tester.new Consumer("consumer 0")); thread.start(); thread0.start(); thread1.start(); &#125; class Producer implements Runnable &#123; private String name; public Producer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.lock(); while (count == 5) &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " produced.."); count++; System.out.println("Current buffer size:" + count); condition.signalAll(); lock.unlock(); &#125; &#125; &#125; class Consumer implements Runnable &#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.lock(); while (count == 0) &#123; try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + " consumed.."); count--; System.out.println("Current buffer size:" + count); condition.signalAll(); lock.unlock(); &#125; &#125; &#125;&#125; 管道方式之前在操作系统这门课中也接触到过这种方式只不过是C版本的，现在也当再次重温一下。此方式是利用管道流在不同线程之间直接传输数据，一个线程向管道中写入数据，另一个线程从管道中读数据。 public class PipedStreamDemo &#123; public static void main(String[] args) throws IOException &#123; PipedOutputStream outputStream = new PipedOutputStream(); PipedInputStream inputStream = new PipedInputStream(); outputStream.connect(inputStream); ThreadWrite threadWrite = new ThreadWrite(outputStream); ThreadRead threadRead = new ThreadRead(inputStream); Thread thread = new Thread(threadRead); Thread thread1 = new Thread(threadWrite); thread.start(); thread1.start(); &#125;&#125;class ThreadWrite implements Runnable&#123; PipedOutputStream pipedOutputStream; public ThreadWrite(PipedOutputStream pipedOutputStream) &#123; this.pipedOutputStream = pipedOutputStream; &#125; public void write(PipedOutputStream pipedOutputStream) throws IOException &#123; System.out.println("write:"); for (int i = 0; i &lt; 100; i++) &#123; String data = "" + i; pipedOutputStream.write(data.getBytes()); System.out.println(data); &#125; pipedOutputStream.close(); &#125; @Override public void run() &#123; try &#123; this.write(pipedOutputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadRead implements Runnable&#123; PipedInputStream pipedInputStream; public ThreadRead(PipedInputStream pipedInputStream) &#123; this.pipedInputStream = pipedInputStream; &#125; public void read(PipedInputStream pipedInputStream) throws IOException &#123; System.out.println("read:"); byte[] bytes = new byte[1024]; int readLength = pipedInputStream.read(bytes); while (readLength != -1) &#123; String newData = new String(bytes, 0, readLength); System.out.print(newData); readLength = pipedInputStream.read(bytes); &#125; System.out.println(); pipedInputStream.close(); &#125; @Override public void run() &#123; try &#123; this.read(this.pipedInputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService接口开发]]></title>
    <url>%2F2019%2F10%2F26%2FWebService%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近有一个项目可能需要用到WebService技术，提前学习一下。 WebService WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 相关概念XML,SOAP和WSDL就是构成WebService平台的三大技术。 XML：扩展性标记语言 （Extensible Markup Language） 用于传输格式化的数据，是Web服务的基础。 SOAP：简单对象访问协议（Simple Object Access Protocol，SOAP）SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。 SOAP协议 = http协议 + XML数据格式 XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 WSDL：（网络服务描述语言，Web Services Description Language）WSDL是一门基于 XML 的语言，用于描述 Web Services 以及如何对它们进行访问。 在idea中新建WebServices项目编写服务端 创建新项目，选择WebServices，Version选择Axis。 在这里，我们新建一个测试类，为了展示如何将一个新建的类添加进来。 public class Test &#123; public String sayHelloWorldFrom(String from) &#123; String result = "Hello, world, from " + from; System.out.println(result); return result; &#125;&#125; 打开web-&gt;WEB-INF-&gt;server-config.wsdd文件，复制粘贴一份下面的代码，将下面两个部分的代码更换为新建的Test类名称。 这时，返回Test类可以发现Test类旁边多了两个🌏的标志，这样就配置成功了。 生成wsdl文件，新版idea需要先下载WebService插件，之后Tools-&gt;WebServices-&gt;Generate Wsdl Java Code… 这里需要先编译一下，否则报ClassNotFoundException，说明刚刚新建的类没有生成.class文件。 配置Tomcat（省略）。 配置Atifacts，一开始会报缺少依赖的错，Fix一下就好。 运行之后，默认跳转到了下面的页面，只需要在URL最后加上services就可以。 单击上面某个wsdl就可以跳转到下面的页面。 编写客户端 新建项目，选择WebService Client，Version选择Apache Axis。 导入wsdl文件，选择wsdl存放的位置，生成代码。 修改自动生产的测试类代码。 package example;import test.TestServiceLocator;public class HelloWorldClient &#123; public static void main(String[] argv) &#123; try &#123; TestServiceLocator locator = new TestServiceLocator(); System.out.println(locator.getTest().sayHelloWorldFrom("ergo")); &#125; catch (javax.xml.rpc.ServiceException ex) &#123; ex.printStackTrace(); &#125; catch (java.rmi.RemoteException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 在控制台可以看到输出的结果。 Java调用WebServic接口的方式还有很多，这里就不一一介绍了。 WebService、REST、RESTful？首先简单介绍一下这三个名词，WebService，基于SOAP协议的服务，上面已经介绍了； REST：一种软件架构风格，一种面向资源的架构，其核心操作只有 GET,PUT,POST,DELETE。 RESTful： 遵守了rest风格的web服务 ，是一个形容词。 RESTful详解 SOAP WebService和RestFul 的区别]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—synchronized关键字]]></title>
    <url>%2F2019%2F10%2F22%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94synchonized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[线程安全与共享资源在《Java并发编程实战》书中对线程安全给出了下面的定义： 当多个线程访问某个类时，这个类始终都能表现处正确的行为 下面介绍一下各种变量的线程安全性。 基础类型局部变量 基础类型的局部变量储存在栈内存中，也就是说，局部变量永远不会被多个线程共享。所以说所有的基础类型的局部变量都是线程安全的。 引用类型局部变量 由于引用类型变量的属性都储存在堆中，但是在一般情况下，别的线程是获取不到该对象的，只要该对象不能够被其他方法获取到，那么他就是线程安全的。 成员变量 由于一个对象的成员是储存在堆内存上的，如果有多个线程同时更新同一个对象的同一个成员变量，那么这种情况就不是线程安全的。 需要说明的是，只有多个线程同时访问同一个资源而且多个线程都对此资源进行了些写操作，才会产生线程安全的问题，多个线程同时对同一个资源进行读操作时不会产生线程安全问题的。 Java同步块Java同步块（synchronized block）用来可以实现同步，可以通过这种方式来有效地避免线程安全问题的出现。 synchronized关键字三种使用方式 修饰实例方法，为当前实例加锁，需要拿到当前实例的锁。 修饰静态方法，为当前类对象加锁，需要获得当前类对象的锁。 修饰代码块，指定加锁对象。 修饰实例方法看一个例子： public class Tester &#123; public static void main(String[] args) throws Exception &#123; Example example = new Example(); MyThread myThread = new MyThread(example); MyThread myThread1 = new MyThread(example); myThread.start(); myThread1.start(); &#125;&#125;class Example &#123; public synchronized void execute() throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); Thread.sleep(2000); &#125; &#125;&#125;class MyThread extends Thread &#123; private Example example; MyThread(Example example) &#123; this.example = example; &#125; @Override public void run() &#123; try &#123; example.execute(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在上面的代码中，为execute方法加上synchronized关键字之后，程序会先输出09，之后再输出一次09；如果去掉synchronized关键字之后，两个线程会同时会执行execute方法。 这说明，如果一个方法加上了synchronized关键字，那么该方法就是一个同步方法，如果一个对象有synchronized方法，某一时刻某个线程已经进入到了synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。 现在将每个MyThread构造方法的参数改为两个对象，再次运行，此时即使加上了synchronized关键字，execute方法仍然是同时执行的。这是因为Java中每个对象都有一个monitor，当一个线程去访问某个对象的synchronized方法时，会将该对象上锁，这时，任何一个线程都无法去访问该对象的同步方法了，直到此方法执行完毕或者抛出异常，该对象就会把锁释放，这时其他的线程才可以访问该方法。 MyThread myThread = new MyThread(new Example());MyThread myThread1 = new MyThread(new Example());myThread.start();myThread1.start(); 修饰静态方法当synchronized作用于静态方法时，由于静态方法并不是属于对象，而是属于类，其锁是当前类的Class对象锁，而访问非静态的synchronized方法时，是使用的当前实例的对象锁。 看一个例子： public class Tester &#123; public static void main(String[] args) throws Exception &#123; MyThread myThread = new MyThread(new Example()); MyThread myThread1 = new MyThread(new Example()); myThread.start(); myThread1.start(); synchronized (Tester.class) &#123; &#125; &#125;&#125;class Example &#123; public synchronized static void execute() throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125;class MyThread extends Thread &#123; private Example example; MyThread(Example example) &#123; this.example = example; &#125; @Override public void run() &#123; try &#123; Example.execute(); &#125; catch (InterruptedException e) &#123; e.printSzaitackTrace(); &#125; &#125;&#125; 在synchronized修饰非静态方法时，如果对于不同的实例对象来说，拿到的锁也是不同的，但是对于static方法来说，即使对不同的实例操作，也是拿到的一个Class对象锁，所以对于上面的代码中，即使有两个不同的线程传入了两个不同的Example对象，但是两个线程依然会互相制约，必须先执行完一个再执行另外一个。 修饰代码块synchronized代码块写法： synchronized (object) &#123; &#125; 表示再某个线程在执行的时候会将object对象上锁（该对象可以任意指定）。 在第一种修饰实例方法给出的代码中，将synchronized方法修改为synchronized代码块。 public void execute() throws InterruptedException &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125; 上面传入的对象是Example对象本身，这时，该锁起到的作用和synchronized实例方法的作用是相同的。如果改为synchronized(new Object())，这时由于锁是针对Object对象的一个实例的，所以，该锁就不会起到相应的作用了。 在第二种修饰静态方法给出的代码中，同样将synchronized静态方法修改为synchronized代码块. public void execute() throws InterruptedException &#123; synchronized (Exmple.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("exe" + i); Thread.sleep(2000); &#125; &#125;&#125; 上面传入的对象是Example的Class对象，这时，该锁起到的作用和synchronized实例方法的作用是相同的。同样的，如果传入其他的对象，该锁就不会起到相应的作用了。]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程—创建线程的方式]]></title>
    <url>%2F2019%2F10%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多线程编程简单介绍几种创建线程的方法 线程的创建方法 继承Thread类，重写run方法；使用匿名内部类。 //继承Thread类，重写run方法class Thread0 extends Thread &#123; @Override public void run() &#123; super.run(); //do something... &#125;&#125;//匿名内部类Thread thread0 = new Thread() &#123; @Override public void run() &#123; super.run(); //do something... &#125;&#125;;class Test &#123; Thread0 thread = new Thread0(); thread.start();&#125; 实现Runnable接口，实现run方法；使用匿名内部类。 //实现Runnable接口，实现run方法class Thread0 implements Runnable &#123; @Override public void run() &#123; //do somrthing... &#125;&#125;//匿名内部类Thread thread0 = new Thread(new Runnable() &#123; @Override public void run() &#123; //do something... &#125;&#125;);class Test &#123; Thread thread = new Thread(new Thread0()); thread.start();&#125; Callable接口除了以上两种方式创建线程以外，还可以通过实现Callable接口并实现call方法的方式实现多线程，利用这种方式，执行完一个线程之后可以通过一个FutureTask对象获取返回值，而Runnable是不能获取到返回值的。并且call方法可以抛出异常，而run方法不可以。 看一个例子： class CallableThread implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); return "haha"; &#125;&#125;public class Tester &#123; public static void main(String[] args) throws Exception &#123; CallableThread thread = new CallableThread(); //使用FutureTask类接收CallableThread返回的数据 FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(thread); new Thread(task).start(); System.out.println(task.get()); &#125;&#125; 关于run和start方法虽然我们定义一个线程是重写或者实现的run方法，但是启动一个线程需要调用start方法，如果直接调用run方法，其实跟调用一个类的普通方法是一样的，run方法的执行还是处在调用该方法的线程中；调用start方法以后，虚拟机才会创建一个新的线程并且调用run方法。（同样地，继承Callable接口实现线程也不可以直接调用call方法） Thread thread0 = new Thread(() -&gt; System.out.println("Current thread: " + Thread.currentThread().getName()));thread0.start();thread0.run();----Output----Current thread: mainCurrent thread: Thread-0 看上面的代码段，调用start方法之后输出新创建的线程Thread-0，调用run方法之后输出的是依然是主线程main。]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的深拷贝和浅拷贝]]></title>
    <url>%2F2019%2F10%2F20%2FJava%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在之前做项目的时候，同组的人因为深拷贝和浅拷贝的问题产生过BUG，当时不是自己负责的部分，没对这个问题做过深入的了解，今天深入学习一下👻 在介绍深拷贝和浅拷贝之前，先温习几个概念。 数据类型Java中的数据类型有两种： 基本类型：粒度最小的数据类型。主要包括 4种整数类型：int、short、long、byte 2种浮点数类型：float、double 1种字符类型：char 1种布尔类型：boolean 引用类型：也叫做句柄，实际存放的应该是一个地址，地址指向实际内容。主要包括： 类 接口 数组 数据如何在内存中储存JVM在程序运行的时候会将内存划分为四个区域： 堆 栈 静态方法区 常量区 针对第一节的数据类型，下面分为基本数据类型的局部变量、基本数据类型的成员变量、引用类型变量来讲解。 基本数据类型的局部变量基本数据类型的局部变量的储存形式如下图所示： 方法中的基本类型的局部变量，都是储存虚拟机的堆内存中的，数据本身的值就是储存在栈内存中。每次给一个新变量赋值的时候，JVM首先会检验内存中有无该数据，如果有，就直接将这个变量指向该数据，没有的话就开辟一个新的内存空间存放数据，然后将变量指向该数据。 int age = 50;int weight = 50;int height = 100; 看上面的代码段，三个变量都是某个方法中的局部变量，当执行int age = 50的时候，首先会定义变量，存入变量表中，然后去栈中找是否存在值为50的内容，并将age变量指向50。当执行int weight = 50时，会在栈中找到50，直接将weight指向50。当方法执行完毕以后，方法局部变量会被JVM的垃圾回收机制回收。 基本数据类型的成员变量和引用类型变量前面提到，除了基本数据类型，还有一种是引用数据类型，对于引用数据类型在内存中的存储形式如下图所示。 public class Student &#123; private String name; private int age; private int grade;&#125; 上面是一个Student类，如果我们不重写toString方法，直接输出一个实例化的对象的话，会得到这样的输出： Student@1b6d3586，其实这就是Student类的地址。 所以，对于引用数据类型来说，引用数据类型只储存一个在堆内存中的地址，而成员变量和方法被储存在堆内存中。 深拷贝和浅拷贝概念前面说了这么多，现在步入正题，首先介绍深拷贝和浅拷贝的概念。 在Java中使用 “=” 做赋值操作时，对于基本数据类型，会直接将值直接赋值给变量，而对于引用数据类型来说，会将其引用赋值给另一个对象。 浅拷贝 浅拷贝会创建一个新的对象，这个对象拥有被拷贝对象的一个精确的副本。在该类的成员变量中，对于基本数据类型，拷贝的就是其值；对于引用数据类型，拷贝的就是其内存地址。如果其中一个对象改变了这个引用数据类型的变量的数据，相应地，另一个对象地该引用数据类型地数据也会随之改变。 如下图，Student类有两个成员变量，一个Schoole类成员变量，一个int类型的成员变量，Student类有两两个实例，student1是对student0的浅拷贝的对象。对于引用类型的School来说，两个对象都储存的是School对象的地址，所以说，如果有其中一个对象的School对象的内容发生了改变，另一个对象也会发生改变；对于基本类型的成员变量来说，两个对象都是直接储存的age的值，双方互不干涉。 深拷贝 深拷贝不仅会为拷贝新建对象，也会对该对象中任何的引用类型变量建立新的对象，这样，拷贝对象和原对象就是两个完全相同的对象，两者各自的成员变量也互不受影响了。 实现浅拷贝先看一个例子（不是浅拷贝）。 public class Tester &#123; public static void main(String[] args) &#123; int age = 10; int age1 = 20; String name = "aaa"; String name1 = "bbb"; Student student = new Student(); student.setAge(age); student.setName(name); Student student1 = student; student.setAge(age1); student.setName(name1); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, name='bbb'&#125;Student&#123;age=20, name='bbb'&#125; 上面代码直接使用了 “=” 对对象进行拷贝，发现，无论是基本类型还是引用类型的数据，只要其中一个对象的值被改变，另一个对象的数据也随之改变。 其实Student student1 = student;这一句代码，相当于只是将student的地址赋值给了student1，两个对象指向一个地址，所有数据都是一起共享的。 而实现浅拷贝之后，创建的新对象会单独开辟一个内存空间有自己的地址，这样对于基本类型的数据来说，每个对象都有自己的数据，而对于引用类型的数据来说，新对象是拷贝的引用类型的地址，所以两个对象是共享该成员变量的。 public class School implements Cloneable &#123; String name; public School(String name) &#123; this.name = name; &#125; ... @Override public String toString() &#123; return "School&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; public class Student implements Cloneable&#123; private int age; private School school; public Student(int age, School school) &#123; this.age = age; this.school = school; &#125; ... @Override public String toString() &#123; return "Student&#123;" + "age=" + age + ", school=" + school + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; public class Tester &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student(10, new School("QUST")); Student student1 = (Student) student.clone(); student.setAge(20); student.getSchool().setName("THU"); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, school=School&#123;name='THU'&#125;&#125;Student&#123;age=10, school=School&#123;name='THU'&#125;&#125; 以上就是一个实现浅拷贝的例子，首先，需要拷贝的类要实现Cloneable接口（此接口是个标识性接口，接口内无任何方法），重写clone方法，在拷贝对象的时候，使用Student student = (Student) student.clone()，这样就实现了浅拷贝。从测试类的输出可以看出来，修改原对象的基本数据类型的成员变量时，拷贝对象并没有收到影响，而修改原对象引用类型成员变量School的属性时，拷贝类型也受到了影响。 实现深拷贝public class School implements Cloneable&#123; String name; public School(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "School&#123;" + "name='" + name + '\'' + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; public class Student implements Cloneable&#123; private int age; private School school; public Student(int age, School school) &#123; this.age = age; this.school = school; &#125; @Override public String toString() &#123; return "Student&#123;" + "age=" + age + ", school=" + school + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Student student = (Student) super.clone(); student.school = (School) this.school.clone(); return student; &#125;&#125; public class Tester &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student(10, new School("QUST")); Student student1 = (Student) student.clone(); student.setAge(20); student.getSchool().setName("THU"); System.out.println(student); System.out.println(student1); &#125;&#125;----Output----Student&#123;age=20, school=School&#123;name='THU'&#125;&#125;Student&#123;age=10, school=School&#123;name='QUST'&#125;&#125; 实现深拷贝的方法就是将类中的引用类型变量也进行拷贝，引用类型所在的类实现Cloneable接口，重写clone方法。这样就可以实现深拷贝了。 还有一种实现深拷贝的方式，就是通过序列化实现可以查看Java序列化。 总结 需要拷贝对象的时候，如果一个对象内部数据类型只有基本类型，那么就可以使用浅拷贝，如果一个对象内部还有引用数据类型，就需要使用深拷贝。 虽然深拷贝和浅拷贝可能用到的不会很多，但是对于理解JVM内部内存还是很有帮助的👅]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到Github文件夹大小写问题]]></title>
    <url>%2F2019%2F10%2F19%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0Github%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述 今天写完博客上传github时，发现algorithm标签404了，上Github仓库一看发现tags文件夹下的algorithm是大写的Algorithm，访问tags/Algorithm，可以正常显示 原因 查询资料发现，git是默认不区分大小写的，之前hexo生成了一个Algorithm文件夹，后来将文件夹的名称改为了algorithm，然而在Github上是不会将大写改为小写的。 解决方法 进入.git文件夹，将config文件的 ignorecase=true 改为 ignorecase=false。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2019%2F10%2F19%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类所谓内部类就是在一个类的内部再定义一个类，之前自己写代码的时候一直也没用过这种方式，系统地学习一下内部类。 /** * @paragram: InnerClassDemo * @description: 内部类 * @auhor: liuergo * @date: 2019-10-19 16:30 */public class OuterClass&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; class InnerClass&#123; public InnerClass ()&#123; name = "Jack"; age = 20; &#125; &#125;&#125; 上面就是内部类的一个简单的例子。 为什么要使用内部类 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 上面是《Thinking in Java》中的一句话，我们知道，Java中是没有多继承的，所以才出现了接口来解决Java多继承的问题，但是如果使用了内部类，就可以使我们的类继承多个类。 成员内部类最普通的内部类，将内部类作为外部类的一个成员，跟成员变量各种方法是并列的。 public class OuterClass&#123; private String name; private int age; public class InnerClass&#123; public InnerClass ()&#123; name = "Jack"; age = 20; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); &#125;&#125; 实例化一个内部类需要使用外部类的对象.new来创建内部类，在内部类中，是可以随便访问外部类的成员变量的;外部类是不可以随便访问内部类的。 局部内部类在方法中定义的内部类，这时的内部类就不属于外部类的成员了，局部内部类可以访问当前代码块中的final关键字修饰的局部变量以及外部类的成员变量。 public class OuterClass&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void function() &#123; final int i = 0; class InnerClass &#123; private String innerName; void InnerFun() &#123; System.out.println(name); //直接访问外部类的变量 System.out.println(i); //访问final类型的局部变量 System.out.println(this.innerName); //使用this.成员变量访问的是内部类的成员变量 System.out.println(OuterClass.this.name); //使用外部类名.this.成员变量的方式访问成员变量 &#125; &#125; &#125;&#125; 静态内部类在static关键字一节中，提到static关键字可以修饰变量、方法、代码块，其实static还可以修饰内部类，在静态内部类中，是不保留对外部类的引用的，这就意味着，静态内部类的创建不需要依赖于外部类。这样，静态内部类也就只能访问静态变量和静态方法。外部类和内部类其实是没有关联的。 public class OuterClass&#123; private String name; private int age; static int num = 0; static class InnerClass&#123; private String innerName; public InnerClass ()&#123; System.out.println(num); //只能访问static变量 &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); InnerClass innerClass = new InnerClass(); //创建实例不依赖外部类 &#125;&#125; 匿名内部类 匿名内部类这一语法适用于创建一次性使用的类。 在Android编程中，经常会用到点击事件，这就是一个匿名内部类的例子。 btnClick.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //do something &#125;&#125;); 可以看到，在上面的例子中，new了一个View.OnClickListener对象，然而这个对象是没有名字的，这就是匿名内部类的特点。 定义匿名内部类下面是官方文档中给出的一个匿名内部类的例子： public class HelloWorldAnonymousClasses &#123; interface HelloWorld &#123; public void greet(); public void greetSomeone(String someone); &#125; public void sayHello() &#123; //实现HelloWorld接口的内部类 class EnglishGreeting implements HelloWorld &#123; String name = "world"; public void greet() &#123; greetSomeone("world"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Hello " + name); &#125; &#125; HelloWorld englishGreeting = new EnglishGreeting(); //匿名类实现HelloWorld接口 HelloWorld frenchGreeting = new HelloWorld() &#123; String name = "tout le monde"; public void greet() &#123; greetSomeone("tout le monde"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Salut " + name); &#125; &#125;; //匿名类实现HelloWorld接口 HelloWorld spanishGreeting = new HelloWorld() &#123; String name = "mundo"; public void greet() &#123; greetSomeone("mundo"); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println("Hola, " + name); &#125; &#125;; englishGreeting.greet(); frenchGreeting.greetSomeone("Fred"); spanishGreeting.greet(); &#125; public static void main(String... args) &#123; HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); &#125; &#125; 上面的例子中，使用实现HelloWorld接口的方式来定义EnglishGreeting类，实例化之后才可以使用；frenchGreeting、spanishGreeting在定义的时候就实例化了，定义完之后就可以使用。上面的例子中，两种方法是一样的，如果一个类只需要用到一次，那么就没必要用继承父类或者是实现接口的方式再定义一个类，这时候就可以使用匿名内部类。 匿名内部类的语法匿名内部类有两种使用方法： 继承父类的匿名类 Thread thread = new Thread() &#123; @Override public void run() &#123; super.run(); &#125;&#125;; 实现接口的匿名类 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("11"); &#125;&#125;); 第二个例子实际上是将一个实现接口的匿名类作为参数传进了Thread的构造函数中。 关于匿名类的数据访问可以看这篇文章：匿名类的数据访问。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几数之和系列]]></title>
    <url>%2F2019%2F10%2F19%2F%E5%87%A0%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[在LeetCode的ArrayTag中，有一系列的__数之和题，这几道题都有一些相似之处，在这里做一下总结。 总览 两数之和 三数之和 最接近的三数之和 四数之和 求解方法 暴力法（不可取），时间复杂度往往为n的“几数”次方（如两数之和为$O(n^2)$）。 HashTable减少循环次数，降低时间复杂度。 排序+双指针（推荐）。 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 此题是LeetCode入坑第一题，作为一名算法小白，首先就想到了暴力求解法，方法也是简单粗暴，不做解释。 class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //暴力求解 for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[] &#123;i ,j&#125;; &#125; &#125; &#125; throw new IllegalArgumentException("no sulotion!"); &#125;&#125; 暴力终究不可取，此题还可以使用HashTable求解，减少了一次循环；上一种解法相当于是每个数都要去找一个能和别人配对的数，而利用HashTable的解法是将每个数想要配对的数存起来，并且在存起来之前，检查一遍当前的HashTable中是否已经存在了想要配对的数，如果配对成功，直接返回结果。 class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //HashMap HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int a = target - nums[i]; //想要配对的数 if (hashMap.containsKey(a) ) &#123; return new int[] &#123;hashMap.get(a),i&#125;; &#125; hashMap.put(nums[i], i); &#125; throw new IllegalArgumentException("no sulotion!"); &#125;&#125; 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，*使得 *a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 此题可以参照两数之和的解法继续使用暴力法或者是HashTable解法，但是题目要求不可以包含重复的三元组，所以去重是个大问题，目前除了想到对每个三元组进行排序再使用HashSet去重外，还没有想到别的好办法。 接下来主要介绍排序+双指针的方法。 此题最合适的方法是采用双指针的方法求解，关于双指针在之前的一道题已经使用过了，最主要的一点就是关于指针如何移动的问题。 算法详解 对数据进行排序，一般使用双指针求解都要先对数据进行排序。 确定三个指针的初始位置，k指向最左边也就是最小的数，i和j分别指向除了k处的两端，分别向中间移动，也就是说，移动方式为i++或者j–。 计算三数之和sum，如果sum = 0，直接返回结果；如果sum &gt; 0，应该向右移动i指针，解释一下，我们的目的是需要让当前的sum值减小慢慢向0趋近，i++的方式会让sum的值增大，而j–的方式会让sum的值减小，所以应该向右移动i指针；如果sum &lt; 0，应该向左移动j指针。 由于事先对数据进行了排序，去重也变得有迹可循，首先，我们需要分析重复数据是如何产生的。看下面一个例子。 去除重复数据 拿示例数据[-1, 0, 1, 2, -1, -4]来说，首先对数据排序，当前k指向-1，i指向0，j指向1，当前结果就是一个符合条件的结果 k i j -4 -1 -1 0 1 2 当k继续移动一位以后，发现当前的情况也是一个符合条件的结果，但是很明显和上一种结果重复了。由此，产生重复结果的原因就在于k了，如果存在两个k指针所指的数重复，那么下一次循环就可以直接跳过，这样就避免了重复结果的产生。 k i j -4 -1 -1 0 1 2 另外，对于其他两个指针，同样会产生重复的情况，分析过程和上面对k指针的分析相同。 代码： class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; //排序 + 双指针 List&lt;List&lt;Integer&gt;&gt; ternaryList = new ArrayList&lt;&gt;(); Arrays.sort(nums); //[-4, -1, -1, 0, 1, 2] //[-1, -1, 0, 1] for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //去重 int i = i + 1; int j = nums.length - 1; while (i &lt; j) &#123; int sum = nums[i] + nums[i] + nums[j]; if (sum == 0) &#123; ternaryList.add(Arrays.asList(nums[i], nums[i], nums[j])); while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) i++; // 去重 while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) j--; // 去重 j--; i++; &#125; else if (sum &lt; 0) &#123; i++; &#125; else if (sum &gt; 0) &#123; j--; &#125; &#125; &#125; return ternaryList; &#125;&#125; 剩下的两道题解法和三数之和基本相同，只给出代码。 最接近的三数之和class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int result = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.length; i++) &#123; int j = i + 1, k = nums.length - 1; while (j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; // 移动指针 if (sum == target) &#123; return sum; &#125; if (sum &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return result; &#125;&#125; 四数之和class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; //去重 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; //去重 int k = j + 1, l = nums.length - 1; while (k &lt; l) &#123; int sum = nums[i] + nums[j] + nums[k] + nums[l]; if (sum == target) &#123; result.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l])); while (k &lt; l &amp;&amp; nums[k] == nums[k + 1]) k++; while (k &lt; l &amp;&amp; nums[l] == nums[l - 1]) l--; k++; l--; &#125; else if (sum &gt; target) &#123; l--; &#125; else if (sum &lt; target)&#123; k++; &#125; &#125; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>two-pointers</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two pointer]]></title>
    <url>%2F2019%2F10%2F16%2FTwo%20pointers%2F</url>
    <content type="text"><![CDATA[盛最多水的容器 Category Difficulty Likes Dislikes algorithms Medium (58.43%) 847 - Tagsarray&nbsp;|&nbsp;two-pointers Companiesbloomberg 给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 作者：LeetCode链接：https://leetcode-cn.com/problems/container-with-most-water/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 解题方法暴力法第一次Submit的时候，奈何不知道双指针，用的暴力法，还有一种LeetCode官方解答种使用Java内置Math工具类的比较简介的写法。 class Solution &#123; public int maxArea(int[] height) &#123;// //暴力法// int maxArea = 0;// for (int i = 0; i &lt; height.length; i++) &#123;// for (int j = i + 1; j &lt; height.length; j++) &#123;// int area = 0;// if (height[i] &lt;= height[j]) &#123;// area = height[i] * (j - i);// &#125; else &#123;// area = height[j] * (j - i);// &#125;// if (area &gt;= maxArea) &#123;// maxArea = area;// &#125;// &#125;// &#125;// return maxArea; //2.暴力法(精简) int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i)); &#125; &#125; return maxArea; &#125;&#125; 复杂度 时间复杂度：$O(n^2)$。 空间复杂度：$O(1)$。 ##双指针法 思路：双指针分别位于容器两端，根据某个规则向内移动指针，并且更新面积的最大值，直到i == j，返回最大值。 水槽的面积公式：$S = min(h[i], h[j]) * (j - i)$ 如果短板或者长板向中间移动，j或者i就会-1，(j - i)就会-1。 如果移动长板，下一个短板min(h[i], h[j])会不变或者变小，然而只要指针发生了移动，(j - i)必变小，所以下一个水槽的面积一定不会大于上一个水槽的面积。 如果移动短板，下一个短板min(h[i], h[j])才可能会变大，所以下一个水槽的面积才有可能变大。 所以，移动规则就是每次向着短板的方向移动。 代码： class Solution &#123; public int maxArea(int[] height) &#123; //双指针法 int head = 0, tail = height.length - 1, maxArea = 0; while (head &lt; tail) &#123; if (height[head] &lt;= height[tail]) &#123; maxArea = Math.max(height[head] * (tail - head), maxArea); head++; &#125; else &#123; maxArea = Math.max(height[tail] * (tail - head), maxArea); tail--; &#125; &#125; return maxArea; &#125;&#125; 复杂度： 时间复杂度：$O(n)$。 空间复杂度：$O(1)$。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Final arrays in Java]]></title>
    <url>%2F2019%2F10%2F10%2FFinal%20arrays%20in%20Java%2F</url>
    <content type="text"><![CDATA[之前在做第一个安卓项目时，在使用TimerTask和使用Thread创建新线程的时候，发现如果在匿名方法中对局部变量进行修改的时候会报错，但是可以访问局部变量，而使用成员变量的时候就不会报错。不过，如果将其写成下面就不会报错了，但是问题又来了，明明将变量声明成了final类型，为什么可以修改其值呢？ void myThread() &#123; final int[] i = &#123;0&#125;; Thread thread = new Thread(()-&gt; i[0]++); thread.start();&#125; 我们需要解决以下几个问题： 为什么在匿名方法中可以修改成员变量而不可以修改局部变量？ 为什么匿名方法中只能访问final类型的局部变量？ 为什么final数组的值可以被修改？ 在匿名方法中使用的局部变量为什么只能是final原因是Java设计者想要匿名函数或者Lambda函数内部外部保持数据一致性，在匿名方法中使用局部变量时，内部类并不是真正地使用该变量，而是在匿名方法中复制一个副本，由于是副本，所以即使是在匿名方法中修改了该变量，局部变量也不会发生变化，所以匿名方法使用的局部变量只能是final类型的变量。 注：在Java8以前，访问任何局部变量都要加final关键字，而在Java8之后，只要不涉及修改局部变量的操作，就可以不用加final关键字。 但是，对于成员变量来说，匿名方法会保存外部类的引用，因而内部类中对任何字段的修改都回真实的反应到外部类实例本身上，所以不需要用final来修饰它。具体可以参考该博客：https://www.cnblogs.com/qq78292959/p/3745348.html Final arrays如果非要对局部变量进行修改怎么办，那就只能用到上面的final数组方法。我们都知道，final类型的数据是不可以被修改的，但是为什么此处的final数组的值被修改了呢？ 下面是一个静态常量： public final int[] number = &#123;1, 2, 3&#125;; final关键字能保证数据不可以被修改对于基本类型来说这点是成立的，但对于数组来说就不成立了，因为数组和类以及接口一样，是引用类型，引用数据类型实际上只储存了一个指针，final只能保证其引用不变，即这个指针不变，但是数组中的对象的值还是可以改变的。而且，引用数据类型的数据是储存在堆内存中的，匿名方法可以共享。 注意：正是由于final数组的这个特性，所以在需要定义一个常量数组的时候，不要使用该方法，这样定义依然是会被修改值的。 文章开始的代码可以重写Thread类，定义Thread类的成员变量来实现相同的功能。 private void myThread()&#123; class MyThread extends Thread &#123; private int i = 0; @Override public void run() &#123; super.run(); i++; System.out.println(i); &#125; &#125; MyThread myThread = new MyThread(); myThread.start();&#125; 总结 在匿名方法中使用的局部变量只能是fianl类型的。 Java8以后，只要不对局部变量修改，局部变量即使不加final关键字也可以被匿名方法访问。 如果匿名方法要修改局部变量，可以将变量定义成final数组的形式。 如果要final发挥常量作用，final数组要慎用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static关键字]]></title>
    <url>%2F2019%2F10%2F10%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static关键字是经常会使用到的，之前一直没有对该关键字进行过深入地学习过，下面就讲述一下该关键字以及用途。 static关键字static关键字表示全局或者静态的意思，可以实现类似全局变量的作用，用static修饰变量或者方法都是独立于某个类的，会被所有的该类的实例共享，所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 public class Student &#123; private static int count; Student() &#123; count++; &#125; public static void main(String[] args) &#123; Student student = new Student(); Student student1 = new Student(); Student student2 = new Student(); System.out.println(Student.count); &#125;&#125;---------------Output:3 如上面的代码，运行结果为3，说明三个类的实例是共享静态变量count的，使用上面的代码可以统计一个类被实例化了多少次。 static关键字的用途 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。 上面是《Thinking in Java》对static关键字作用的解释，总结一下，就是static方法可以在不用实例化对象的情况下使用。 static变量有static关键字修饰的变量为静态变量，而没有static修饰的变量是成员变量，在对类进行实例化的时候，无论进行多少次实例化，静态变量也只会被实例化一次，而成员变量则不同，它是伴随着实例的，每创建一个实例就会产生一个成员变量。 static成员变量的初始化顺序按照定义的顺序进行初始化。 在C/C++中static是可以作用域局部变量的，但是在Java中static是不允许用来修饰局部变量。 static方法有static关键字修饰的方法可以直接通过类名进行调用。由于static方法在类加载的时候就已经存在了，它不依赖于任何实例。 注意，在静态方法中不能调用非静态成员和非静态方法，在静态方法加载的时候非静态成员和方法还未加载；然而，在非静态方法中可以调用静态方法。 static代码块static关键字的一个比较特殊的用法就是静态代码块。静态代码块同样是在虚拟机加载类的时候就会会被加载执行，而且只执行一次。如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们。 静态代码块作用静态代码块的一个比较重要的作用就是可以优化性能。 比如下面的例子： public class Student &#123; private Date birthDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是判断该人是否是1946年到1964年之间出生的，每次isBornBoomer被调用的时候都会生成startDate和endDate两个对象，造成了空间浪费，可以改成下面的形式： public class Student &#123; private Date birthDate; private static Date startDate,endDate; public Student(Date birthDate) &#123; this.birthDate = birthDate; &#125; static &#123; Date startDate = Date.valueOf("1946"); Date endDate = Date.valueOf("1964"); &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 所以，可以对只进行一次初始化的操作放在static代码块中进行。 静态代码块的执行时机在Java中，一个类的加载过程分为三个步骤：1. 装载 2. 连接 3. 初始化。 静态代码块是在类初始化的时候执行的，初始化阶段，jvm主要完成对静态变量的初始化，静态块执行等工作。 Class A&#123; static&#123; System.out.println("static block invoked!") &#125;&#125; 上面的代码中 new A()会执行static代码块中的内容。 Class.forName(&quot;A&quot;)会执行代码块中的内容；这个过程相当于Class.forName(&quot;A&quot;, true, A.class.getClassLoader())。 Class.forName(&quot;A&quot;, false, A.class.getClassLoader())不会执行代码块中的内容；因为false指明了在类加载的过程中不进行初始化，就不会执行static代码块了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识点整理]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本学期学习了计算机网络，本文将整理计算机网络的一些基础知识点，供自己以后查阅。 计算机网络的几种分层结构计算机网络通常可以进行下面的几种分层方式： 七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。 五层划分为：应用层、传输层、网络层、数据链路层、物理层。 四层划分为：应用层、传输层、网络层、网络接口层。 下面基本以五层架构为标准讲解 每层常用的网络协议 层 网络协议 应用层 http DNS FTP TFTP Telnet SMTP 传输层 TCP UDP 网络层 IP ICMP RIP ICMP 数据链路层 ARP RARP 每层较重要的协议应用层 协议名称 基本介绍 http 超文本传输协议，是用于从万维网服务器传输超文本到本地浏览器的传送协议，基于TCP/IP协议通信。 DNS 将域名解析为IP地址的协议，基于UDP协议通信。 FTP 文件传输协议。 TFTP 简单文件传输协议。 Telnet 为用户提供了在本地计算机上完成远程主机工作的能力。 SMTP 简单邮件传输协议。 传输层 协议名称 基本介绍 TCP TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP UDP协议是一种无连接的简单传输协议。 网络层 协议名称 基本介绍 IP IP协议不仅定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择。 ICMP 面向无连接的协议，用于传输出错报告控制信息。（ping命令就是使用的该协议，ping虽然处在应用层，但是可以直接使用网络层的ICMP协议） RIP 是一种内部网关协议，是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。 数据链路层 协议名称 基本介绍 ARP 地址解析协议，可以根据IP地址获取物理地址。 RARP 反向地址转换协议，可以根据物理地址获取IP地址。 常用端口号概述计算机端口号总数：65535。 0-1023： 系统端口，也叫公认端口，这些端口只有系统特许的进程才能使用。 1024~65535：用户端口，用户可以自定义这些端口的作用。 常用端口 协议/服务名称 端口号 http 80 https 443 www代理服务 8080 ssh 22 DNS 53 FTP 20（用于连接）、21（用于传输） Telnet 23]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置WireShark抓取https数据包]]></title>
    <url>%2F2019%2F09%2F27%2F%E9%85%8D%E7%BD%AEWireShark%E6%8A%93%E5%8F%96https%E6%95%B0%E6%8D%AE%E5%8C%85%2F</url>
    <content type="text"><![CDATA[配置环境变量SSLKEYLOGFILE为E:\ssl_key\sslog.log。 完全退出chrome或者firefox浏览器，然后重新打开。打开浏览器，访问一个HTTPS 网页，然后打开刚才SSLKEYLOGFILE环境变量值的文件路径就可以看到随机字符串记录。 配置WireShark。打开编辑-&gt;首选项-&gt;Protocols，打开SSL对其进行编辑（注：wireshark在某次版本更新之后去掉了SSL选项，没有SSL选项的需要设置TSL），将日志文件的路径添加到(Pre)-Master-Securet log file。 访问www.liuergo.top ，在WireShark中开始抓包，可以发现https的数据包可以被抓到了。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化介绍 序列化：将对象写入到IO流中 反序列化：将对象从IO流中恢复 序列化的意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在，而且这整个过程都是独立于JVM进行的。 使用场景：所有在网络上传输的对象都需要进行序列化，比如在使用RMI(远程方法调用)时；所有需要保存到磁盘上的Java对象必须是可以被序列化的。通常程序创建的每个JavaBean都要实现Serializeable接口。 实现序列化如果一个类要实现序列化，那么这个类应该实现Serializable接口或者Externalizable接口。 Serializable接口Serializable接口是个标记接口，和之前提到的RandomAccess接口一样，接口中没有任何方法。一旦实现了该类，就表明该类是可序列化的。 序列化步骤 相应的类实现Serializeable接口。 Student.java /** * @paragram: SerializeDemo * @description: 学生类 * @auhor: liuergo * @date: 2019-09-26 21:55 */public class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age='" + age + '\'' + '&#125;'; &#125; 创建一个ObjectOutputStream输出流，并调用ObjectOutputStream对象的writeObject输出可序列化对象。 public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student.txt")); Student student = new Student("二狗", 18); objectOutputStream.writeObject(student); &#125; catch (IOException e) &#123; e.printStackTrace() &#125;&#125; 这时，会生成一个Student.txt文件。 反序列化步骤创建一个ObjectInputStream输入，并调用ObjectInputStream对象的readObject方法。 public static void main(String[] args) &#123; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student.txt")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//Student&#123;name='二狗', age='18'&#125; 反序列化不需要调用构造方法，其反序列化的对象是由JVM自己生成的对象，不需要构造方法生成。 对同一个对象多次序列化public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); Student student = new Student("二狗", 18); Student student1 = new Student("大鹅", 18); Student student2 = new Student("三虎", 19); objectOutputStream.writeObject(student); objectOutputStream.writeObject(student1); objectOutputStream.writeObject(student2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student = (Student) objectInputStream.readObject(); System.out.println(student.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//运行结果//Student&#123;name='二狗', age='18'&#125; 从运行结果可以看出，在对一个对象进行序列化之后，并不会再次对其进行序列化。 所以，该序列化算法存在这样一个问题，如果在对一个对象进行序列化之后，需要修改该对象的内容，第二次序列化并不会成功。 transient关键字如果有时候对象的某些属性不需要序列化。这时候就可以使用该关键字选择不需要序列化的属性。 public class Student implements Serializable&#123; private transient String name; private int age; ...&#125; 这时序列化的结果就变成了Student{name=&#39;null&#39;, age=&#39;18&#39;}，这样，序列化的时候就自动忽略了name这个属性。 Externalizable接口 Externalizable.java public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 可以看到，该接口有两个方法，实现该接口，必须要实现writeExternal、readExternal两个方法。 public class Student implements Externalizable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; StringBuffer reverseString = new StringBuffer(this.name).reverse(); out.writeObject(reverseString); out.writeInt(this.age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; this.name = ((StringBuffer) in.readObject()).reverse().toString(); this.age = in.readInt(); &#125;&#125; Student类继承Externalizable接口之后，实现两个方法，在writeExternal方法中，可以对其进行一加密以保证安全性，注意要在readExternal方法中写相应的解密方法；而且如果不需要对某个属性进行序列化的话，就可以直接去掉某个属性序列化的语句，相当于实现了transient关键字的作用。 public static void main(String[] args) throws Exception&#123; Student student = new Student("二狗", 18); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Student")); objectOutputStream.writeObject(student); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("Student")); Student student1 = (Student) objectInputStream.readObject(); System.out.println(student1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 序列化和反序列化的代码和之前的是一样的，看到这里可能或产生一个问题，在上面的一段代码中，并没有看到刚刚的writeExternal和readExternal被显式调用，那么这两个方法到底是如何被调用的呢？ 查看ObjectOutputStream的源码，对于一个实现了EXternalizable接口的类来说，可以看出writeObject的调用栈： writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeExternalData ObjectOutputStream.java private void writeObject0(Object obj, boolean unshared) throws IOException&#123;......// remaining cases if (obj instanceof String) &#123; writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared); &#125;......&#125;private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException&#123;...... if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123; writeExternalData((Externalizable) obj); &#125; else &#123; writeSerialData(obj, desc); &#125;......&#125;/** * Writes externalizable data of given object by invoking its * writeExternal() method. */private void writeExternalData(Externalizable obj) throws IOException &#123; PutFieldImpl oldPut = curPut; curPut = null; if (extendedDebugInfo) &#123; debugInfoStack.push("writeExternal data"); &#125; SerialCallbackContext oldContext = curContext; try &#123; curContext = null; if (protocol == PROTOCOL_VERSION_1) &#123; obj.writeExternal(this); &#125; else &#123; bout.setBlockDataMode(true); obj.writeExternal(this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); &#125; &#125; finally &#123; curContext = oldContext; if (extendedDebugInfo) &#123; debugInfoStack.pop(); &#125; &#125;&#125; ⭐上面的部分源码给出了调用栈的后三个方法，通过源码可以很清晰地看出，由于Externalizable接口也实现了Serializable接口，所以在writeObject0方法中首先经过obj instanceof Serializable进入writeOrdinaryObject方法，在这里对该对象是否实现了Externalizable接口进行了判断（如果是继承了Serializable接口，会调用writeSerialData方法，这种情况会在下面讲解），最后调用writeExternalData方法，可以看到在该方法中会调用在类中重写的writeExternal方法。 🐞第一次运行的时候，报了以下异常，no valid constructor，没有合法的构造器，这是因为Student类中没有一个无参的构造器。在通过实现接口Externalizable进行序列化读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器，增加一个无参构造器之后就不会报这个异常了。 serialVersionUID在学习集合类的时候经常能在源码中看见serialVersionUID，当时只是知道和序列化有关，今天就深入了解一下。 JVM是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，即serialVersionUID。 如果反序列化时候的使用的序列化ID与序列化时使用的ID不同的话，就会报InvalidClassException异常。 需要特别说明的是，如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。 ⭐所以，在编写某个JavaBean时，最好是给这个serialVersionUID赋值，这样就可以避免以后在更新类的时候产生异常，方便升级。 ArrayList的序列化最初学习序列化的原因，是因为一开始看ArrayList源码的时候，不知道serialVersionUID一大串数字是干嘛的，也不知道transient关键字的含义，现在学习完序列化之后再回过头来看ArrayList的源码。从ArrayList的源码开始，我们首先关注下面的部分。 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; transient Object[] elementData; // non-private to simplify nested class access&#125; 可以看到，底层的实现数组使用了transient关键字，也就是说，ArrayList是不会被序列化的吗？ public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ArrayList")); objectOutputStream.writeObject(list); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("ArrayList")); ArrayList&lt;Integer&gt; list1 = (ArrayList&lt;Integer&gt;) objectInputStream.readObject(); System.out.println(list1); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;//输出结果//[1, 2, 3] 然而在经过测试之后，可以发现，ArrayList被序列化成功了，那么使用了transient关键字为什么还会被序列化？既然要序列化ArrayList，又是为什么要使用该关键字呢？ 其实事情的真相就在于ArrayList中的两个方法writeObject和readObject方法，下面是两个方法的源码部分。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 从源码可以看出，在序列化一个ArrayList时，会将size和elementData都写入输出流，这就是为什么加了transient关键字之后依然会被序列化的原因。那么为什么要加这个关键字呢？这是因为elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上面的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 现在还有一个问题就是，这两个方法是如何被调用的呢？有了前面对Externalizable接口分析的经验，直接查看ObjectOutputStream的writeSerialData方法，在该方法中调用了invokeWriteObject方法来实现序列化，下面直接看该方法。 void invokeWriteObject(Object obj, ObjectOutputStream out) throws IOException, UnsupportedOperationException&#123; requireInitialized(); if (writeObjectMethod != null) &#123; try &#123; writeObjectMethod.invoke(obj, new Object[]&#123; out &#125;); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); if (th instanceof IOException) &#123; throw (IOException) th; &#125; else &#123; throwMiscException(th); &#125; &#125; catch (IllegalAccessException ex) &#123; // should not occur, as access checks have been suppressed throw new InternalError(ex); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125;&#125; ObjectStreamClass.java writeObjectMethod = getPrivateMethod(cl, "writeObject", new Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;, Void.TYPE);readObjectMethod = getPrivateMethod(cl, "readObject", new Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;, Void.TYPE); 重点关注writeObjectMethod.invoke(obj, new Object[]{ out });这一行，其中的writewriteObjectMethod对象就是在ObjectStreamClass类中定义的，通过反射的方式调用的两个方法。 总结 实现序列化的方式主要有以下几种： 实现Serializable接口，调用ObjectOutputStream的writeObject方法，将对象序列化，这时，是使用的Java的自带的序列化方式。此时被transient关键字修饰的属性，不会被序列化。 实现Serializable接口，同时提供writeObject方法，这时ObjectOutputStream就会通过反射的方式调用writeObject方法。此时transient修饰的字段，是否会被序列化，取决于writeObject方法。 实现 Externalizable接口，并实现两个方法，这时ObjectOutputStream就会自动调用writeObject方法。此时，transient关键字不会起作用，是否会被序列化，取决于writeObject方法。 定义JavaBean时，最好都实现Serializable接口，并且定义serialVersionUID。 静态变量不会被实例化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RandomAccess接口]]></title>
    <url>%2F2019%2F09%2F24%2FRandomAccess%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通过在Java集合类中，查看类继承图和源码可以看出ArrayList和Vector都实现了RandomAccess接口，而LinkList却没有实现该接口，查看RandomAccess接口，发现里面是空的。 RandomAccess.java package java.util;/** * 一大堆注释... */public interface RandomAccess &#123;&#125; 其实，该接口只是一个标识性接口(Marker)，除了RandomAccess接口外，还有Cloneable (可拷贝克隆)、Serializable(被序列化)，之后会有文章介绍这两个接口。 该接口的官方解释 List实现使用的标记界面，表明它们支持快速（通常为恒定时间）随机访问。 此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。 当施加到顺序访问列表（如LinkedList），用于操纵随机接入列表（如ArrayList）最好算法可以产生二次行为。 鼓励通用列表算法在应用如果应用于顺序访问列表之前提供较差性能的算法，并且如果需要改变其行为以确保可接受的性能，则检查给定列表是否为instanceof此接口。 此循环： for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); 比这个循环运行得更快： for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); Collections类中的使用此接口在Collections类中有很多地方都使用到了，比如下面的binarySearch方法 Collection.java @SuppressWarnings("unchecked")public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123; if (c==null) return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key); if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key, c); else return Collections.iteratorBinarySearch(list, key, c);&#125; 上面的方法中，通过判断list是否实现了RandomAccess接口来判断执行indexedBinarySearch方法还是执行iteratorBinarySearch方法(instanceof关键字的作用是判断某个对象所在的类是否继承某个类或者是实现某个接口)。 应用下面先做一个分别使用for循环和Iterator遍历ArrayList和LinkedList的实验。 RamdomAccessDemo.java import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;/** * @paragram: CollectionDemo * @description: RandomAccess接口Demo * @auhor: liuergo * @date: 2019-09-24 23:00 */public class RandomAccessDemo &#123; public static void main(String[] args) &#123; System.out.println("arrayList使用for循环遍历" + arrayListFor()); System.out.println("arrayList使用Iterator遍历" + arrayListIterator()); System.out.println("linkedList使用for循环遍历" + linkedListFor()); System.out.println("linkedList使用Iterator遍历" + linkedListIterator()); &#125; //for循环遍历ArrayList public static long arrayListFor() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long arrayListIterator() &#123; List list = new ArrayList(); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //for循环遍历ArrayList public static long linkedListFor() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; Object object = list.get(i); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125; //Iterator循环遍历ArrayList public static long linkedListIterator() &#123; List list = new LinkedList(); for (int i = 0; i &lt; 50000; i++) &#123; list.add(i); &#125; long startTime = System.currentTimeMillis(); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object object = iterator.next(); &#125; long endTime = System.currentTimeMillis(); return endTime - startTime; &#125;&#125; 运行结果 可以发现，使用for循环比使用Iterator遍历ArrayList快，使用Iterator比使用for循环快。 所以，我们在使用这些集合类的时候，应该想到对于不同的集合类采取不同的遍历方式，具体采取那种方式就可以采取通过判断该类是否实现了RandomAccess接口的方式。 可以采用如下的模板： public void traverseList(List list) &#123; if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; &#125; &#125; else &#123; Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; &#125; &#125;&#125; 注：推荐使用增强for循环，增强for循环在底层也是实现的Iterator。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS+PicGo建立图床]]></title>
    <url>%2F2019%2F09%2F21%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%2BPicGo%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在本地写md文档时候插入图片是一件挺麻烦的事情，使用本地图片的话，每次在给别人分享文档或者上传博客的时候就比较难顶了。网上有两种方法可以解决这个问题，一种是使用图片的base64编码，但是图片转换为base64编码之后，编码长度会很大，文档的可读性不好，而且也会使文档的体积急剧变大，这种方法显然不太好。所以，最终使用了图床的方法将图片储存在阿里云中。 开通OSS服务​ 进入阿里云创建一个对象存储OSS的服务，之后新建一个Bucket，创建Bucket之后，我们的存储空间就创建成功了。 使用PicGo快速上传图片 PicGo下载地址https://github.com/Molunerfinn/PicGo 配置PicGo ​ KeyId和KeySecret可以从阿里的控制台获取。 ​ 储存空间名就是Bucket的名称，存储区域在访问域名可以找到。 ​ 配置完成之后就可以使用PicGo上传图片了。 踩坑记录​ 第一次使用PicGo上传图片的时候，总是提示上传失败，检查了好几遍配置，都没有什么错误，可是就是上传不了。 ​ 打开PicGo的配置文件之后，发现有下面的报错信息。 2019-09-21 21:33:11 [PicGo ERROR] StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot;------Error Stack Begin------StatusCodeError: 403 - &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;Error&gt;\n RequestTimeTooSkewed\n &lt;Message&gt;The difference between the request time and the current time is too large.&lt;/Message&gt;\n &lt;RequestId&gt;5D8634B41BCC63B32BB5C43E&lt;/RequestId&gt;\n &lt;HostId&gt;lzy-md-image.oss-cn-qingdao.aliyuncs.com&lt;/HostId&gt;\n &lt;MaxAllowedSkewMilliseconds&gt;900000&lt;/MaxAllowedSkewMilliseconds&gt;\n &lt;RequestTime&gt;2019-09-21T13:33:10.000Z&lt;/RequestTime&gt;\n &lt;ServerTime&gt;2019-09-21T14:33:24.000Z&lt;/ServerTime&gt;\n&lt;/Error&gt;\n&quot; at new StatusCodeError (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\errors.js:32:15) at Request.plumbing.callback (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:104:33) at Request.RP$callback [as _callback] (E:\PicGo\resources\app.asar\node_modules\request-promise-core\lib\plumbing.js:46:31) at Request.self.callback (E:\PicGo\resources\app.asar\node_modules\request\request.js:185:22) at Request.emit (events.js:182:13) at Request.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1157:10) at Request.emit (events.js:182:13) at IncomingMessage.&lt;anonymous&gt; (E:\PicGo\resources\app.asar\node_modules\request\request.js:1079:12) at Object.onceWrapper (events.js:273:13) at IncomingMessage.emit (events.js:187:15)-------Error Stack End------- ​ 重点关注The difference between the request time and the current time is too large这一部分，查找阿里云OS文档，403错误及排查。看到下面的部分，就明白了出问题的原因。 ​ 由于我的电脑是Windows+Ubuntu双系统，每次切换系统的时候都会产生八个小时的时差，一直没有解决这个冲突问题，所以造成了Windows时间不正常，也就导致了今天的问题。 ​ 解决方法就很简单了，重新同步一下时钟就好了。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合类]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java众多的集合类由两大接口衍生而来：Collection接口和Map接口 CollectionList(有序，可重复)ArrayList优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程不安全，效率高。 类继承图 ArrayList.java /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 上面的elementData就是ArrayList的底层数组的实现。 Vector优点：底层数据结构是数组，具有数组本身的特点：查询快，增删慢。 缺点：线程安全，效率低。 类继承图 Vector.java /** * Appends the specified element to the end of this Vector. * * @param e element to be appended to this Vector * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) * @since 1.2 */public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 查看Vector的源码可以发现，大部分源码都加上了synchronized关键字，比如上面的add方法，这也是Vector线程安全的原因。 LinkedList优点: 底层数据结构是链表，查询慢，增删快。缺点: 线程不安全，效率高。 类继承图 比较LinkedList和前两个集合类的区别，可以发现LinkedList实现了Deque接口，并且没有实现 RandomAccess接口，表示此集合类不支持快速随机访问，此接口有专门的文章讲解。 Set(无序，唯一)HashSet底层数据结构是哈希表（无序，唯一）。 类继承图 可以看出，HashSet也是没有实现RandomAccess接口的，不支持快速随机访问，关于HashSet是如何保证元素的唯一性的，及其无序性的原因将在HashMap中解释。 HashSet.java private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 从上面的源码可以看出，HashSet的底层实现是HashMap，每次调用add方法时，Map的value部分仅仅put了一个一个Object对象，而HashMap的Key是唯一的，也就保证了HashSet的唯一性。 LinkedHashSet底层数据结构是哈希表和链表（有序，唯一），链表保证其有序，哈希表保证其唯一。 从类继承图可以看出，LinkedHashSet继承了HashSet，从下面的源码可以看出，LinkedHashSet主要是实现了HashSet的HashSet(int initialCapacity, float loadFactor, boolean dummy)构造方法，在该方法中新建了一个LinkedHashMap对象，链表部分的实现就在LikedHashMap中实现了。 //LinkedHashSet.javapublic LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;//HashSet.javaHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; TreeSet底层数据结构是红黑树（唯一，有序）。SortedSet接口保证了其有序性，主要用于排序。 类继承图 MapHashMapMap族主要包括HashMap、LinkedHashMap、TreeMap、Hashtable HashMap 线程不安全，效率高，无序。 HashMap允许空值，并且key和value都允许。key值具有唯一性，存在的话key值不会覆盖，新的value会替代旧的value，而且HashMap是无序的，之后会有源码讲解详细解释。 LinkedHashMap 内部维持了一个双向链表，相比于HashMap来说可以保证有序。 TreeMap 内部实现是红黑树，可以对插入的元素进行自动排序。 Hashtable 很多方法加上了synchronized，所以，Hashtable是线程安全的，而且Hashtable不允许空值。 对比分析TreeSet，LinkedHashSet，HashSet对比相同点 由于实现了Set接口，都有唯一性的特点。 三者都不是线程安全的，如果想保证线程安全，可以使用Collections.synchronizedSet()方法。 不同点 是否有序：HashSet直接实现了HanshMap，是无序的，而由于LinkedHashSet实现了链表，可以保证数据按照插入顺序排序，TreeSet会对插入的数据实现排序。 是否允许空值：HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException。 测试public static void setTest() &#123; HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); for (Integer data: Arrays.asList(745, 3, 114, 526, 5, 7, 4)) &#123; hashSet.add(data); linkedHashSet.add(data); treeSet.add(data); &#125; System.out.println("HashSet：" + hashSet); System.out.println("LinkedHashSet：" + linkedHashSet); System.out.println("TreeSet：" + treeSet);&#125; 运行结果 可以看出来，遍历HashSet的结果是无序的，遍历LinkedHashSet的结果是跟插入数据的顺序保持一致，TreeSet可以对数据进行排序。 HashMap、LinkedHashMap、TreeMap、Hashtable对比相同点 都是用于储存key/value键值对，key不能重复 不同点 是否支持多线程读写：HashMap、TreeMap、LinkedHashMap线程不安全，只有Hashtable线程安全。 是否有序：HashMap、Hashtable无序，LikedHashMap可以保证数据按照插入顺序排序、TreeMap可以对数据进行排序。 是否允许空值：HashMap、LikedHashMap允许存在一条键为null的记录，Hashtable、TreeMap不允许空值存在。 遍历方式List主要有三种循环方式，for循环、增强for循环和迭代器方式。增强for循环的内部是调用iterator实现的，后两种方式的效果基本相同(在idea中也会有提示建议使用增强for循环的方式)。对于如何选择遍历方式，在RandomAccess接口中有讲到。 //List遍历private static void traverseListTest() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) &#123; arrayList.add(i); &#125; //for循环遍历 for (int i = 0; i &lt; arrayList.size(); i++) &#123; System.out.println(arrayList.get(i)); &#125; //增强for循环 for (Integer integer : arrayList) &#123; System.out.println(integer); &#125; //iterator方式 Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125;&#125; Map遍历方式，主要的遍历方式有四种，第一中国方式仅仅遍历value或者key的话直接使用一个增强for循环，第二种方式是使用Map.keyset方法遍历key，可以再通过key找到value，第三种是使用Map.entrySet遍历，此方法是效率比较高的一种，第四种是使用Iterator遍历，和上一种方式基本相同，但是如果需要在遍历过程中删除元素的话，需要使用该方法。 //Map遍历private static void traverseMapTest() &#123; Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125; //仅遍历value for (Integer value : map.values()) &#123; System.out.println(value); &#125; //仅遍历key for (Integer key : map.keySet()) &#123; System.out.println(key); &#125; //Map.keySet方法 for (Integer key : map.keySet()) &#123; System.out.println(key + " " + map.get(key)); &#125; //Map.entrySet方法 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue()); &#125; //Iterator方式 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next().getKey() + " " + iterator.next().getValue()); &#125; //lambada map.forEach((key, value) -&gt; System.out.println(key + " " + value));&#125; 性能测试插入了500w条数据进行测试。 遍历方式 时间（ms） KeySet 13 values 42 keySet get(key) 51 entrySet 41 iterator 39 总结 如果只是获取key或者value，推荐使用KeySet和values方式。 同时需要key和value，推荐使用entrySet方式。 如果需要在遍历的过程中删除元素，可以使用iterator方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么输入IP地址无法访问网站]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%93%E5%85%A5IP%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[🌈学习完DNS解析之后，自己尝试写了一个Java程序解析DNS地址的小Demo。 代码： import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Arrays;/** * @paragram: DNSDemo * @description: 域名解析 * @auhor: liuergo * @date: 2019-09-18 15:41 */public class Test &#123; public static void main(String[] args) &#123; Test tester = new Test(); // tester.resolveDomain("www.baidu.com"); tester.resolveDomain("www.zhihu.com"); &#125; private void resolveDomain(String domain) &#123; InetAddress[] address; try &#123; address = InetAddress.getAllByName(domain); Arrays.stream(address) .map(InetAddress::getHostAddress) .forEach(System.out::println); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解析百度的IP地址以后，直接访问百度的IP地址可以正常访问，然而解析知乎的IP地址以后，无法正常访问。 域名可以访问然而IP不能访问，这是为什么呢？ 只输入IP地址无法访问网站的原因​ 输入IP地址无法访问的原因就是多个站点在共用这一个IP，如果只输入IP地址的话，浏览器也不知道要访问哪个站点，所以就无法访问了。 ​ 那么，浏览器不也是解析域名之后再访问的IP地址吗，最终也是访问的IP地址，那么越过DNS解析直接访问和前一种形式不应该一样吗？ ​ 有两种技术可以上面的问题： 虚拟主机技术 反向代理技术 虚拟主机技术 虚拟主机技术是apache，nginx等服务器所特有的一种功能，也就是实现多个站点在同一台服务器上放置。 那么，知乎的某台服务器可能就是下面的样子： 站点 文件存放路径 www.zhihu.com /zhihu/index www.a.com /a/index www.b.com /b/index 这样，域名和文件之间就存在映射关系了，当我们直接访问 www.zhihu.com 时，主要经历了以下几个步骤： DNS域名解析，获得解析后的结果，比如是223.111.243.190。 浏览器与IP为223.111.243.190的服务器进行三次握手，建立TCP连接。 浏览器开始构建HTTP请求报文，通过抓包可以看到报文格式： Hypertext Transfer Protocol GET / HTTP/1.1\r\n Host: www.zhihu.com\r\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8\r\n Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n Accept-Encoding: gzip, deflate\r\n Connection: keep-alive\r\n Upgrade-Insecure-Requests: 1\r\n \r\n [Full request URI: http://www.zhihu.com/] [HTTP request 1/18] [Response in frame: 121] 以上信息中，我们需要关注一行，就是Host: www.zhihu.com\r\n 这一行，通过这个头部字段，服务器就可以知道 到底访问的是哪个HOST，然后服务器就根据HOST和域名的对应关系，去寻找/zhihu/index文件。 反向代理技术先介绍一下正向代理和反向代理的区别： 正向代理正向代理，是在用户端的。比如需要访问某些国外网站，我们可能需要购买vpn。 并且vpn是在我们的用户浏览器端设置的(并不是在远端的服务器设置)。 浏览器先访问vpn地址，vpn地址转发请求，并最后将请求结果原路返回来。 反向代理有正向代理，就有反向代理。 反向代理是作用在服务器端的，是一个虚拟IP(VIP)。对于用户的一个请求，会转发到多个后端处理器中的一台来处理该具体请求。 大型网站都有DNS(域名解析服务器)，load balance(负载均衡器)等。 下面主要介绍反向代理技术 ​ 在计算机网络中，反向代理是代理服务器的一种。服务器根据客户端的请求，从其关联的一组或多组后端（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在。 在这种情况下，直接访问IP的时候会访问反向代理服务器，这样访问 www.zhihu.com 的时候，过程如下： 通过DNS解析获得 www.zhihu.com 的反向代理IP地址223.111.243.190。 HTTP请求到达反向代理服务器之后，该服务器会对请求做转发。 请求的HOST地址为 www.zhihu.com ，反向代理服务器会将请求报文转发到域名为www.zhihu.com的服务器上。 总结直接使用IP无法访问站点的原因 一个IP可能对应多个web站点，仅仅凭借IP无法找到相应的站点。通过域名访问就可以借助HOST分辨到底是要访问哪个站点。如果使用虚拟主机技术，那么利用HOST + IP的方式就可以访问；如果使用反向代理技术，通过代理服务器找到站点实际服务器的IP也可以访问。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WireShark基本操作]]></title>
    <url>%2F2019%2F09%2F16%2FWireShark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 拦截本地回环数据（需要的时候再开启）机访问本机的回环数据是不经过网卡的，比如我们在本机访问搭建在本机上的web服务，但我们经常有服务搭建在本机的操作也经常有拦截本地回环数据包加以分析的需求，所以我们环要拦载回环数据包。操作如下。 首先，以管理员身份运行cmd（普通用户没有路由表操作权限，会提示“请求的操作需要提升”） 然后，使用ipconfig查看本机ip和网关： ipconfig 再然后，使用以下命令添加路由，指定回环数据也要先转发到网关（使用上一步获取本的本机ip和网关替换其中的和）： route add &lt;your_IP&gt; mask 255.255.255.255 &lt;gateway_IP&gt; metric 1 最后，查看路由表中路由是否已添加成功： route print 回环数据经网关再回来会增加网卡的压力，可使用以下命令删除路由（使用前边获取本的本机ip替换其中的）： route delete &lt;your_IP&gt; 2. WireShark 界面说明 区域1：该区域展示的是wireshark捕获到的所有数据包的列表。注意最后一列Info列是wireshark组织的说明列并不一定是该数据包中的原始内容。 区域 2：该区域是区域 1 中选定的数据包的分协议层展示。 区域 3：该区域是区域 1 中选定的数据包的源数据，其中左侧是十六进制表示右侧是ASCII码表示。另外在2号窗口中选中某层或某字段，3号窗口对应位置也会被高亮。 2. 捕获过滤器表达式在欢迎页面可以看到管理捕获过滤器。 打开以后，可以看到过滤器的各种写法。 3. 显示过滤器表达式及其书写规律显示过滤器会在WireShark捕获数据包之后，按照过滤表达的条件，有选择性地显示已经捕获的所有数据包。 3.1. 基本过滤表达式一个基本的表达式由过滤项、过滤关系、过滤值三个部分组成。 比如ip.addr == 192.168.1.1这条表达式 ip.addr是过滤项 == 是过滤关系 192.168.1.1是过滤值 表达式的意思为找出所有ip协议中源或目标地址为192.168.1.1的数据包。 3.1.1. 过滤项==过滤项 = 协议 + 协议字段== 以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。 当在应用过滤显示器中输入时，会有相应的提示。 3.1.2. 过滤关系过滤关系可以使用“English”和“C-like”两种方式，例如“==”可以写作“eq”。 3.1.3 过滤值不解释。 ###3.2. 复合规律表达式 English C-like Description Example and &amp;&amp; Logical AND ip.src==10.0.0.5 and tcp.flags.fin or || Logical OR ip.scr==10.0.0.5 or ip.src==192.1.1.1 xor ^^ Logical XOR tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! Logical NOT not llc […] Subsequence See “Slice Operator” below. in Set Membership http.request.method in {&quot;HEAD&quot; &quot;GET&quot;}. See “Membership Operator” below. 3.3. 常见用显示过滤需求及其对应表达式数据链路层： 筛选mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包—-eth.src == 04:f9:38:ad:13:26 网络层： 筛选ip地址为192.168.1.1的数据包—-ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据—- ip contains “192.168.1” 筛选192.168.1.1和192.168.1.2之间的数据包—-ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包—-ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2 传输层： 筛选tcp协议的数据包—-tcp 筛选除tcp协议以外的数据包—-!tcp 筛选端口为80的数据包—-tcp.port == 80 筛选12345端口和80端口之间的数据包—-tcp.port == 12345 &amp;&amp; tcp.port == 80 筛选从12345端口到80端口的数据包—-tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80 应用层： 特别说明—-http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包—-http.request.uri contains “.php” 筛选内容包含username的http数据包—-http contains “username”]]></content>
      <categories>
        <category>计算机网络</category>
        <category>WireShark</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>WireShark</tag>
      </tags>
  </entry>
</search>
